;; ../../../../spec/0-aux.watsup:18.1-18.21
def $sum



;; ../../../../spec/0-aux.watsup:19.1-19.21
def $max



;; ../../../../spec/0-aux.watsup:20.1-20.21
def $min



;; ../../../../spec/0-aux.watsup:26.1-27.17
def $int_to_text



;; ../../../../spec/0-aux.watsup:29.1-30.17
def $concat_text(text*{text <- text*})

1. Case analysis on text*{text <- text*}

  1. Case (% matches pattern [])

    1. Return ""

  2. Case (% matches pattern _ :: _)

    1. (Let t :: t'*{t' <- t'*} be text*{text <- text*})

    2. Return t ++ $concat_text(t'*{t' <- t'*})

;; ../../../../spec/0-aux.watsup:35.1-35.37
def $strip_prefix



;; ../../../../spec/0-aux.watsup:36.1-36.37
def $strip_suffix



;; ../../../../spec/0-aux.watsup:42.1-42.23
def $init_(nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return (nat' - 1) :: $init_((nat' - 1))

;; ../../../../spec/0-aux.watsup:47.1-47.29
def $repeat_<X>(X, nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return [X] ++ $repeat_<X>(X, (nat' - 1))

;; ../../../../spec/0-aux.watsup:53.1-54.26
def $rev_<X>



;; ../../../../spec/0-aux.watsup:56.1-57.23
def $concat_<X>



;; ../../../../spec/0-aux.watsup:59.1-59.39
def $partition_<X>



;; ../../../../spec/0-aux.watsup:61.1-62.23
def $assoc_<X, Y>



;; ../../../../spec/0-aux.watsup:64.1-65.28
def $distinct_<K>



;; ../../../../spec/0-aux.watsup:71.17-71.24
syntax set<K> = 
   | `{%}`(K*)

;; ../../../../spec/0-aux.watsup:73.1-74.43
def $empty_set<K>

1. Return ({ [] })

;; ../../../../spec/0-aux.watsup:77.1-78.36
def $in_set<K>(K, ({ K'*{K' <- K'*} }))

1. Return K is in K'*{K' <- K'*}

;; ../../../../spec/0-aux.watsup:81.1-82.37
def $intersect_set<K>



;; ../../../../spec/0-aux.watsup:84.1-85.37
def $union_set<K>



;; ../../../../spec/0-aux.watsup:87.1-88.37
def $unions_set<K>



;; ../../../../spec/0-aux.watsup:90.1-91.42
def $diff_set<K>



;; ../../../../spec/0-aux.watsup:93.1-94.40
def $sub_set<K>



;; ../../../../spec/0-aux.watsup:96.1-97.33
def $eq_set<K>



;; ../../../../spec/0-aux.watsup:103.21-103.27
syntax pair<K, V> = 
   | `%->%`(K, V)

;; ../../../../spec/0-aux.watsup:106.20-106.37
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec/0-aux.watsup:108.1-109.43
def $empty_map<K, V>

1. Return ({ [] })

;; ../../../../spec/0-aux.watsup:113.1-114.55
def $dom_map<K, V>(({ (K -> V)*{K <- K*, V <- V*} }))

1. Return ({ K*{K <- K*} })

;; ../../../../spec/0-aux.watsup:118.1-119.25
def $find_map<K, V>



;; ../../../../spec/0-aux.watsup:121.1-122.25
def $find_maps<K, V>



;; ../../../../spec/0-aux.watsup:124.1-125.71
def $add_map<K, V>



;; ../../../../spec/0-aux.watsup:127.1-128.71
def $adds_map<K, V>



;; ../../../../spec/0-aux.watsup:130.1-131.71
def $update_map<K, V>



;; ../../../../spec/1a-syntax-el.watsup:5.15-5.18
syntax bits = int

;; ../../../../spec/1a-syntax-el.watsup:6.16-6.19
syntax width = nat

;; ../../../../spec/1a-syntax-el.watsup:9.1-11.39
syntax num = 
   | `INT%`(int)
   | `FINT%%`(width, bits)
   | `FBIT%%`(width, bits)

;; ../../../../spec/1a-syntax-el.watsup:21.13-21.17
syntax id = text

;; ../../../../spec/1a-syntax-el.watsup:28.1-29.29
syntax name = 
   | `TOP%`(id)
   | `CURRENT%`(id)

;; ../../../../spec/1a-syntax-el.watsup:35.17-35.19
syntax member = id

;; ../../../../spec/1a-syntax-el.watsup:41.20-41.22
syntax matchkind = id

;; ../../../../spec/1a-syntax-el.watsup:47.21-47.23
syntax statelabel = id

;; ../../../../spec/1a-syntax-el.watsup:54.1-57.35
syntax unop = 
   | `BNOT`()
   | `LNOT`()
   | `UPLUS`()
   | `UMINUS`()

;; ../../../../spec/1a-syntax-el.watsup:64.1-84.36
syntax binop = 
   | `PLUS`()
   | `SPLUS`()
   | `MINUS`()
   | `SMINUS`()
   | `MUL`()
   | `DIV`()
   | `MOD`()
   | `SHL`()
   | `SHR`()
   | `LE`()
   | `GE`()
   | `LT`()
   | `GT`()
   | `EQ`()
   | `NE`()
   | `BAND`()
   | `BXOR`()
   | `BOR`()
   | `CONCAT`()
   | `LAND`()
   | `LOR`()

;; ../../../../spec/1a-syntax-el.watsup:90.14-90.37
syntax dir = 
   | `NO`()
   | `IN`()
   | `OUT`()
   | `INOUT`()

;; ../../../../spec/1a-syntax-el.watsup:103.1-117.36
syntax type = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(expr)
   | `FBitT%`(expr)
   | `VBitT%`(expr)
   | `StackT%%`(type, expr)
   | `ListT%`(type)
   | `TupleT%`(type*)
   | `NameT%`(name)
   | `SpecT%%`(name, type*)
   | `AnyT`()

;; ../../../../spec/1a-syntax-el.watsup:123.17-123.19
syntax tparam = id

;; ../../../../spec/1a-syntax-el.watsup:129.16-129.33
syntax param = 
   | `%%%%`(id, dir, type, expr?)

;; ../../../../spec/1a-syntax-el.watsup:135.17-135.22
syntax cparam = param

;; ../../../../spec/1a-syntax-el.watsup:141.15-141.19
syntax targ = type

;; ../../../../spec/1a-syntax-el.watsup:148.1-150.33
syntax arg = 
   | `ExprA%`(expr)
   | `NameA%%`(id, expr?)
   | `AnyA`()

;; ../../../../spec/1a-syntax-el.watsup:157.1-159.29
syntax keyset = 
   | `ExprK%`(expr)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec/1a-syntax-el.watsup:165.21-165.39
syntax selectcase = 
   | `%%`(keyset*, statelabel)

;; ../../../../spec/1a-syntax-el.watsup:173.1-198.108
syntax expr = 
   | `BoolE%`(bool)
   | `StrE%`(text)
   | `NumE%`(num)
   | `NameE%`(name)
   | `SeqE%`(expr*)
   | `SeqDefaultE%`(expr*)
   | `RecordE%`((member, expr)*)
   | `RecordDefaultE%`((member, expr)*)
   | `DefaultE`()
   | `InvalidE`()
   | `UnE%%`(unop, expr)
   | `BinE%%%`(binop, expr, expr)
   | `TernE%%%`(expr, expr, expr)
   | `CastE%%`(type, expr)
   | `MaskE%%`(expr, expr)
   | `RangeE%%`(expr, expr)
   | `SelectE%%`(expr*, selectcase*)
   | `ArrAccE%%`(expr, expr)
   | `BitAccE%%%`(expr, expr, expr)
   | `ErrAccE%`(member)
   | `TypeAccE%%`(name, member)
   | `ExprAccE%%`(expr, member)
   | `CallFuncE%%%`(name, targ*, arg*)
   | `CallMethodE%%%%`(expr, member, targ*, arg*)
   | `CallTypeE%%%%`(name, member, targ*, arg*)
   | `InstE%%%`(name, targ*, arg*)

;; ../../../../spec/1a-syntax-el.watsup:204.16-204.71
syntax block = 
   | `BlockB%`(stmt*)

;; ../../../../spec/1a-syntax-el.watsup:211.1-222.55
syntax stmt = 
   | `EmptyS`()
   | `AssignS%%`(expr, expr)
   | `SwitchS%%`(expr, switchcase*)
   | `IfS%%%`(expr, stmt, stmt)
   | `BlockS%`(block)
   | `ExitS`()
   | `RetS%`(expr?)
   | `CallFuncS%%%`(name, targ*, arg*)
   | `CallMethodS%%%%`(expr, member, targ*, arg*)
   | `CallInstS%%%`(name, targ*, arg*)
   | `TransS%`(expr)
   | `DeclS%`(decl)

;; ../../../../spec/1a-syntax-el.watsup:229.1-230.35
syntax switchlabel = 
   | `ExprL%`(expr)
   | `DefaultL`()

;; ../../../../spec/1a-syntax-el.watsup:233.1-234.48
syntax switchcase = 
   | `MatchC%%`(switchlabel, block)
   | `FallC%`(switchlabel)

;; ../../../../spec/1a-syntax-el.watsup:240.22-240.38
syntax parserstate = 
   | `%%`(statelabel, block)

;; ../../../../spec/1a-syntax-el.watsup:246.14-246.22
syntax tbl = tblprop*

;; ../../../../spec/1a-syntax-el.watsup:252.17-252.31
syntax tblkey = 
   | `%%`(expr, matchkind)

;; ../../../../spec/1a-syntax-el.watsup:253.21-253.28
syntax tblkeyprop = tblkey*

;; ../../../../spec/1a-syntax-el.watsup:259.20-259.29
syntax tblaction = 
   | `%%`(name, arg*)

;; ../../../../spec/1a-syntax-el.watsup:260.24-260.34
syntax tblactionprop = tblaction*

;; ../../../../spec/1a-syntax-el.watsup:266.19-266.47
syntax tblentry = 
   | `%%%%`(bool, keyset*, tblaction, expr?)

;; ../../../../spec/1a-syntax-el.watsup:267.23-267.37
syntax tblentryprop = 
   | `%%`(bool, tblentry*)

;; ../../../../spec/1a-syntax-el.watsup:273.25-273.39
syntax tbldefaultprop = 
   | `%%`(bool, tblaction)

;; ../../../../spec/1a-syntax-el.watsup:279.24-279.40
syntax tblcustomprop = 
   | `%%%`(bool, member, expr)

;; ../../../../spec/1a-syntax-el.watsup:286.1-290.78
syntax tblprop = 
   | `KeyP%`(tblkeyprop)
   | `ActionP%`(tblactionprop)
   | `EntryP%`(tblentryprop)
   | `DefaultP%`(tbldefaultprop)
   | `CustomP%`(tblcustomprop)

;; ../../../../spec/1a-syntax-el.watsup:297.1-299.120
syntax method = 
   | `ExternConsM%%`(id, cparam*)
   | `ExternAbstractM%%%%`(id, type, tparam*, param*)
   | `ExternM%%%%`(id, type, tparam*, param*)

;; ../../../../spec/1a-syntax-el.watsup:308.1-330.136
syntax decl = 
   | `ConstD%%%`(id, type, expr)
   | `VarD%%%`(id, type, expr?)
   | `ErrD%`(member*)
   | `MatchKindD%`(member*)
   | `InstD%%%%%`(id, name, targ*, arg*, decl*)
   | `StructD%%%`(id, tparam*, (member, type)*)
   | `HeaderD%%%`(id, tparam*, (member, type)*)
   | `UnionD%%%`(id, tparam*, (member, type)*)
   | `EnumD%%`(id, member*)
   | `SEnumD%%%`(id, type, (member, expr)*)
   | `NewTypeD%%`(id, typedef)
   | `TypeDefD%%`(id, typedef)
   | `ValueSetD%%%`(id, type, expr)
   | `ParserTypeD%%%`(id, tparam*, param*)
   | `ParserD%%%%%`(id, param*, cparam*, decl*, parserstate*)
   | `TableD%%`(id, tbl)
   | `ControlTypeD%%%`(id, tparam*, param*)
   | `ControlD%%%%%`(id, param*, cparam*, decl*, block)
   | `ActionD%%%`(id, param*, block)
   | `FuncD%%%%%`(id, type, tparam*, param*, block)
   | `ExternFuncD%%%%`(id, type, tparam*, param*)
   | `ExternObjectD%%%`(id, tparam*, method*)
   | `PackageTypeD%%%`(id, tparam*, cparam*)

;; ../../../../spec/1a-syntax-el.watsup:333.1-334.15
syntax typedef = 
   | `TypeD%`(type)
   | `DeclD%`(decl)

;; ../../../../spec/1a-syntax-el.watsup:340.18-340.23
syntax program = decl*

;; ../../../../spec/1b-syntax-el-aux.watsup:5.1-6.27
def $is_boole(expr')

1. If ((expr' matches pattern `BoolE%`)), then

  1. (Let (BoolE _bool) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:11.1-12.26
def $is_stre(expr')

1. If ((expr' matches pattern `StrE%`)), then

  1. (Let (StrE _text) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:17.1-18.26
def $is_nume(expr')

1. If ((expr' matches pattern `NumE%`)), then

  1. (Let (NumE _num) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:23.1-24.27
def $is_namee(expr')

1. If ((expr' matches pattern `NameE%`)), then

  1. (Let (NameE _name) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:29.1-30.26
def $is_seqe(expr')

1. If ((expr' matches pattern `SeqE%`)), then

  1. (Let (SeqE _expr*{_expr <- _expr*}) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:35.1-36.34
def $is_seq_defaulte(expr')

1. If ((expr' matches pattern `SeqDefaultE%`)), then

  1. (Let (SeqDefaultE _expr*{_expr <- _expr*}) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:41.1-42.29
def $is_recorde(expr')

1. If ((expr' matches pattern `RecordE%`)), then

  1. (Let (RecordE _(member, expr)*{_(member, expr) <- _(member, expr)*}) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:47.1-48.37
def $is_record_defaulte(expr')

1. If ((expr' matches pattern `RecordDefaultE%`)), then

  1. (Let (RecordDefaultE _(member, expr)*{_(member, expr) <- _(member, expr)*}) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:53.1-54.30
def $is_defaulte(expr')

1. If ((expr' matches pattern `DefaultE`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:59.1-60.30
def $is_invalide(expr')

1. If ((expr' matches pattern `InvalidE`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:65.1-66.25
def $is_une(expr')

1. If ((expr' matches pattern `UnE%%`)), then

  1. (Let (UnE _unop _expr) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:71.1-72.26
def $is_bine(expr')

1. If ((expr' matches pattern `BinE%%%`)), then

  1. (Let (BinE _binop _expr _expr') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:77.1-78.27
def $is_terne(expr')

1. If ((expr' matches pattern `TernE%%%`)), then

  1. (Let (TernE _expr _expr' _expr'') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:83.1-84.27
def $is_caste(expr')

1. If ((expr' matches pattern `CastE%%`)), then

  1. (Let (CastE _type _expr) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:89.1-90.27
def $is_maske(expr')

1. If ((expr' matches pattern `MaskE%%`)), then

  1. (Let (MaskE _expr _expr') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:95.1-96.28
def $is_rangee(expr')

1. If ((expr' matches pattern `RangeE%%`)), then

  1. (Let (RangeE _expr _expr') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:101.1-102.29
def $is_selecte(expr')

1. If ((expr' matches pattern `SelectE%%`)), then

  1. (Let (SelectE _expr*{_expr <- _expr*} _selectcase*{_selectcase <- _selectcase*}) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:107.1-108.29
def $is_arracce(expr')

1. If ((expr' matches pattern `ArrAccE%%`)), then

  1. (Let (ArrAccE _expr _expr') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:113.1-114.29
def $is_bitacce(expr')

1. If ((expr' matches pattern `BitAccE%%%`)), then

  1. (Let (BitAccE _expr _expr' _expr'') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:119.1-120.29
def $is_erracce(expr')

1. If ((expr' matches pattern `ErrAccE%`)), then

  1. (Let (ErrAccE _member) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:125.1-126.30
def $is_typacce(expr')

1. If ((expr' matches pattern `TypeAccE%%`)), then

  1. (Let (TypeAccE _name _member) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:131.1-132.30
def $is_expracce(expr')

1. If ((expr' matches pattern `ExprAccE%%`)), then

  1. (Let (ExprAccE _expr _member) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:137.1-138.31
def $is_callfunce(expr')

1. If ((expr' matches pattern `CallFuncE%%%`)), then

  1. (Let (CallFuncE _name _targ*{_targ <- _targ*} _arg*{_arg <- _arg*}) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:143.1-144.33
def $is_callmethode(expr')

1. If ((expr' matches pattern `CallMethodE%%%%`)), then

  1. (Let (CallMethodE _expr _member _targ*{_targ <- _targ*} _arg*{_arg <- _arg*}) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:149.1-150.31
def $is_calltype(expr')

1. If ((expr' matches pattern `CallTypeE%%%%`)), then

  1. (Let (CallTypeE _name _member _targ*{_targ <- _targ*} _arg*{_arg <- _arg*}) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:155.1-156.27
def $is_inste(expr')

1. If ((expr' matches pattern `InstE%%%`)), then

  1. (Let (InstE _name _targ*{_targ <- _targ*} _arg*{_arg <- _arg*}) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:165.1-166.17
def $string_of_name(name)

1. Case analysis on name

  1. Case (% matches pattern `TOP%`)

    1. (Let (TOP id) be name)

    2. Return $concat_text("." :: [id])

  2. Case (% matches pattern `CURRENT%`)

    1. (Let (CURRENT id) be name)

    2. Return id

;; ../../../../spec/1b-syntax-el-aux.watsup:175.1-176.17
def $id_of_name(name)

1. Case analysis on name

  1. Case (% matches pattern `TOP%`)

    1. (Let (TOP id) be name)

    2. Return id

  2. Case (% matches pattern `CURRENT%`)

    1. (Let (CURRENT id) be name)

    2. Return id

;; ../../../../spec/2a-runtime-domain.watsup:10.14-10.16
syntax tid = id

;; ../../../../spec/2a-runtime-domain.watsup:11.51-11.59
syntax tidset = set<tid>

;; ../../../../spec/2a-runtime-domain.watsup:13.1-14.27
def $fresh_tid



;; ../../../../spec/2a-runtime-domain.watsup:16.1-17.28
def $fresh_tids(nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return $fresh_tid :: $fresh_tids((nat' - 1))

;; ../../../../spec/2a-runtime-domain.watsup:29.14-29.28
syntax fid = 
   | `%%`(id, (id, bool)*)

;; ../../../../spec/2a-runtime-domain.watsup:30.14-30.17
syntax cid = fid

;; ../../../../spec/2a-runtime-domain.watsup:34.1-34.30
def $to_fid(id, param*{param <- param*})

1. Return (id $to_fid'(param*{param <- param*}))

;; ../../../../spec/2a-runtime-domain.watsup:35.1-35.35
def $to_fid'(param*{param <- param*})

1. Case analysis on param*{param <- param*}

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let param_h :: param_t*{param_t <- param_t*} be param*{param <- param*})

    2. (Let (id dir type expr'?{expr' <- expr'?}) be param_h)

    3. If ((expr'?{expr' <- expr'?} matches pattern (_))), then

      1. (Let ?(expr) be expr'?{expr' <- expr'?})

      2. Return (id, true) :: $to_fid'(param_t*{param_t <- param_t*})

    3. Else Phantom#0 ((param*{param <- param*} matches pattern _ :: _)) /\ (~(expr'?{expr' <- expr'?} matches pattern (_)))

    4. (Let (id dir type expr?{expr <- expr?}) be param_h)

    5. If ((expr?{expr <- expr?} matches pattern ())), then

      1. Return (id, false) :: $to_fid'(param_t*{param_t <- param_t*})

    5. Else Phantom#1 ((param*{param <- param*} matches pattern _ :: _)) /\ (~(expr?{expr <- expr?} matches pattern ()))

;; ../../../../spec/2a-runtime-domain.watsup:46.1-46.30
def $to_cid(id, param*{param <- param*})

1. Return $to_fid(id, param*{param <- param*})

;; ../../../../spec/2a-runtime-domain.watsup:54.14-54.17
syntax oid = id*

;; ../../../../spec/2b1-runtime-bitstr.watsup:5.17-5.20
syntax bitstr = int

;; ../../../../spec/2b1-runtime-bitstr.watsup:10.1-10.31
def $to_int



;; ../../../../spec/2b1-runtime-bitstr.watsup:14.1-14.34
def $to_bitstr



;; ../../../../spec/2b2-runtime-value.watsup:9.1-37.57
syntax val = 
   | `ErrV%`(member)
   | `MatchKindV%`(member)
   | `StrV%`(text)
   | `BoolV%`(bool)
   | `IntV%`(int)
   | `FIntV%%`(width, bitstr)
   | `FBitV%%`(width, bitstr)
   | `VBitV%%%`(width, width, bitstr)
   | `EnumFieldV%%`(id, member)
   | `SEnumFieldV%%%`(id, member, val)
   | `ListV%`(val*)
   | `TupleV%`(val*)
   | `StackV%%%`(val*, int, int)
   | `StructV%%`(id, (member, val)*)
   | `HeaderV%%`(id, (member, val)*)
   | `UnionV%%`(id, (member, val)*)
   | `RefV%`(oid)
   | `TableEnumFieldV%%`(id, member)
   | `TableStructV%%`(id, (member, val)*)
   | `SeqV%`(val*)
   | `SeqDefaultV%`(val*)
   | `RecordV%`((member, val)*)
   | `RecordDefaultV%`((member, val)*)
   | `DefaultV`()
   | `InvalidV`()
   | `SetV%`(setval)

;; ../../../../spec/2b2-runtime-value.watsup:40.1-42.83
syntax setval = 
   | `SingletonSet%`(val)
   | `MaskSet%%`(val, val)
   | `RangeSet%%`(val, val)

;; ../../../../spec/2b3-runtime-value-aux.watsup:3.1-3.24
def $get_num(val)

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i) be val)

    2. Return i

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs) be val)

    2. Return $to_int((w as int), bs)

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV _width bs) be val)

    2. Return bs

  4. Case (% matches pattern `VBitV%%%`)

    1. (Let (VBitV _width _width' bs) be val)

    2. Return bs

1. Else Phantom#2 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`)) /\ (~(val matches pattern `VBitV%%%`))

;; ../../../../spec/2c1-runtime-type.watsup:12.3-12.18
syntax paramtyp = 
   | `%%%%`(id, dir, typ, val?)

;; ../../../../spec/2c1-runtime-type.watsup:25.1-29.38
syntax primtyp = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()

;; ../../../../spec/2c1-runtime-type.watsup:32.1-35.78
syntax numtyp = 
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)

;; ../../../../spec/2c1-runtime-type.watsup:38.1-38.21
syntax basetyp = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)

;; ../../../../spec/2c1-runtime-type.watsup:45.1-46.98
syntax abstyp = 
   | `VarT%`(id)
   | `SpecT%%`(polytypdef, typ*)

;; ../../../../spec/2c1-runtime-type.watsup:53.1-53.57
syntax aliastyp = 
   | `DefT%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:56.1-64.89
syntax datatyp = 
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)

;; ../../../../spec/2c1-runtime-type.watsup:67.1-71.59
syntax objtyp = 
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%`(paramtyp*)
   | `ControlT%`(paramtyp*)
   | `PackageT%`(typ*)
   | `TableT%%`(id, typ)

;; ../../../../spec/2c1-runtime-type.watsup:74.1-74.32
syntax deftyp = 
   | `DefT%`(typ)
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%`(paramtyp*)
   | `ControlT%`(paramtyp*)
   | `PackageT%`(typ*)
   | `TableT%%`(id, typ)

;; ../../../../spec/2c1-runtime-type.watsup:81.1-91.55
syntax synthtyp = 
   | `DefaultT`()
   | `SeqT%`(typ*)
   | `SeqDefaultT%`(typ*)
   | `RecordT%`((member, typ)*)
   | `RecordDefaultT%`((member, typ)*)
   | `InvalidT`()
   | `SetT%`(typ)
   | `StateT`()
   | `TableEnumT%%`(id, member*)
   | `TableStructT%%`(id, (member, typ)*)
   | `AnyT`()

;; ../../../../spec/2c1-runtime-type.watsup:94.1-94.41
syntax typ = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)
   | `VarT%`(id)
   | `SpecT%%`(polytypdef, typ*)
   | `DefT%`(typ)
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%`(paramtyp*)
   | `ControlT%`(paramtyp*)
   | `PackageT%`(typ*)
   | `TableT%%`(id, typ)
   | `DefaultT`()
   | `SeqT%`(typ*)
   | `SeqDefaultT%`(typ*)
   | `RecordT%`((member, typ)*)
   | `RecordDefaultT%`((member, typ)*)
   | `InvalidT`()
   | `SetT%`(typ)
   | `StateT`()
   | `TableEnumT%%`(id, member*)
   | `TableStructT%%`(id, (member, typ)*)
   | `AnyT`()

;; ../../../../spec/2c1-runtime-type.watsup:101.3-101.12
syntax monotypdef = 
   | `MonoD%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:103.3-103.34
syntax polytypdef = 
   | `PolyD%->%`((tparam*, tparam*), typ)

;; ../../../../spec/2c1-runtime-type.watsup:106.1-107.15
syntax typdef = 
   | `MonoD%`(typ)
   | `PolyD%->%`((tparam*, tparam*), typ)

;; ../../../../spec/2c1-runtime-type.watsup:118.1-126.82
syntax functyp = 
   | `ActionT%`(paramtyp*)
   | `ExternFuncT%%`(paramtyp*, typ)
   | `FuncT%%`(paramtyp*, typ)
   | `BuiltinMethodT%%`(paramtyp*, typ)
   | `ExternMethodT%%`(paramtyp*, typ)
   | `ExternAbstractMethodT%%`(paramtyp*, typ)
   | `ParserApplyMethodT%`(paramtyp*)
   | `ControlApplyMethodT%`(paramtyp*)
   | `TableApplyMethodT%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:135.3-135.65
syntax monofuncdef = 
   | `MonoFD%`(functyp)

;; ../../../../spec/2c1-runtime-type.watsup:138.3-138.69
syntax polyfuncdef = 
   | `PolyFD%->%`((tparam*, tparam*), functyp)

;; ../../../../spec/2c1-runtime-type.watsup:141.1-142.16
syntax funcdef = 
   | `MonoFD%`(functyp)
   | `PolyFD%->%`((tparam*, tparam*), functyp)

;; ../../../../spec/2c1-runtime-type.watsup:155.3-155.52
syntax constyp = 
   | `ConsT%%`(paramtyp*, typ)

;; ../../../../spec/2c1-runtime-type.watsup:164.3-164.38
syntax consdef = 
   | `ConsD%->%`((tparam*, tparam*), constyp)

;; ../../../../spec/2c2-runtime-type-aux.watsup:7.1-8.30
def $is_base(typ)

1. If ((typ has type basetyp)), then

  1. (Let basetyp be (typ as basetyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:13.1-14.35
def $is_prim(typ)

1. If ((typ has type primtyp)), then

  1. (Let primtyp be (typ as primtyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:19.1-20.27
def $is_voidt(typ)

1. If ((typ = ((VoidT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:25.1-26.26
def $is_errt(typ)

1. If ((typ = ((ErrT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:31.1-32.33
def $is_matchkindt(typ)

1. If ((typ = ((MatchKindT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:37.1-38.26
def $is_strt(typ)

1. If ((typ = ((StrT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:43.1-44.27
def $is_boolt(typ)

1. If ((typ = ((BoolT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:49.1-50.33
def $is_num(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:55.1-56.24
def $is_intt(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:61.1-62.25
def $is_fintt(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. If ((numtyp matches pattern `FIntT%`)), then

    1. (Let (FIntT _width) be numtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:67.1-68.27
def $is_fbitt(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. If ((numtyp matches pattern `FBitT%`)), then

    1. (Let (FBitT _width) be numtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:73.1-74.27
def $is_vbitt(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. If ((numtyp matches pattern `VBitT%`)), then

    1. (Let (VBitT _width) be numtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:79.1-80.34
def $is_abstract(typ)

1. If ((typ has type abstyp)), then

  1. (Let abstyp be (typ as abstyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:85.1-86.26
def $is_vart(typ)

1. If ((typ has type abstyp)), then

  1. (Let abstyp be (typ as abstyp))

  2. If ((abstyp matches pattern `VarT%`)), then

    1. (Let (VarT _id) be abstyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:91.1-92.27
def $is_spect(typ)

1. If ((typ has type abstyp)), then

  1. (Let abstyp be (typ as abstyp))

  2. If ((abstyp matches pattern `SpecT%%`)), then

    1. (Let (SpecT _polytypdef _typ*{_typ <- _typ*}) be abstyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:97.1-98.33
def $is_def(typ)

1. If ((typ has type deftyp)), then

  1. (Let deftyp be (typ as deftyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:103.1-104.31
def $is_alias(typ)

1. If ((typ has type aliastyp)), then

  1. (Let aliastyp be (typ as aliastyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:109.1-110.26
def $is_deft(typ)

1. If ((typ has type aliastyp)), then

  1. (Let (DefT _typ) be (typ as aliastyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:115.1-116.30
def $is_data(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:121.1-122.26
def $is_newt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `NewT%%`)), then

    1. (Let (NewT _id _typ) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:127.1-128.27
def $is_enumt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `EnumT%%`)), then

    1. (Let (EnumT _id _member*{_member <- _member*}) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:133.1-134.28
def $is_senumt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `SEnumT%%%`)), then

    1. (Let (SEnumT _id _typ _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:139.1-140.27
def $is_listt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `ListT%`)), then

    1. (Let (ListT _typ) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:145.1-146.28
def $is_tuplet(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `TupleT%`)), then

    1. (Let (TupleT _typ*{_typ <- _typ*}) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:151.1-152.28
def $is_stackt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `StackT%%`)), then

    1. (Let (StackT _typ _int) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:157.1-158.29
def $is_structt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `StructT%%`)), then

    1. (Let (StructT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:163.1-164.29
def $is_headert(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `HeaderT%%`)), then

    1. (Let (HeaderT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:169.1-170.28
def $is_uniont(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `UnionT%%`)), then

    1. (Let (UnionT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:175.1-176.32
def $is_obj(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:181.1-182.29
def $is_externt(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ExternT%%`)), then

    1. (Let (ExternT _id _map<fid, funcdef>) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:187.1-188.29
def $is_parsert(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ParserT%`)), then

    1. (Let (ParserT _paramtyp*{_paramtyp <- _paramtyp*}) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:193.1-194.30
def $is_controlt(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ControlT%`)), then

    1. (Let (ControlT _paramtyp*{_paramtyp <- _paramtyp*}) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:199.1-200.30
def $is_packaget(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `PackageT%`)), then

    1. (Let (PackageT _typ*{_typ <- _typ*}) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:205.1-206.28
def $is_tablet(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `TableT%%`)), then

    1. (Let (TableT _id _typ) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:211.1-212.37
def $is_synth(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:217.1-218.26
def $is_seqt(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. If ((synthtyp matches pattern `SeqT%`)), then

    1. (Let (SeqT _typ*{_typ <- _typ*}) be synthtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:223.1-224.29
def $is_recordt(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. If ((synthtyp matches pattern `RecordT%`)), then

    1. (Let (RecordT _(member, typ)*{_(member, typ) <- _(member, typ)*}) be synthtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:229.1-230.26
def $is_sett(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. If ((synthtyp matches pattern `SetT%`)), then

    1. (Let (SetT _typ) be synthtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:235.1-236.35
def $is_table_structt(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. If ((synthtyp matches pattern `TableStructT%%`)), then

    1. (Let (TableStructT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be synthtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:247.1-248.29
def $is_actiont(functyp)

1. If ((functyp matches pattern `ActionT%`)), then

  1. (Let (ActionT _paramtyp*{_paramtyp <- _paramtyp*}) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:253.1-254.34
def $is_externfunct(functyp)

1. If ((functyp matches pattern `ExternFuncT%%`)), then

  1. (Let (ExternFuncT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:259.1-260.27
def $is_funct(functyp)

1. If ((functyp matches pattern `FuncT%%`)), then

  1. (Let (FuncT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:265.1-266.37
def $is_builtinmethodt(functyp)

1. If ((functyp matches pattern `BuiltinMethodT%%`)), then

  1. (Let (BuiltinMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:271.1-272.36
def $is_externmethodt(functyp)

1. If ((functyp matches pattern `ExternMethodT%%`)), then

  1. (Let (ExternMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:277.1-278.45
def $is_externabstractmethodt(functyp)

1. If ((functyp matches pattern `ExternAbstractMethodT%%`)), then

  1. (Let (ExternAbstractMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:283.1-284.42
def $is_parserapplymethodt(functyp)

1. If ((functyp matches pattern `ParserApplyMethodT%`)), then

  1. (Let (ParserApplyMethodT _paramtyp*{_paramtyp <- _paramtyp*}) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:289.1-290.43
def $is_controlapplymethodt(functyp)

1. If ((functyp matches pattern `ControlApplyMethodT%`)), then

  1. (Let (ControlApplyMethodT _paramtyp*{_paramtyp <- _paramtyp*}) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:295.1-296.41
def $is_tableapplymethodt(functyp)

1. If ((functyp matches pattern `TableApplyMethodT%`)), then

  1. (Let (TableApplyMethodT _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:303.1-304.38
def $get_params_functyp(functyp)

1. Case analysis on functyp

  1. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt*{pt <- pt*}) be functyp)

    2. Return pt*{pt <- pt*}

  2. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt*{pt <- pt*} _typ) be functyp)

    2. Return pt*{pt <- pt*}

  3. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt*{pt <- pt*} _typ) be functyp)

    2. Return pt*{pt <- pt*}

  4. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt*{pt <- pt*} _typ) be functyp)

    2. Return pt*{pt <- pt*}

  5. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt*{pt <- pt*} _typ) be functyp)

    2. Return pt*{pt <- pt*}

  6. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt*{pt <- pt*}) be functyp)

    2. Return pt*{pt <- pt*}

  7. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt*{pt <- pt*}) be functyp)

    2. Return pt*{pt <- pt*}

  8. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt*{pt <- pt*} _typ) be functyp)

    2. Return pt*{pt <- pt*}

  9. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT _typ) be functyp)

    2. Return []

;; ../../../../spec/2c2-runtime-type-aux.watsup:315.1-316.39
def $get_typ_ret_functyp(functyp)

1. Case analysis on functyp

  1. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT _paramtyp*{_paramtyp <- _paramtyp*}) be functyp)

    2. Return ((VoidT) as typ)

  2. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT _paramtyp*{_paramtyp <- _paramtyp*} typ_r) be functyp)

    2. Return typ_r

  3. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT _paramtyp*{_paramtyp <- _paramtyp*} typ_r) be functyp)

    2. Return typ_r

  4. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT _paramtyp*{_paramtyp <- _paramtyp*} typ_r) be functyp)

    2. Return typ_r

  5. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT _paramtyp*{_paramtyp <- _paramtyp*} typ_r) be functyp)

    2. Return typ_r

  6. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT _paramtyp*{_paramtyp <- _paramtyp*}) be functyp)

    2. Return ((VoidT) as typ)

  7. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT _paramtyp*{_paramtyp <- _paramtyp*}) be functyp)

    2. Return ((VoidT) as typ)

  8. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT _paramtyp*{_paramtyp <- _paramtyp*} typ_r) be functyp)

    2. Return typ_r

  9. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ_r) be functyp)

    2. Return typ_r

;; ../../../../spec/2c2-runtime-type-aux.watsup:333.1-334.38
def $get_params_funcdef(funcdef)

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. Return $get_params_functyp(ft)

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD _(tparam*, tparam*) -> ft) be (funcdef as polyfuncdef))

    2. Return $get_params_functyp(ft)

;; ../../../../spec/2c2-runtime-type-aux.watsup:338.1-339.39
def $get_typ_ret_funcdef(funcdef)

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. Return $get_typ_ret_functyp(ft)

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD _(tparam*, tparam*) -> ft) be (funcdef as polyfuncdef))

    2. Return $get_typ_ret_functyp(ft)

;; ../../../../spec/2c3-runtime-type-subst.watsup:5.45-5.57
syntax theta = map<id, typ>

;; ../../../../spec/2c3-runtime-type-subst.watsup:7.1-8.44
def $free_typ(typ'')

1. Case analysis on typ''

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ'' as basetyp))

    2. Return ({ [] })

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT id) be abstyp)

        2. Return ({ [id] })

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd typ''*{typ'' <- typ''*}) be abstyp)

        2. (Let tidset_ptd be $free_typdef_poly(ptd))

        3. (Let tidset_typs be $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*}))

        4. Return $union_set<tid>(tidset_ptd, tidset_typs)

  3. Case (% has type aliastyp)

    1. (Let (DefT typ'') be (typ'' as aliastyp))

    2. Return $free_typ(typ'')

  4. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'') be datatyp)

        2. Return $free_typ(typ'')

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*{_member <- _member*}) be datatyp)

        2. Return ({ [] })

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return $free_typ(typ'')

      4. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ'') be datatyp)

        2. Return $free_typ(typ'')

      5. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*{typ'' <- typ''*}) be datatyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      6. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' _int) be datatyp)

        2. Return $free_typ(typ'')

      7. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      8. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      9. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

  5. Case (% has type objtyp)

    1. (Let objtyp be (typ'' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id ({ (_fid -> fd)*{_fid <- _fid*, fd <- fd*} })) be objtyp)

        2. Return $unions_set<tid>($free_funcdef(fd)*{fd <- fd*})

      2. Case (% matches pattern `ParserT%`)

        1. (Let (ParserT pt*{pt <- pt*}) be objtyp)

        2. (Let (_id _dir typ'' _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ'' <- typ''*}

        3. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      3. Case (% matches pattern `ControlT%`)

        1. (Let (ControlT pt*{pt <- pt*}) be objtyp)

        2. (Let (_id _dir typ'' _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ'' <- typ''*}

        3. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      4. Case (% matches pattern `PackageT%`)

        1. (Let (PackageT typ''*{typ'' <- typ''*}) be objtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT _id typ'') be objtyp)

        2. Return $free_typ(typ'')

  6. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ''*{typ'' <- typ''*}) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ''*{typ'' <- typ''*}) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      3. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

      5. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ'') be synthtyp)

        2. Return $free_typ(typ'')

      6. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT _id _member*{_member <- _member*}) be synthtyp)

        2. Return ({ [] })

      7. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*{typ'' <- typ''*})

    2. Else Phantom#3 ((typ'' has type synthtyp)) /\ (~(synthtyp matches pattern `SeqT%`)) /\ (~(synthtyp matches pattern `SeqDefaultT%`)) /\ (~(synthtyp matches pattern `RecordT%`)) /\ (~(synthtyp matches pattern `RecordDefaultT%`)) /\ (~(synthtyp matches pattern `SetT%`)) /\ (~(synthtyp matches pattern `TableEnumT%%`)) /\ (~(synthtyp matches pattern `TableStructT%%`))

2. If ((typ'' = ((DefaultT) as typ))), then

  1. Return ({ [] })

2. Else Phantom#4 (~(typ'' = ((DefaultT) as typ)))

3. If ((typ'' = ((InvalidT) as typ))), then

  1. Return ({ [] })

3. Else Phantom#5 (~(typ'' = ((InvalidT) as typ)))

4. If ((typ'' = ((StateT) as typ))), then

  1. Return ({ [] })

4. Else Phantom#6 (~(typ'' = ((StateT) as typ)))

5. If ((typ'' = ((AnyT) as typ))), then

  1. Return ({ [] })

5. Else Phantom#7 (~(typ'' = ((AnyT) as typ)))

;; ../../../../spec/2c3-runtime-type-subst.watsup:9.1-10.44
def $free_typdef_poly((PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ))

1. (Let tidset_typ be $free_typ(typ))

2. (Let tidset_tparams be ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} }))

3. Return $diff_set<tid>(tidset_typ, tidset_tparams)

;; ../../../../spec/2c3-runtime-type-subst.watsup:11.1-12.44
def $free_functyp(functyp)

1. Case analysis on functyp

  1. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt*{pt <- pt*}) be functyp)

    2. (Let (_id _dir typ _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ <- typ*}

    3. Return $unions_set<tid>($free_typ(typ)*{typ <- typ*})

  2. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt*{pt <- pt*} typ_r) be functyp)

    2. (Let (_id _dir typ_p _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*}))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  3. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt*{pt <- pt*} typ_r) be functyp)

    2. (Let (_id _dir typ_p _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*}))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  4. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt*{pt <- pt*} typ_r) be functyp)

    2. (Let (_id _dir typ_p _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*}))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  5. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt*{pt <- pt*} typ_r) be functyp)

    2. (Let (_id _dir typ_p _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*}))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  6. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt*{pt <- pt*} typ_r) be functyp)

    2. (Let (_id _dir typ_p _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*{typ_p <- typ_p*}))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  7. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt*{pt <- pt*}) be functyp)

    2. (Let (_id _dir typ _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ <- typ*}

    3. Return $unions_set<tid>($free_typ(typ)*{typ <- typ*})

  8. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt*{pt <- pt*}) be functyp)

    2. (Let (_id _dir typ _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ <- typ*}

    3. Return $unions_set<tid>($free_typ(typ)*{typ <- typ*})

  9. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ) be functyp)

    2. Return $free_typ(typ)

;; ../../../../spec/2c3-runtime-type-subst.watsup:13.1-14.44
def $free_funcdef(funcdef)

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. Return $free_functyp(ft)

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> ft) be (funcdef as polyfuncdef))

    2. (Let tidset_ft be $free_functyp(ft))

    3. (Let tidset_tparams be ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} }))

    4. Return $diff_set<tid>(tidset_ft, tidset_tparams)

;; ../../../../spec/2c3-runtime-type-subst.watsup:16.1-17.33
def $subst_typ(theta, typ''')

1. Case analysis on typ'''

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ''' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT id) be abstyp)

        2. If ($in_set<id>(id, $dom_map<id, typ>(theta))), then

          1. (Let typ''?{typ'' <- typ''?} be $find_map<id, typ>(theta, id))

          2. If ((typ''?{typ'' <- typ''?} matches pattern (_))), then

            1. (Let ?(typ) be typ''?{typ'' <- typ''?})

            2. Return typ

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd typ*{typ <- typ*}) be abstyp)

        2. (Let ptd' be $subst_typdef_poly(theta, ptd))

        3. (Let typ'''*{typ''' <- typ'''*} be $subst_typ(theta, typ)*{typ <- typ*})

        4. Return ((SpecT ptd' typ'''*{typ''' <- typ'''*}) as typ)

  2. Case (% has type aliastyp)

    1. (Let (DefT typ) be (typ''' as aliastyp))

    2. Return $subst_typ(theta, typ)

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT id typ) be datatyp)

        2. Return ((NewT id $subst_typ(theta, typ)) as typ)

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT id typ (member, val)*{member <- member*, val <- val*}) be datatyp)

        2. Return ((SEnumT id $subst_typ(theta, typ) (member, val)*{member <- member*, val <- val*}) as typ)

      3. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ) be datatyp)

        2. Return ((ListT $subst_typ(theta, typ)) as typ)

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ*{typ <- typ*}) be datatyp)

        2. Return ((TupleT $subst_typ(theta, typ)*{typ <- typ*}) as typ)

      5. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ int) be datatyp)

        2. Return ((StackT $subst_typ(theta, typ) int) as typ)

      6. Case (% matches pattern `StructT%%`)

        1. (Let (StructT id (member, typ)*{member <- member*, typ <- typ*}) be datatyp)

        2. Return ((StructT id (member, $subst_typ(theta, typ))*{member <- member*, typ <- typ*}) as typ)

      7. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT id (member, typ)*{member <- member*, typ <- typ*}) be datatyp)

        2. Return ((HeaderT id (member, $subst_typ(theta, typ))*{member <- member*, typ <- typ*}) as typ)

      8. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT id (member, typ)*{member <- member*, typ <- typ*}) be datatyp)

        2. Return ((UnionT id (member, $subst_typ(theta, typ))*{member <- member*, typ <- typ*}) as typ)

  4. Case (% has type objtyp)

    1. (Let objtyp be (typ''' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT id fmap) be objtyp)

        2. (Let ({ (fid -> funcdef)*{fid <- fid*, funcdef <- funcdef*} }) be fmap)

        3. (Let fmap' be ({ (fid -> $subst_funcdef(theta, funcdef))*{fid <- fid*, funcdef <- funcdef*} }))

        4. Return ((ExternT id fmap') as typ)

      2. Case (% matches pattern `ParserT%`)

        1. (Let (ParserT pt*{pt <- pt*}) be objtyp)

        2. (Let (id dir typ''' val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ''' <- typ'''*, val? <- val?*}

        3. (Let pt' be (id dir $subst_typ(theta, typ''') val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ''' <- typ'''*, val? <- val?*}

        4. Return ((ParserT pt'*{pt' <- pt'*}) as typ)

      3. Case (% matches pattern `ControlT%`)

        1. (Let (ControlT pt*{pt <- pt*}) be objtyp)

        2. (Let (id dir typ''' val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ''' <- typ'''*, val? <- val?*}

        3. (Let pt' be (id dir $subst_typ(theta, typ''') val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ''' <- typ'''*, val? <- val?*}

        4. Return ((ControlT pt'*{pt' <- pt'*}) as typ)

      4. Case (% matches pattern `PackageT%`)

        1. (Let (PackageT typ'''*{typ''' <- typ'''*}) be objtyp)

        2. Return ((PackageT $subst_typ(theta, typ''')*{typ''' <- typ'''*}) as typ)

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT id typ''') be objtyp)

        2. Return ((TableT id $subst_typ(theta, typ''')) as typ)

  5. Case (% has type synthtyp)

    1. (Let synthtyp be (typ''' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT id (member, typ''')*{member <- member*, typ''' <- typ'''*}) be synthtyp)

        2. Return ((TableStructT id (member, $subst_typ(theta, typ'''))*{member <- member*, typ''' <- typ'''*}) as typ)

      2. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ'''*{typ''' <- typ'''*}) be synthtyp)

        2. Return ((SeqT $subst_typ(theta, typ''')*{typ''' <- typ'''*}) as typ)

      3. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ'''*{typ''' <- typ'''*}) be synthtyp)

        2. Return ((SeqDefaultT $subst_typ(theta, typ''')*{typ''' <- typ'''*}) as typ)

      4. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member, typ''')*{member <- member*, typ''' <- typ'''*}) be synthtyp)

        2. Return ((RecordT (member, $subst_typ(theta, typ'''))*{member <- member*, typ''' <- typ'''*}) as typ)

      5. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member, typ''')*{member <- member*, typ''' <- typ'''*}) be synthtyp)

        2. Return ((RecordDefaultT (member, $subst_typ(theta, typ'''))*{member <- member*, typ''' <- typ'''*}) as typ)

      6. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ''') be synthtyp)

        2. Return ((SetT $subst_typ(theta, typ''')) as typ)

2. Otherwise

  1. Return typ'''

;; ../../../../spec/2c3-runtime-type-subst.watsup:18.1-19.33
def $subst_typdef_poly(theta, (PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ))

1. (Let ({ tid_free*{tid_free <- tid_free*} }) be $diff_set<tid>($free_typ(typ), ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} })))

2. (Let typ''?{typ'' <- typ''?} be $find_map<tid, typ>(theta, tid_free))*{tid_free <- tid_free*, typ''? <- typ''?*}

3. If ((typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}, then

  1. (Let ?(typ_free) be typ''?{typ'' <- typ''?})*{typ''? <- typ''?*, typ_free <- typ_free*}

  2. (Let tidset_capture be $unions_set<tid>($free_typ(typ_free)*{typ_free <- typ_free*}))

  3. (Let tparam'*{tparam' <- tparam'*} be $fresh_tids(|tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}|))

  4. If (~$in_set<tid>(tparam', tidset_capture))*{tparam' <- tparam'*}, then

    1. (Let tparam''*{tparam'' <- tparam''*} be tparam'*{tparam' <- tparam'*}[0 : |tparam*{tparam <- tparam*}|])

    2. (Let tparam''_hidden*{tparam''_hidden <- tparam''_hidden*} be tparam'*{tparam' <- tparam'*}[|tparam*{tparam <- tparam*}| : |tparam_hidden*{tparam_hidden <- tparam_hidden*}|])

    3. (Let theta' be $adds_map<tid, typ>(theta, tparam*{tparam <- tparam*}, ((VarT tparam'') as typ)*{tparam'' <- tparam''*}))

    4. (Let theta'' be $adds_map<tid, typ>(theta', tparam_hidden*{tparam_hidden <- tparam_hidden*}, ((VarT tparam''_hidden) as typ)*{tparam''_hidden <- tparam''_hidden*}))

    5. (Let typ' be $subst_typ(theta'', typ))

    6. Return (PolyD (tparam''*{tparam'' <- tparam''*}, tparam''_hidden*{tparam''_hidden <- tparam''_hidden*}) -> typ')

  4. Else Phantom#8 (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (exists ~~$in_set<tid>(tparam', tidset_capture))*{tparam' <- tparam'*}

3. Else Phantom#9 (exists ~(typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}

;; ../../../../spec/2c3-runtime-type-subst.watsup:20.1-21.33
def $subst_funcdef(theta, funcdef)

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. Return ((MonoFD $subst_functyp(theta, ft)) as funcdef)

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> ft) be (funcdef as polyfuncdef))

    2. (Let ({ tid_free*{tid_free <- tid_free*} }) be $diff_set<tid>($free_functyp(ft), ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} })))

    3. (Let typ?{typ <- typ?} be $find_map<tid, typ>(theta, tid_free))*{tid_free <- tid_free*, typ? <- typ?*}

    4. If ((typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}, then

      1. (Let ?(typ_free) be typ?{typ <- typ?})*{typ? <- typ?*, typ_free <- typ_free*}

      2. (Let tidset_capture be $unions_set<tid>($free_typ(typ_free)*{typ_free <- typ_free*}))

      3. (Let tparam'*{tparam' <- tparam'*} be $fresh_tids(|tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}|))

      4. If (~$in_set<tid>(tparam', tidset_capture))*{tparam' <- tparam'*}, then

        1. (Let tparam''*{tparam'' <- tparam''*} be tparam'*{tparam' <- tparam'*}[0 : |tparam*{tparam <- tparam*}|])

        2. (Let tparam''_hidden*{tparam''_hidden <- tparam''_hidden*} be tparam'*{tparam' <- tparam'*}[|tparam*{tparam <- tparam*}| : |tparam_hidden*{tparam_hidden <- tparam_hidden*}|])

        3. (Let theta' be $adds_map<tid, typ>(theta, tparam*{tparam <- tparam*}, ((VarT tparam') as typ)*{tparam' <- tparam'*}))

        4. (Let theta'' be $adds_map<tid, typ>(theta', tparam_hidden*{tparam_hidden <- tparam_hidden*}, ((VarT tparam''_hidden) as typ)*{tparam''_hidden <- tparam''_hidden*}))

        5. (Let ft' be $subst_functyp(theta'', ft))

        6. Return ((PolyFD (tparam''*{tparam'' <- tparam''*}, tparam''_hidden*{tparam''_hidden <- tparam''_hidden*}) -> ft') as funcdef)

      4. Else Phantom#10 ((funcdef has type polyfuncdef)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ (exists ~~$in_set<tid>(tparam', tidset_capture))*{tparam' <- tparam'*}

    4. Else Phantom#11 ((funcdef has type polyfuncdef)) /\ (exists ~(typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}

;; ../../../../spec/2c3-runtime-type-subst.watsup:22.1-23.33
def $subst_functyp(theta, functyp)

1. Case analysis on functyp

  1. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt*{pt <- pt*} typ) be functyp)

    2. (Let (id dir typ_p val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}

    4. Return (BuiltinMethodT pt'*{pt' <- pt'*} $subst_typ(theta, typ))

  2. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt*{pt <- pt*}) be functyp)

    2. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

    3. (Let pt' be (id dir $subst_typ(theta, typ) val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ <- typ*, val? <- val?*}

    4. Return (ActionT pt'*{pt' <- pt'*})

  3. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt*{pt <- pt*}) be functyp)

    2. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

    3. (Let pt' be (id dir $subst_typ(theta, typ) val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ <- typ*, val? <- val?*}

    4. Return (ParserApplyMethodT pt'*{pt' <- pt'*})

  4. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt*{pt <- pt*}) be functyp)

    2. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

    3. (Let pt' be (id dir $subst_typ(theta, typ) val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ <- typ*, val? <- val?*}

    4. Return (ControlApplyMethodT pt'*{pt' <- pt'*})

  5. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ) be functyp)

    2. Return (TableApplyMethodT $subst_typ(theta, typ))

  6. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt*{pt <- pt*} typ) be functyp)

    2. (Let (id dir typ_p val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}

    4. Return (ExternFuncT pt'*{pt' <- pt'*} $subst_typ(theta, typ))

  7. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt*{pt <- pt*} typ) be functyp)

    2. (Let (id dir typ_p val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}

    4. Return (FuncT pt'*{pt' <- pt'*} $subst_typ(theta, typ))

  8. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt*{pt <- pt*} typ) be functyp)

    2. (Let (id dir typ_p val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}

    4. Return (ExternMethodT pt'*{pt' <- pt'*} $subst_typ(theta, typ))

  9. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt*{pt <- pt*} typ) be functyp)

    2. (Let (id dir typ_p val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}

    4. Return (ExternAbstractMethodT pt'*{pt' <- pt'*} $subst_typ(theta, typ))

;; ../../../../spec/2c3-runtime-type-subst.watsup:24.1-25.33
def $subst_constyp(theta, (ConsT pt*{pt <- pt*} typ))

1. (Let (id dir typ_p val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ_p <- typ_p*, val? <- val?*}

2. (Let pt' be (id dir $subst_typ(theta, typ_p) val?{val <- val?}))*{dir <- dir*, id <- id*, pt' <- pt'*, typ_p <- typ_p*, val? <- val?*}

3. Return (ConsT pt'*{pt' <- pt'*} $subst_typ(theta, typ))

;; ../../../../spec/2c3-runtime-type-subst.watsup:317.1-318.57
def $specialize_typdef(typdef, typ''*{typ'' <- typ''*})

1. (Let typ' be typ'')*{typ'' <- typ''*, typ' <- typ'*}

2. If ((typdef has type monotypdef)), then

  1. (Let (MonoD typ) be (typdef as monotypdef))

  2. If ((typ'*{typ' <- typ'*} matches pattern [])), then

    1. Return typ

  2. Else Phantom#12 ((typdef has type monotypdef)) /\ (~(typ'*{typ' <- typ'*} matches pattern []))

2. Else Phantom#13 (~(typdef has type monotypdef))

3. (Let typ_a be typ'')*{typ'' <- typ''*, typ_a <- typ_a*}

4. If ((typdef has type polytypdef)), then

  1. (Let (PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ) be (typdef as polytypdef))

  2. (Let tparam'*{tparam' <- tparam'*} be tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})

  3. (Let theta be ({ (tparam' -> typ_a)*{tparam' <- tparam'*, typ_a <- typ_a*} }))

  4. Return $subst_typ(theta, typ)

4. Else Phantom#14 (~(typdef has type polytypdef))

;; ../../../../spec/2c3-runtime-type-subst.watsup:329.1-330.57
def $specialize_funcdef(funcdef, typ'*{typ' <- typ'*})

1. (Let typ be typ')*{typ' <- typ'*, typ <- typ*}

2. If ((funcdef has type monofuncdef)), then

  1. (Let (MonoFD ft) be (funcdef as monofuncdef))

  2. If ((typ*{typ <- typ*} matches pattern [])), then

    1. Return (ft, [])

  2. Else Phantom#15 ((funcdef has type monofuncdef)) /\ (~(typ*{typ <- typ*} matches pattern []))

2. Else Phantom#16 (~(funcdef has type monofuncdef))

3. (Let typ_a be typ')*{typ' <- typ'*, typ_a <- typ_a*}

4. If ((funcdef has type polyfuncdef)), then

  1. (Let (PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> ft) be (funcdef as polyfuncdef))

  2. (Let tparam'*{tparam' <- tparam'*} be tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})

  3. If ((|tparam'*{tparam' <- tparam'*}| = |typ_a*{typ_a <- typ_a*}|)), then

    1. Return ($subst_functyp(({ (tparam' -> typ_a)*{tparam' <- tparam'*, typ_a <- typ_a*} }), ft), [])

  3. Else Phantom#17 ((funcdef has type polyfuncdef)) /\ (~(|tparam'*{tparam' <- tparam'*}| = |typ_a*{typ_a <- typ_a*}|))

  4. If (((|typ_a*{typ_a <- typ_a*}| = 0) /\ (|tparam'*{tparam' <- tparam'*}| > 0))), then

    1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tparam'*{tparam' <- tparam'*}|))

    2. Return ($subst_functyp(({ (tparam' -> ((VarT tid_fresh) as typ))*{tid_fresh <- tid_fresh*, tparam' <- tparam'*} }), ft), tid_fresh*{tid_fresh <- tid_fresh*})

  4. Else Phantom#18 ((funcdef has type polyfuncdef)) /\ (~((|typ_a*{typ_a <- typ_a*}| = 0) /\ (|tparam'*{tparam' <- tparam'*}| > 0)))

  5. If ((((|typ_a*{typ_a <- typ_a*}| > 0) /\ (|tparam*{tparam <- tparam*}| = |typ_a*{typ_a <- typ_a*}|)) /\ (|tparam_hidden*{tparam_hidden <- tparam_hidden*}| > 0))), then

    1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tparam_hidden*{tparam_hidden <- tparam_hidden*}|))

    2. (Let typ_a'*{typ_a' <- typ_a'*} be typ_a*{typ_a <- typ_a*} ++ ((VarT tid_fresh) as typ)*{tid_fresh <- tid_fresh*})

    3. Return ($subst_functyp(({ (tparam' -> typ_a')*{tparam' <- tparam'*, typ_a' <- typ_a'*} }), ft), tid_fresh*{tid_fresh <- tid_fresh*})

  5. Else Phantom#19 ((funcdef has type polyfuncdef)) /\ (~(((|typ_a*{typ_a <- typ_a*}| > 0) /\ (|tparam*{tparam <- tparam*}| = |typ_a*{typ_a <- typ_a*}|)) /\ (|tparam_hidden*{tparam_hidden <- tparam_hidden*}| > 0)))

4. Else Phantom#20 (~(funcdef has type polyfuncdef))

;; ../../../../spec/2c3-runtime-type-subst.watsup:359.1-360.57
def $specialize_consdef((ConsD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> ct), typ_a*{typ_a <- typ_a*})

1. (Let tparam'*{tparam' <- tparam'*} be tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})

2. If ((|tparam'*{tparam' <- tparam'*}| = |typ_a*{typ_a <- typ_a*}|)), then

  1. Return ($subst_constyp(({ (tparam' -> typ_a)*{tparam' <- tparam'*, typ_a <- typ_a*} }), ct), [])

2. Else Phantom#21 (~(|tparam'*{tparam' <- tparam'*}| = |typ_a*{typ_a <- typ_a*}|))

3. If (((|typ_a*{typ_a <- typ_a*}| = 0) /\ (|tparam'*{tparam' <- tparam'*}| > 0))), then

  1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tparam'*{tparam' <- tparam'*}|))

  2. Return ($subst_constyp(({ (tparam' -> ((VarT tid_fresh) as typ))*{tid_fresh <- tid_fresh*, tparam' <- tparam'*} }), ct), tid_fresh*{tid_fresh <- tid_fresh*})

3. Else Phantom#22 (~((|typ_a*{typ_a <- typ_a*}| = 0) /\ (|tparam'*{tparam' <- tparam'*}| > 0)))

4. If ((((|typ_a*{typ_a <- typ_a*}| > 0) /\ (|tparam*{tparam <- tparam*}| = |typ_a*{typ_a <- typ_a*}|)) /\ (|tparam_hidden*{tparam_hidden <- tparam_hidden*}| > 0))), then

  1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tparam_hidden*{tparam_hidden <- tparam_hidden*}|))

  2. (Let typ_a'*{typ_a' <- typ_a'*} be typ_a*{typ_a <- typ_a*} ++ ((VarT tid_fresh) as typ)*{tid_fresh <- tid_fresh*})

  3. Return ($subst_constyp(({ (tparam' -> typ_a')*{tparam' <- tparam'*, typ_a' <- typ_a'*} }), ct), tid_fresh*{tid_fresh <- tid_fresh*})

4. Else Phantom#23 (~(((|typ_a*{typ_a <- typ_a*}| > 0) /\ (|tparam*{tparam <- tparam*}| = |typ_a*{typ_a <- typ_a*}|)) /\ (|tparam_hidden*{tparam_hidden <- tparam_hidden*}| > 0)))

;; ../../../../spec/2c3-runtime-type-subst.watsup:387.1-388.47
def $canon_typ(typ'')

1. Case analysis on typ''

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `SpecT%%`)), then

      1. (Let (SpecT ptd typ_a*{typ_a <- typ_a*}) be abstyp)

      2. (Let typ be $specialize_typdef((ptd as typdef), typ_a*{typ_a <- typ_a*}))

      3. Return $canon_typ(typ)

  2. Case (% has type aliastyp)

    1. (Let (DefT typ) be (typ'' as aliastyp))

    2. Return $canon_typ(typ)

2. Otherwise

  1. Return typ''

;; ../../../../spec/2c4-runtime-type-util.watsup:7.1-8.28
def $is_nominal(typ)

1. Return $is_nominal'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:9.1-9.29
def $is_nominal'(typ)

1. Case analysis on typ

  1. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*{_member <- _member*}) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return true

      4. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. Return true

      5. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. Return true

      6. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. Return true

  2. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id _map<fid, funcdef>) be objtyp)

        2. Return true

      2. Case (% matches pattern `TableT%%`)

        1. (Let (TableT _id _typ) be objtyp)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c4-runtime-type-util.watsup:25.1-26.32
def $is_deftable(typ)

1. Return $is_deftable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:27.1-27.30
def $is_deftable'(typ'')

1. If ((typ'' = ((ErrT) as typ))), then

  1. Return true

2. If ((typ'' = ((StrT) as typ))), then

  1. Return true

3. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

4. If ((typ'' = ((IntT) as typ))), then

  1. Return true

5. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT _width) be numtyp)

        2. Return true

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ') be datatyp)

        2. Return $is_deftable(typ')

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*{_member <- _member*}) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return $is_deftable(typ')

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ'*{typ' <- typ'*}) be datatyp)

        2. If ($is_deftable(typ'))*{typ' <- typ'*}, then

          1. Return true

      5. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' _int) be datatyp)

        2. Return $is_deftable(typ'')

      6. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. If ($is_deftable(typ''))*{typ'' <- typ''*}, then

          1. Return true

      7. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. If ($is_deftable(typ''))*{typ'' <- typ''*}, then

          1. Return true

      8. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. If ($is_deftable(typ''))*{typ'' <- typ''*}, then

          1. Return true

6. Otherwise

  1. Return false

;; ../../../../spec/2c4-runtime-type-util.watsup:54.1-55.30
def $is_equalable(typ)

1. Return $is_equalable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:56.1-56.31
def $is_equalable'(typ)

1. If ((typ = ((VoidT) as typ))), then

  1. Return false

2. Case analysis on typ

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return false

  2. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id _map<fid, funcdef>) be objtyp)

        2. Return false

      2. Case (% matches pattern `ParserT%`)

        1. (Let (ParserT _paramtyp*{_paramtyp <- _paramtyp*}) be objtyp)

        2. Return false

      3. Case (% matches pattern `ControlT%`)

        1. (Let (ControlT _paramtyp*{_paramtyp <- _paramtyp*}) be objtyp)

        2. Return false

      4. Case (% matches pattern `PackageT%`)

        1. (Let (PackageT _typ*{_typ <- _typ*}) be objtyp)

        2. Return false

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT _id _typ) be objtyp)

        2. Return false

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ as synthtyp))

    2. Return ($is_seqt((synthtyp as typ)) \/ $is_recordt((synthtyp as typ)))

3. Otherwise

  1. Return true

;; ../../../../spec/2c4-runtime-type-util.watsup:72.1-73.31
def $is_assignable(typ)

1. Return $is_assignable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:74.1-74.32
def $is_assignable'(typ)

1. If ((typ = ((VoidT) as typ))), then

  1. Return false

2. If ((typ = ((StrT) as typ))), then

  1. Return false

3. If ((typ = ((IntT) as typ))), then

  1. Return false

4. Case analysis on typ

  1. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. Return false

  2. Case (% has type synthtyp)

    1. (Let synthtyp be (typ as synthtyp))

    2. Return false

5. Otherwise

  1. Return true

;; ../../../../spec/2c4-runtime-type-util.watsup:89.1-89.26
def $get_width(typ)

1. Return $get_width'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:90.1-90.27
def $get_width'(typ'')

1. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return w

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return w

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT w) be numtyp)

        2. Return w

    2. Else Phantom#24 ((typ'' has type numtyp)) /\ (~(numtyp matches pattern `FIntT%`)) /\ (~(numtyp matches pattern `FBitT%`)) /\ (~(numtyp matches pattern `VBitT%`))

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $get_width(typ'')

    2. Else Phantom#25 ((typ'' has type datatyp)) /\ (~(datatyp matches pattern `NewT%%`))

1. Else Phantom#26 (~(typ'' has type numtyp)) /\ (~(typ'' has type datatyp))

;; ../../../../spec/2c5-runtime-type-alpha.watsup:5.1-7.20
relation Type_alpha: typ'', typ'''

1. Case analysis on typ''

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ'' as basetyp))

    2. If ((typ''' has type basetyp)), then

      1. (Let basetyp' be (typ''' as basetyp))

      2. If ((basetyp = basetyp')), then

        1. The relation holds

      2. Else Phantom#27 ((typ'' has type basetyp)) /\ ((typ''' has type basetyp)) /\ (~(basetyp = basetyp'))

    2. Else Phantom#28 ((typ'' has type basetyp)) /\ (~(typ''' has type basetyp))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT id) be abstyp)

        2. If ((typ''' has type abstyp)), then

          1. (Let abstyp' be (typ''' as abstyp))

          2. If ((abstyp' matches pattern `VarT%`)), then

            1. (Let (VarT id') be abstyp')

            2. If ((id = id')), then

              1. The relation holds

            2. Else Phantom#29 ((typ'' has type abstyp)) /\ ((abstyp matches pattern `VarT%`)) /\ ((typ''' has type abstyp)) /\ ((abstyp' matches pattern `VarT%`)) /\ (~(id = id'))

          2. Else Phantom#30 ((typ'' has type abstyp)) /\ ((abstyp matches pattern `VarT%`)) /\ ((typ''' has type abstyp)) /\ (~(abstyp' matches pattern `VarT%`))

        2. Else Phantom#31 ((typ'' has type abstyp)) /\ ((abstyp matches pattern `VarT%`)) /\ (~(typ''' has type abstyp))

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd_a typ_a*{typ_a <- typ_a*}) be abstyp)

        2. If ((typ''' has type abstyp)), then

          1. (Let abstyp' be (typ''' as abstyp))

          2. If ((abstyp' matches pattern `SpecT%%`)), then

            1. (Let (SpecT ptd_b typ_b*{typ_b <- typ_b*}) be abstyp')

            2. (Let typ_a' be $specialize_typdef((ptd_a as typdef), typ_a*{typ_a <- typ_a*}))

            3. (Let typ_b' be $specialize_typdef((ptd_b as typdef), typ_b*{typ_b <- typ_b*}))

            4. If ((Type_alpha: typ_a' ~~ typ_b' holds)), then

              1. If (($is_nominal(typ_a') /\ $is_nominal(typ_b'))), then

                1. If ((Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}, then

                  1. The relation holds

                1. Else Phantom#32 ((typ'' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ ((typ''' has type abstyp)) /\ ((abstyp' matches pattern `SpecT%%`)) /\ ((Type_alpha: typ_a' ~~ typ_b' holds)) /\ (($is_nominal(typ_a') /\ $is_nominal(typ_b'))) /\ (exists ~(Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}

              1. Else Phantom#33 ((typ'' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ ((typ''' has type abstyp)) /\ ((abstyp' matches pattern `SpecT%%`)) /\ ((Type_alpha: typ_a' ~~ typ_b' holds)) /\ (~($is_nominal(typ_a') /\ $is_nominal(typ_b')))

              2. If ((~$is_nominal(typ_a') /\ ~$is_nominal(typ_b'))), then

                1. The relation holds

              2. Else Phantom#34 ((typ'' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ ((typ''' has type abstyp)) /\ ((abstyp' matches pattern `SpecT%%`)) /\ ((Type_alpha: typ_a' ~~ typ_b' holds)) /\ (~(~$is_nominal(typ_a') /\ ~$is_nominal(typ_b')))

            4. Else Phantom#35 ((typ'' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ ((typ''' has type abstyp)) /\ ((abstyp' matches pattern `SpecT%%`)) /\ (~(Type_alpha: typ_a' ~~ typ_b' holds))

          2. Else Phantom#36 ((typ'' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ ((typ''' has type abstyp)) /\ (~(abstyp' matches pattern `SpecT%%`))

        2. Else Phantom#37 ((typ'' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ (~(typ''' has type abstyp))

  3. Case (% has type aliastyp)

    1. (Let (DefT typ_a) be (typ'' as aliastyp))

    2. If ((Type_alpha: typ_a ~~ typ''' holds)), then

      1. The relation holds

    2. Else Phantom#38 ((typ'' has type aliastyp)) /\ (~(Type_alpha: typ_a ~~ typ''' holds))

  4. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT id typ'') be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `NewT%%`)), then

            1. (Let (NewT id' typ''') be datatyp')

            2. If ((id = id')), then

              1. If ((Type_alpha: typ'' ~~ typ''' holds)), then

                1. The relation holds

              1. Else Phantom#39 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `NewT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `NewT%%`)) /\ ((id = id')) /\ (~(Type_alpha: typ'' ~~ typ''' holds))

            2. Else Phantom#40 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `NewT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `NewT%%`)) /\ (~(id = id'))

          2. Else Phantom#41 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `NewT%%`)) /\ ((typ''' has type datatyp)) /\ (~(datatyp' matches pattern `NewT%%`))

        2. Else Phantom#42 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `NewT%%`)) /\ (~(typ''' has type datatyp))

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT id member*{member <- member*}) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `EnumT%%`)), then

            1. (Let (EnumT id' member'*{member' <- member'*}) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*{member <- member*, member' <- member'*}, then

                1. The relation holds

              1. Else Phantom#43 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `EnumT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `EnumT%%`)) /\ ((id = id')) /\ (exists ~(member = member'))*{member <- member*, member' <- member'*}

            2. Else Phantom#44 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `EnumT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `EnumT%%`)) /\ (~(id = id'))

          2. Else Phantom#45 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `EnumT%%`)) /\ ((typ''' has type datatyp)) /\ (~(datatyp' matches pattern `EnumT%%`))

        2. Else Phantom#46 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `EnumT%%`)) /\ (~(typ''' has type datatyp))

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT id typ'' (member, val_a)*{member <- member*, val_a <- val_a*}) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `SEnumT%%%`)), then

            1. (Let (SEnumT id' typ''' (member', val_b)*{member' <- member'*, val_b <- val_b*}) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*{member <- member*, member' <- member'*}, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds)), then

                  1. If ((val_a = val_b))*{val_a <- val_a*, val_b <- val_b*}, then

                    1. The relation holds

                  1. Else Phantom#47 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `SEnumT%%%`)) /\ ((id = id')) /\ (forall (member = member'))*{member <- member*, member' <- member'*} /\ ((Type_alpha: typ'' ~~ typ''' holds)) /\ (exists ~(val_a = val_b))*{val_a <- val_a*, val_b <- val_b*}

                1. Else Phantom#48 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `SEnumT%%%`)) /\ ((id = id')) /\ (forall (member = member'))*{member <- member*, member' <- member'*} /\ (~(Type_alpha: typ'' ~~ typ''' holds))

              1. Else Phantom#49 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `SEnumT%%%`)) /\ ((id = id')) /\ (exists ~(member = member'))*{member <- member*, member' <- member'*}

            2. Else Phantom#50 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `SEnumT%%%`)) /\ (~(id = id'))

          2. Else Phantom#51 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ ((typ''' has type datatyp)) /\ (~(datatyp' matches pattern `SEnumT%%%`))

        2. Else Phantom#52 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ (~(typ''' has type datatyp))

      4. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ'') be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `ListT%`)), then

            1. (Let (ListT typ''') be datatyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds)), then

              1. The relation holds

            2. Else Phantom#53 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `ListT%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `ListT%`)) /\ (~(Type_alpha: typ'' ~~ typ''' holds))

          2. Else Phantom#54 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `ListT%`)) /\ ((typ''' has type datatyp)) /\ (~(datatyp' matches pattern `ListT%`))

        2. Else Phantom#55 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `ListT%`)) /\ (~(typ''' has type datatyp))

      5. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*{typ'' <- typ''*}) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `TupleT%`)), then

            1. (Let (TupleT typ'''*{typ''' <- typ'''*}) be datatyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

              1. The relation holds

            2. Else Phantom#56 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `TupleT%`)) /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

          2. Else Phantom#57 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ ((typ''' has type datatyp)) /\ (~(datatyp' matches pattern `TupleT%`))

        2. Else Phantom#58 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ (~(typ''' has type datatyp))

      6. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' i_size) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `StackT%%`)), then

            1. (Let (StackT typ''' i_size') be datatyp')

            2. If ((i_size = i_size')), then

              1. If ((Type_alpha: typ'' ~~ typ''' holds)), then

                1. The relation holds

              1. Else Phantom#59 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `StackT%%`)) /\ ((i_size = i_size')) /\ (~(Type_alpha: typ'' ~~ typ''' holds))

            2. Else Phantom#60 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `StackT%%`)) /\ (~(i_size = i_size'))

          2. Else Phantom#61 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ ((typ''' has type datatyp)) /\ (~(datatyp' matches pattern `StackT%%`))

        2. Else Phantom#62 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~(typ''' has type datatyp))

      7. Case (% matches pattern `StructT%%`)

        1. (Let (StructT id (member, typ'')*{member <- member*, typ'' <- typ''*}) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `StructT%%`)), then

            1. (Let (StructT id' (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*{member <- member*, member' <- member'*}, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

                  1. The relation holds

                1. Else Phantom#63 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `StructT%%`)) /\ ((id = id')) /\ (forall (member = member'))*{member <- member*, member' <- member'*} /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

              1. Else Phantom#64 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `StructT%%`)) /\ ((id = id')) /\ (exists ~(member = member'))*{member <- member*, member' <- member'*}

            2. Else Phantom#65 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `StructT%%`)) /\ (~(id = id'))

          2. Else Phantom#66 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ((typ''' has type datatyp)) /\ (~(datatyp' matches pattern `StructT%%`))

        2. Else Phantom#67 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~(typ''' has type datatyp))

      8. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT id (member, typ'')*{member <- member*, typ'' <- typ''*}) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `HeaderT%%`)), then

            1. (Let (HeaderT id' (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*{member <- member*, member' <- member'*}, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

                  1. The relation holds

                1. Else Phantom#68 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `HeaderT%%`)) /\ ((id = id')) /\ (forall (member = member'))*{member <- member*, member' <- member'*} /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

              1. Else Phantom#69 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `HeaderT%%`)) /\ ((id = id')) /\ (exists ~(member = member'))*{member <- member*, member' <- member'*}

            2. Else Phantom#70 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `HeaderT%%`)) /\ (~(id = id'))

          2. Else Phantom#71 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ((typ''' has type datatyp)) /\ (~(datatyp' matches pattern `HeaderT%%`))

        2. Else Phantom#72 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~(typ''' has type datatyp))

      9. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT id (member, typ'')*{member <- member*, typ'' <- typ''*}) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `UnionT%%`)), then

            1. (Let (UnionT id' (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*{member <- member*, member' <- member'*}, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

                  1. The relation holds

                1. Else Phantom#73 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `UnionT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `UnionT%%`)) /\ ((id = id')) /\ (forall (member = member'))*{member <- member*, member' <- member'*} /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

              1. Else Phantom#74 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `UnionT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `UnionT%%`)) /\ ((id = id')) /\ (exists ~(member = member'))*{member <- member*, member' <- member'*}

            2. Else Phantom#75 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `UnionT%%`)) /\ ((typ''' has type datatyp)) /\ ((datatyp' matches pattern `UnionT%%`)) /\ (~(id = id'))

          2. Else Phantom#76 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `UnionT%%`)) /\ ((typ''' has type datatyp)) /\ (~(datatyp' matches pattern `UnionT%%`))

        2. Else Phantom#77 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `UnionT%%`)) /\ (~(typ''' has type datatyp))

  5. Case (% has type objtyp)

    1. (Let objtyp be (typ'' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT id fmap_a) be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `ExternT%%`)), then

            1. (Let (ExternT id' fmap_b) be objtyp')

            2. If ((id = id')), then

              1. (Let ({ (fid_a -> fd_a)*{fd_a <- fd_a*, fid_a <- fid_a*} }) be fmap_a)

              2. (Let ({ (fid_b -> fd_b)*{fd_b <- fd_b*, fid_b <- fid_b*} }) be fmap_b)

              3. If ($eq_set<fid>(({ fid_a*{fid_a <- fid_a*} }), ({ fid_b*{fid_b <- fid_b*} }))), then

                1. (Let funcdef?{funcdef <- funcdef?} be $find_map<fid, funcdef>(fmap_a, fid_a))*{fid_a <- fid_a*, funcdef? <- funcdef?*}

                2. If ((funcdef?{funcdef <- funcdef?} matches pattern (_)))*{funcdef? <- funcdef?*}, then

                  1. (Let ?(fd_a') be funcdef?{funcdef <- funcdef?})*{fd_a' <- fd_a'*, funcdef? <- funcdef?*}

                  2. (Let funcdef'?{funcdef' <- funcdef'?} be $find_map<fid, funcdef>(fmap_b, fid_a))*{fid_a <- fid_a*, funcdef'? <- funcdef'?*}

                  3. If ((funcdef'?{funcdef' <- funcdef'?} matches pattern (_)))*{funcdef'? <- funcdef'?*}, then

                    1. (Let ?(fd_b') be funcdef'?{funcdef' <- funcdef'?})*{fd_b' <- fd_b'*, funcdef'? <- funcdef'?*}

                    2. If ((FuncDef_alpha: fd_a' ~~ fd_b' holds))*{fd_a' <- fd_a'*, fd_b' <- fd_b'*}, then

                      1. The relation holds

                    2. Else Phantom#78 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `ExternT%%`)) /\ ((id = id')) /\ ($eq_set<fid>(({ fid_a*{fid_a <- fid_a*} }), ({ fid_b*{fid_b <- fid_b*} }))) /\ (forall (funcdef?{funcdef <- funcdef?} matches pattern (_)))*{funcdef? <- funcdef?*} /\ (forall (funcdef'?{funcdef' <- funcdef'?} matches pattern (_)))*{funcdef'? <- funcdef'?*} /\ (exists ~(FuncDef_alpha: fd_a' ~~ fd_b' holds))*{fd_a' <- fd_a'*, fd_b' <- fd_b'*}

                  3. Else Phantom#79 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `ExternT%%`)) /\ ((id = id')) /\ ($eq_set<fid>(({ fid_a*{fid_a <- fid_a*} }), ({ fid_b*{fid_b <- fid_b*} }))) /\ (forall (funcdef?{funcdef <- funcdef?} matches pattern (_)))*{funcdef? <- funcdef?*} /\ (exists ~(funcdef'?{funcdef' <- funcdef'?} matches pattern (_)))*{funcdef'? <- funcdef'?*}

                2. Else Phantom#80 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `ExternT%%`)) /\ ((id = id')) /\ ($eq_set<fid>(({ fid_a*{fid_a <- fid_a*} }), ({ fid_b*{fid_b <- fid_b*} }))) /\ (exists ~(funcdef?{funcdef <- funcdef?} matches pattern (_)))*{funcdef? <- funcdef?*}

              3. Else Phantom#81 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `ExternT%%`)) /\ ((id = id')) /\ (~$eq_set<fid>(({ fid_a*{fid_a <- fid_a*} }), ({ fid_b*{fid_b <- fid_b*} })))

            2. Else Phantom#82 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `ExternT%%`)) /\ (~(id = id'))

          2. Else Phantom#83 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ ((typ''' has type objtyp)) /\ (~(objtyp' matches pattern `ExternT%%`))

        2. Else Phantom#84 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ (~(typ''' has type objtyp))

      2. Case (% matches pattern `ParserT%`)

        1. (Let (ParserT pt_a*{pt_a <- pt_a*}) be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `ParserT%`)), then

            1. (Let (ParserT pt_b*{pt_b <- pt_b*}) be objtyp')

            2. (Let (_id dir_a typ'' _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ'' <- typ''*}

            3. (Let (_id' dir_b typ''' _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ''' <- typ'''*}

            4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

              1. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

                1. The relation holds

              1. Else Phantom#85 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ParserT%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `ParserT%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

            4. Else Phantom#86 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ParserT%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `ParserT%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

          2. Else Phantom#87 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ParserT%`)) /\ ((typ''' has type objtyp)) /\ (~(objtyp' matches pattern `ParserT%`))

        2. Else Phantom#88 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ParserT%`)) /\ (~(typ''' has type objtyp))

      3. Case (% matches pattern `ControlT%`)

        1. (Let (ControlT pt_a*{pt_a <- pt_a*}) be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `ControlT%`)), then

            1. (Let (ControlT pt_b*{pt_b <- pt_b*}) be objtyp')

            2. (Let (_id dir_a typ'' _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ'' <- typ''*}

            3. (Let (_id' dir_b typ''' _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ''' <- typ'''*}

            4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

              1. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

                1. The relation holds

              1. Else Phantom#89 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ControlT%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `ControlT%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

            4. Else Phantom#90 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ControlT%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `ControlT%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

          2. Else Phantom#91 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ControlT%`)) /\ ((typ''' has type objtyp)) /\ (~(objtyp' matches pattern `ControlT%`))

        2. Else Phantom#92 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ControlT%`)) /\ (~(typ''' has type objtyp))

      4. Case (% matches pattern `PackageT%`)

        1. (Let (PackageT typ''*{typ'' <- typ''*}) be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `PackageT%`)), then

            1. (Let (PackageT typ'''*{typ''' <- typ'''*}) be objtyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

              1. The relation holds

            2. Else Phantom#93 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `PackageT%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `PackageT%`)) /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

          2. Else Phantom#94 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `PackageT%`)) /\ ((typ''' has type objtyp)) /\ (~(objtyp' matches pattern `PackageT%`))

        2. Else Phantom#95 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `PackageT%`)) /\ (~(typ''' has type objtyp))

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT id typ'') be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `TableT%%`)), then

            1. (Let (TableT id' typ''') be objtyp')

            2. If ((id = id')), then

              1. If ((Type_alpha: typ'' ~~ typ''' holds)), then

                1. The relation holds

              1. Else Phantom#96 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `TableT%%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `TableT%%`)) /\ ((id = id')) /\ (~(Type_alpha: typ'' ~~ typ''' holds))

            2. Else Phantom#97 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `TableT%%`)) /\ ((typ''' has type objtyp)) /\ ((objtyp' matches pattern `TableT%%`)) /\ (~(id = id'))

          2. Else Phantom#98 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `TableT%%`)) /\ ((typ''' has type objtyp)) /\ (~(objtyp' matches pattern `TableT%%`))

        2. Else Phantom#99 ((typ'' has type objtyp)) /\ ((objtyp matches pattern `TableT%%`)) /\ (~(typ''' has type objtyp))

  6. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ''*{typ'' <- typ''*}) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `SeqT%`)), then

            1. (Let (SeqT typ'''*{typ''' <- typ'''*}) be synthtyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

              1. The relation holds

            2. Else Phantom#100 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `SeqT%`)) /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

          2. Else Phantom#101 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ''' has type synthtyp)) /\ (~(synthtyp' matches pattern `SeqT%`))

        2. Else Phantom#102 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ (~(typ''' has type synthtyp))

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ''*{typ'' <- typ''*}) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `SeqDefaultT%`)), then

            1. (Let (SeqDefaultT typ'''*{typ''' <- typ'''*}) be synthtyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

              1. The relation holds

            2. Else Phantom#103 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `SeqDefaultT%`)) /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

          2. Else Phantom#104 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ''' has type synthtyp)) /\ (~(synthtyp' matches pattern `SeqDefaultT%`))

        2. Else Phantom#105 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ (~(typ''' has type synthtyp))

      3. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member, typ'')*{member <- member*, typ'' <- typ''*}) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `RecordT%`)), then

            1. (Let (RecordT (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) be synthtyp')

            2. If ((member = member'))*{member <- member*, member' <- member'*}, then

              1. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

                1. The relation holds

              1. Else Phantom#106 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `RecordT%`)) /\ (forall (member = member'))*{member <- member*, member' <- member'*} /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

            2. Else Phantom#107 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `RecordT%`)) /\ (exists ~(member = member'))*{member <- member*, member' <- member'*}

          2. Else Phantom#108 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ''' has type synthtyp)) /\ (~(synthtyp' matches pattern `RecordT%`))

        2. Else Phantom#109 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ (~(typ''' has type synthtyp))

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member, typ'')*{member <- member*, typ'' <- typ''*}) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `RecordDefaultT%`)), then

            1. (Let (RecordDefaultT (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) be synthtyp')

            2. If ((member = member'))*{member <- member*, member' <- member'*}, then

              1. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

                1. The relation holds

              1. Else Phantom#110 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `RecordDefaultT%`)) /\ (forall (member = member'))*{member <- member*, member' <- member'*} /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

            2. Else Phantom#111 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `RecordDefaultT%`)) /\ (exists ~(member = member'))*{member <- member*, member' <- member'*}

          2. Else Phantom#112 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ''' has type synthtyp)) /\ (~(synthtyp' matches pattern `RecordDefaultT%`))

        2. Else Phantom#113 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ (~(typ''' has type synthtyp))

      5. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ'') be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `SetT%`)), then

            1. (Let (SetT typ''') be synthtyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds)), then

              1. The relation holds

            2. Else Phantom#114 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `SetT%`)) /\ (~(Type_alpha: typ'' ~~ typ''' holds))

          2. Else Phantom#115 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ ((typ''' has type synthtyp)) /\ (~(synthtyp' matches pattern `SetT%`))

        2. Else Phantom#116 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ (~(typ''' has type synthtyp))

      6. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT id member*{member <- member*}) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `TableEnumT%%`)), then

            1. (Let (TableEnumT id' member'*{member' <- member'*}) be synthtyp')

            2. If ((id = id')), then

              1. If ((member = member'))*{member <- member*, member' <- member'*}, then

                1. The relation holds

              1. Else Phantom#117 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `TableEnumT%%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `TableEnumT%%`)) /\ ((id = id')) /\ (exists ~(member = member'))*{member <- member*, member' <- member'*}

            2. Else Phantom#118 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `TableEnumT%%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `TableEnumT%%`)) /\ (~(id = id'))

          2. Else Phantom#119 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `TableEnumT%%`)) /\ ((typ''' has type synthtyp)) /\ (~(synthtyp' matches pattern `TableEnumT%%`))

        2. Else Phantom#120 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `TableEnumT%%`)) /\ (~(typ''' has type synthtyp))

      7. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT id (member, typ'')*{member <- member*, typ'' <- typ''*}) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `TableStructT%%`)), then

            1. (Let (TableStructT id' (member', typ''')*{member' <- member'*, typ''' <- typ'''*}) be synthtyp')

            2. If ((id = id')), then

              1. If ((member = member'))*{member <- member*, member' <- member'*}, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}, then

                  1. The relation holds

                1. Else Phantom#121 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `TableStructT%%`)) /\ ((id = id')) /\ (forall (member = member'))*{member <- member*, member' <- member'*} /\ (exists ~(Type_alpha: typ'' ~~ typ''' holds))*{typ'' <- typ''*, typ''' <- typ'''*}

              1. Else Phantom#122 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `TableStructT%%`)) /\ ((id = id')) /\ (exists ~(member = member'))*{member <- member*, member' <- member'*}

            2. Else Phantom#123 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((typ''' has type synthtyp)) /\ ((synthtyp' matches pattern `TableStructT%%`)) /\ (~(id = id'))

          2. Else Phantom#124 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((typ''' has type synthtyp)) /\ (~(synthtyp' matches pattern `TableStructT%%`))

        2. Else Phantom#125 ((typ'' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ (~(typ''' has type synthtyp))

    2. Else Phantom#126 ((typ'' has type synthtyp)) /\ (~(synthtyp matches pattern `SeqT%`)) /\ (~(synthtyp matches pattern `SeqDefaultT%`)) /\ (~(synthtyp matches pattern `RecordT%`)) /\ (~(synthtyp matches pattern `RecordDefaultT%`)) /\ (~(synthtyp matches pattern `SetT%`)) /\ (~(synthtyp matches pattern `TableEnumT%%`)) /\ (~(synthtyp matches pattern `TableStructT%%`))

2. If ((typ''' has type aliastyp)), then

  1. (Let (DefT typ''') be (typ''' as aliastyp))

  2. If ((Type_alpha: typ'' ~~ typ''' holds)), then

    1. The relation holds

  2. Else Phantom#127 ((typ''' has type aliastyp)) /\ (~(Type_alpha: typ'' ~~ typ''' holds))

2. Else Phantom#128 (~(typ''' has type aliastyp))

3. If ((typ'' = ((DefaultT) as typ))), then

  1. If ((typ''' = ((DefaultT) as typ))), then

    1. The relation holds

  1. Else Phantom#129 ((typ'' = ((DefaultT) as typ))) /\ (~(typ''' = ((DefaultT) as typ)))

3. Else Phantom#130 (~(typ'' = ((DefaultT) as typ)))

4. If ((typ'' = ((InvalidT) as typ))), then

  1. If ((typ''' = ((InvalidT) as typ))), then

    1. The relation holds

  1. Else Phantom#131 ((typ'' = ((InvalidT) as typ))) /\ (~(typ''' = ((InvalidT) as typ)))

4. Else Phantom#132 (~(typ'' = ((InvalidT) as typ)))

5. If ((typ'' = ((StateT) as typ))), then

  1. If ((typ''' = ((StateT) as typ))), then

    1. The relation holds

  1. Else Phantom#133 ((typ'' = ((StateT) as typ))) /\ (~(typ''' = ((StateT) as typ)))

5. Else Phantom#134 (~(typ'' = ((StateT) as typ)))

6. If ((typ'' = ((AnyT) as typ))), then

  1. If ((typ''' = ((AnyT) as typ))), then

    1. The relation holds

  1. Else Phantom#135 ((typ'' = ((AnyT) as typ))) /\ (~(typ''' = ((AnyT) as typ)))

6. Else Phantom#136 (~(typ'' = ((AnyT) as typ)))

;; ../../../../spec/2c5-runtime-type-alpha.watsup:9.1-11.20
relation FuncType_alpha: functyp, functyp'

1. Case analysis on functyp

  1. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt_a*{pt_a <- pt_a*} typ_r_a) be functyp)

    2. If ((functyp' matches pattern `BuiltinMethodT%%`)), then

      1. (Let (BuiltinMethodT pt_b*{pt_b <- pt_b*} typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}

      3. (Let (_id' dir_b typ_b _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}

      4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#137 ((functyp matches pattern `BuiltinMethodT%%`)) /\ ((functyp' matches pattern `BuiltinMethodT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (forall (Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*} /\ (~(Type_alpha: typ_r_a ~~ typ_r_b holds))

        1. Else Phantom#138 ((functyp matches pattern `BuiltinMethodT%%`)) /\ ((functyp' matches pattern `BuiltinMethodT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}

      4. Else Phantom#139 ((functyp matches pattern `BuiltinMethodT%%`)) /\ ((functyp' matches pattern `BuiltinMethodT%%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

    2. Else Phantom#140 ((functyp matches pattern `BuiltinMethodT%%`)) /\ (~(functyp' matches pattern `BuiltinMethodT%%`))

  2. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt_a*{pt_a <- pt_a*}) be functyp)

    2. If ((functyp' matches pattern `ActionT%`)), then

      1. (Let (ActionT pt_b*{pt_b <- pt_b*}) be functyp')

      2. (Let (_id dir_a typ_a _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}

      3. (Let (_id' dir_b typ_b _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}

      4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}, then

          1. The relation holds

        1. Else Phantom#141 ((functyp matches pattern `ActionT%`)) /\ ((functyp' matches pattern `ActionT%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}

      4. Else Phantom#142 ((functyp matches pattern `ActionT%`)) /\ ((functyp' matches pattern `ActionT%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

    2. Else Phantom#143 ((functyp matches pattern `ActionT%`)) /\ (~(functyp' matches pattern `ActionT%`))

  3. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt_a*{pt_a <- pt_a*}) be functyp)

    2. If ((functyp' matches pattern `ParserApplyMethodT%`)), then

      1. (Let (ParserApplyMethodT pt_b*{pt_b <- pt_b*}) be functyp')

      2. (Let (_id dir_a typ_a _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}

      3. (Let (_id' dir_b typ_b _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}

      4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}, then

          1. The relation holds

        1. Else Phantom#144 ((functyp matches pattern `ParserApplyMethodT%`)) /\ ((functyp' matches pattern `ParserApplyMethodT%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}

      4. Else Phantom#145 ((functyp matches pattern `ParserApplyMethodT%`)) /\ ((functyp' matches pattern `ParserApplyMethodT%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

    2. Else Phantom#146 ((functyp matches pattern `ParserApplyMethodT%`)) /\ (~(functyp' matches pattern `ParserApplyMethodT%`))

  4. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt_a*{pt_a <- pt_a*}) be functyp)

    2. If ((functyp' matches pattern `ControlApplyMethodT%`)), then

      1. (Let (ControlApplyMethodT pt_b*{pt_b <- pt_b*}) be functyp')

      2. (Let (_id dir_a typ_a _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}

      3. (Let (_id' dir_b typ_b _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}

      4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}, then

          1. The relation holds

        1. Else Phantom#147 ((functyp matches pattern `ControlApplyMethodT%`)) /\ ((functyp' matches pattern `ControlApplyMethodT%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}

      4. Else Phantom#148 ((functyp matches pattern `ControlApplyMethodT%`)) /\ ((functyp' matches pattern `ControlApplyMethodT%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

    2. Else Phantom#149 ((functyp matches pattern `ControlApplyMethodT%`)) /\ (~(functyp' matches pattern `ControlApplyMethodT%`))

  5. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ_a) be functyp)

    2. If ((functyp' matches pattern `TableApplyMethodT%`)), then

      1. (Let (TableApplyMethodT typ_b) be functyp')

      2. If ((Type_alpha: typ_a ~~ typ_b holds)), then

        1. The relation holds

      2. Else Phantom#150 ((functyp matches pattern `TableApplyMethodT%`)) /\ ((functyp' matches pattern `TableApplyMethodT%`)) /\ (~(Type_alpha: typ_a ~~ typ_b holds))

    2. Else Phantom#151 ((functyp matches pattern `TableApplyMethodT%`)) /\ (~(functyp' matches pattern `TableApplyMethodT%`))

  6. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt_a*{pt_a <- pt_a*} typ_r_a) be functyp)

    2. If ((functyp' matches pattern `ExternFuncT%%`)), then

      1. (Let (ExternFuncT pt_b*{pt_b <- pt_b*} typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}

      3. (Let (_id' dir_b typ_b _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}

      4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#152 ((functyp matches pattern `ExternFuncT%%`)) /\ ((functyp' matches pattern `ExternFuncT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (forall (Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*} /\ (~(Type_alpha: typ_r_a ~~ typ_r_b holds))

        1. Else Phantom#153 ((functyp matches pattern `ExternFuncT%%`)) /\ ((functyp' matches pattern `ExternFuncT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}

      4. Else Phantom#154 ((functyp matches pattern `ExternFuncT%%`)) /\ ((functyp' matches pattern `ExternFuncT%%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

    2. Else Phantom#155 ((functyp matches pattern `ExternFuncT%%`)) /\ (~(functyp' matches pattern `ExternFuncT%%`))

  7. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt_a*{pt_a <- pt_a*} typ_r_a) be functyp)

    2. If ((functyp' matches pattern `FuncT%%`)), then

      1. (Let (FuncT pt_b*{pt_b <- pt_b*} typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}

      3. (Let (_id' dir_b typ_b _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}

      4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#156 ((functyp matches pattern `FuncT%%`)) /\ ((functyp' matches pattern `FuncT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (forall (Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*} /\ (~(Type_alpha: typ_r_a ~~ typ_r_b holds))

        1. Else Phantom#157 ((functyp matches pattern `FuncT%%`)) /\ ((functyp' matches pattern `FuncT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}

      4. Else Phantom#158 ((functyp matches pattern `FuncT%%`)) /\ ((functyp' matches pattern `FuncT%%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

    2. Else Phantom#159 ((functyp matches pattern `FuncT%%`)) /\ (~(functyp' matches pattern `FuncT%%`))

  8. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt_a*{pt_a <- pt_a*} typ_r_a) be functyp)

    2. If ((functyp' matches pattern `ExternMethodT%%`)), then

      1. (Let (ExternMethodT pt_b*{pt_b <- pt_b*} typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}

      3. (Let (_id' dir_b typ_b _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}

      4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#160 ((functyp matches pattern `ExternMethodT%%`)) /\ ((functyp' matches pattern `ExternMethodT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (forall (Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*} /\ (~(Type_alpha: typ_r_a ~~ typ_r_b holds))

        1. Else Phantom#161 ((functyp matches pattern `ExternMethodT%%`)) /\ ((functyp' matches pattern `ExternMethodT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}

      4. Else Phantom#162 ((functyp matches pattern `ExternMethodT%%`)) /\ ((functyp' matches pattern `ExternMethodT%%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

    2. Else Phantom#163 ((functyp matches pattern `ExternMethodT%%`)) /\ (~(functyp' matches pattern `ExternMethodT%%`))

  9. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt_a*{pt_a <- pt_a*} typ_r_a) be functyp)

    2. If ((functyp' matches pattern `ExternAbstractMethodT%%`)), then

      1. (Let (ExternAbstractMethodT pt_b*{pt_b <- pt_b*} typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _val?{_val <- _val?}) be pt_a)*{_id <- _id*, _val? <- _val?*, dir_a <- dir_a*, pt_a <- pt_a*, typ_a <- typ_a*}

      3. (Let (_id' dir_b typ_b _val'?{_val' <- _val'?}) be pt_b)*{_id' <- _id'*, _val'? <- _val'?*, dir_b <- dir_b*, pt_b <- pt_b*, typ_b <- typ_b*}

      4. If ((dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#164 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((functyp' matches pattern `ExternAbstractMethodT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (forall (Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*} /\ (~(Type_alpha: typ_r_a ~~ typ_r_b holds))

        1. Else Phantom#165 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((functyp' matches pattern `ExternAbstractMethodT%%`)) /\ (forall (dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*} /\ (exists ~(Type_alpha: typ_a ~~ typ_b holds))*{typ_a <- typ_a*, typ_b <- typ_b*}

      4. Else Phantom#166 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((functyp' matches pattern `ExternAbstractMethodT%%`)) /\ (exists ~(dir_a = dir_b))*{dir_a <- dir_a*, dir_b <- dir_b*}

    2. Else Phantom#167 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ (~(functyp' matches pattern `ExternAbstractMethodT%%`))

;; ../../../../spec/2c5-runtime-type-alpha.watsup:13.1-15.20
relation FuncDef_alpha: funcdef, funcdef'

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft_a) be (funcdef as monofuncdef))

    2. If ((funcdef' has type monofuncdef)), then

      1. (Let (MonoFD ft_b) be (funcdef' as monofuncdef))

      2. If ((FuncType_alpha: ft_a ~~ ft_b holds)), then

        1. The relation holds

      2. Else Phantom#168 ((funcdef has type monofuncdef)) /\ ((funcdef' has type monofuncdef)) /\ (~(FuncType_alpha: ft_a ~~ ft_b holds))

    2. Else Phantom#169 ((funcdef has type monofuncdef)) /\ (~(funcdef' has type monofuncdef))

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD (tparam_a*{tparam_a <- tparam_a*}, tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*}) -> ft_a) be (funcdef as polyfuncdef))

    2. If ((funcdef' has type polyfuncdef)), then

      1. (Let (PolyFD (tparam_b*{tparam_b <- tparam_b*}, tparam_hidden_b*{tparam_hidden_b <- tparam_hidden_b*}) -> ft_b) be (funcdef' as polyfuncdef))

      2. If ((|tparam_a*{tparam_a <- tparam_a*}| = |tparam_b*{tparam_b <- tparam_b*}|)), then

        1. If ((|tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*}| = |tparam_hidden_b*{tparam_hidden_b <- tparam_hidden_b*}|)), then

          1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tparam_a*{tparam_a <- tparam_a*} ++ tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*}|))

          2. (Let tparam_a'*{tparam_a' <- tparam_a'*} be tparam_a*{tparam_a <- tparam_a*} ++ tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*})

          3. (Let ft_a' be $subst_functyp(({ (tparam_a' -> ((VarT tid_fresh) as typ))*{tid_fresh <- tid_fresh*, tparam_a' <- tparam_a'*} }), ft_a))

          4. (Let tparam_b'*{tparam_b' <- tparam_b'*} be tparam_b*{tparam_b <- tparam_b*} ++ tparam_hidden_b*{tparam_hidden_b <- tparam_hidden_b*})

          5. (Let ft_b' be $subst_functyp(({ (tparam_b' -> ((VarT tid_fresh) as typ))*{tid_fresh <- tid_fresh*, tparam_b' <- tparam_b'*} }), ft_b))

          6. If ((FuncType_alpha: ft_a' ~~ ft_b' holds)), then

            1. The relation holds

          6. Else Phantom#170 ((funcdef has type polyfuncdef)) /\ ((funcdef' has type polyfuncdef)) /\ ((|tparam_a*{tparam_a <- tparam_a*}| = |tparam_b*{tparam_b <- tparam_b*}|)) /\ ((|tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*}| = |tparam_hidden_b*{tparam_hidden_b <- tparam_hidden_b*}|)) /\ (~(FuncType_alpha: ft_a' ~~ ft_b' holds))

        1. Else Phantom#171 ((funcdef has type polyfuncdef)) /\ ((funcdef' has type polyfuncdef)) /\ ((|tparam_a*{tparam_a <- tparam_a*}| = |tparam_b*{tparam_b <- tparam_b*}|)) /\ (~(|tparam_hidden_a*{tparam_hidden_a <- tparam_hidden_a*}| = |tparam_hidden_b*{tparam_hidden_b <- tparam_hidden_b*}|))

      2. Else Phantom#172 ((funcdef has type polyfuncdef)) /\ ((funcdef' has type polyfuncdef)) /\ (~(|tparam_a*{tparam_a <- tparam_a*}| = |tparam_b*{tparam_b <- tparam_b*}|))

    2. Else Phantom#173 ((funcdef has type polyfuncdef)) /\ (~(funcdef' has type polyfuncdef))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:5.1-5.39
relation Type_wf: tidset, typ''''''

1. Case analysis on typ''''''

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ'''''' as basetyp))

    2. The relation holds

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'''''' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT tid) be abstyp)

        2. If ($in_set<tid>(tid, tidset)), then

          1. The relation holds

        2. Else Phantom#174 ((typ'''''' has type abstyp)) /\ ((abstyp matches pattern `VarT%`)) /\ (~$in_set<tid>(tid, tidset))

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd typ_a*{typ_a <- typ_a*}) be abstyp)

        2. (Let typ'''''' be $specialize_typdef((ptd as typdef), typ_a*{typ_a <- typ_a*}))

        3. If ((Type_wf: tidset |- typ'''''' holds)), then

          1. The relation holds

        3. Else Phantom#175 ((typ'''''' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ (~(Type_wf: tidset |- typ'''''' holds))

  3. Case (% has type aliastyp)

    1. (Let (DefT typ'''''') be (typ'''''' as aliastyp))

    2. If ($nestable_deft(typ'''''')), then

      1. If ((Type_wf: tidset |- typ'''''' holds)), then

        1. The relation holds

      1. Else Phantom#176 ((typ'''''' has type aliastyp)) /\ ($nestable_deft(typ'''''')) /\ (~(Type_wf: tidset |- typ'''''' holds))

    2. Else Phantom#177 ((typ'''''' has type aliastyp)) /\ (~$nestable_deft(typ''''''))

  4. Case (% has type datatyp)

    1. (Let datatyp be (typ'''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'''''') be datatyp)

        2. If ($nestable_newt(typ'''''')), then

          1. If ((Type_wf: tidset |- typ'''''' holds)), then

            1. The relation holds

          1. Else Phantom#178 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `NewT%%`)) /\ ($nestable_newt(typ'''''')) /\ (~(Type_wf: tidset |- typ'''''' holds))

        2. Else Phantom#179 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `NewT%%`)) /\ (~$nestable_newt(typ''''''))

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id member*{member <- member*}) be datatyp)

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. The relation holds

        2. Else Phantom#180 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `EnumT%%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'''''' (member, val)*{member <- member*, val <- val*}) be datatyp)

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. If ($nestable_senumt(typ'''''')), then

            1. If ((Type_wf: tidset |- typ'''''' holds)), then

              1. The relation holds

            1. Else Phantom#181 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ ($nestable_senumt(typ'''''')) /\ (~(Type_wf: tidset |- typ'''''' holds))

          1. Else Phantom#182 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (~$nestable_senumt(typ''''''))

        2. Else Phantom#183 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      4. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ'''''') be datatyp)

        2. If ($nestable_listt(typ'''''')), then

          1. If ((Type_wf: tidset |- typ'''''' holds)), then

            1. The relation holds

          1. Else Phantom#184 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `ListT%`)) /\ ($nestable_listt(typ'''''')) /\ (~(Type_wf: tidset |- typ'''''' holds))

        2. Else Phantom#185 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `ListT%`)) /\ (~$nestable_listt(typ''''''))

      5. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''''''*{typ'''''' <- typ''''''*}) be datatyp)

        2. If ($nestable_tuplet(typ''''''))*{typ'''''' <- typ''''''*}, then

          1. If ((Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}, then

            1. The relation holds

          1. Else Phantom#186 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ (forall $nestable_tuplet(typ''''''))*{typ'''''' <- typ''''''*} /\ (exists ~(Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}

        2. Else Phantom#187 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ (exists ~$nestable_tuplet(typ''''''))*{typ'''''' <- typ''''''*}

      6. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'''''' i_size) be datatyp)

        2. If ((i_size >= (0 as int))), then

          1. If ($nestable_stackt(typ'''''')), then

            1. If ((Type_wf: tidset |- typ'''''' holds)), then

              1. The relation holds

            1. Else Phantom#188 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ ((i_size >= (0 as int))) /\ ($nestable_stackt(typ'''''')) /\ (~(Type_wf: tidset |- typ'''''' holds))

          1. Else Phantom#189 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ ((i_size >= (0 as int))) /\ (~$nestable_stackt(typ''''''))

        2. Else Phantom#190 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~(i_size >= (0 as int)))

      7. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (member, typ'''''')*{member <- member*, typ'''''' <- typ''''''*}) be datatyp)

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. If ($nestable_structt(typ''''''))*{typ'''''' <- typ''''''*}, then

            1. If ((Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}, then

              1. The relation holds

            1. Else Phantom#191 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (forall $nestable_structt(typ''''''))*{typ'''''' <- typ''''''*} /\ (exists ~(Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}

          1. Else Phantom#192 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (exists ~$nestable_structt(typ''''''))*{typ'''''' <- typ''''''*}

        2. Else Phantom#193 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      8. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (member, typ'''''')*{member <- member*, typ'''''' <- typ''''''*}) be datatyp)

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. If ($nestable_headert(typ''''''))*{typ'''''' <- typ''''''*}, then

            1. If ((Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}, then

              1. The relation holds

            1. Else Phantom#194 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (forall $nestable_headert(typ''''''))*{typ'''''' <- typ''''''*} /\ (exists ~(Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}

          1. Else Phantom#195 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (exists ~$nestable_headert(typ''''''))*{typ'''''' <- typ''''''*}

        2. Else Phantom#196 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      9. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (member, typ'''''')*{member <- member*, typ'''''' <- typ''''''*}) be datatyp)

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. If ($nestable_uniont(typ''''''))*{typ'''''' <- typ''''''*}, then

            1. If ((Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}, then

              1. The relation holds

            1. Else Phantom#197 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `UnionT%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (forall $nestable_uniont(typ''''''))*{typ'''''' <- typ''''''*} /\ (exists ~(Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}

          1. Else Phantom#198 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `UnionT%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (exists ~$nestable_uniont(typ''''''))*{typ'''''' <- typ''''''*}

        2. Else Phantom#199 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `UnionT%%`)) /\ (~$distinct_<member>(member*{member <- member*}))

  5. Case (% has type objtyp)

    1. (Let objtyp be (typ'''''' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id fmap) be objtyp)

        2. (Let ({ (fid -> funcdef)*{fid <- fid*, funcdef <- funcdef*} }) be fmap)

        3. If ((FuncDef_wf: tidset |- funcdef holds))*{funcdef <- funcdef*}, then

          1. The relation holds

        3. Else Phantom#200 ((typ'''''' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ (exists ~(FuncDef_wf: tidset |- funcdef holds))*{funcdef <- funcdef*}

      2. Case (% matches pattern `ParserT%`)

        1. (Let (ParserT pt*{pt <- pt*}) be objtyp)

        2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

          1. The relation holds

        2. Else Phantom#201 ((typ'''''' has type objtyp)) /\ ((objtyp matches pattern `ParserT%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

      3. Case (% matches pattern `ControlT%`)

        1. (Let (ControlT pt*{pt <- pt*}) be objtyp)

        2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

          1. The relation holds

        2. Else Phantom#202 ((typ'''''' has type objtyp)) /\ ((objtyp matches pattern `ControlT%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

      4. Case (% matches pattern `PackageT%`)

        1. (Let (PackageT typ''''''*{typ'''''' <- typ''''''*}) be objtyp)

        2. If ((Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}, then

          1. The relation holds

        2. Else Phantom#203 ((typ'''''' has type objtyp)) /\ ((objtyp matches pattern `PackageT%`)) /\ (exists ~(Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT _id typ'''''') be objtyp)

        2. (Let typ'''''' be $canon_typ(typ''''''))

        3. If ($is_table_structt(typ'''''')), then

          1. If ((Type_wf: tidset |- typ'''''' holds)), then

            1. The relation holds

          1. Else Phantom#204 ((typ'''''' has type objtyp)) /\ ((objtyp matches pattern `TableT%%`)) /\ ($is_table_structt(typ'''''')) /\ (~(Type_wf: tidset |- typ'''''' holds))

        3. Else Phantom#205 ((typ'''''' has type objtyp)) /\ ((objtyp matches pattern `TableT%%`)) /\ (~$is_table_structt(typ''''''))

  6. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'''''' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ''''''*{typ'''''' <- typ''''''*}) be synthtyp)

        2. If ((Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}, then

          1. The relation holds

        2. Else Phantom#206 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ (exists ~(Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ''''''*{typ'''''' <- typ''''''*}) be synthtyp)

        2. If ((Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}, then

          1. The relation holds

        2. Else Phantom#207 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ (exists ~(Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}

      3. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member, typ'''''')*{member <- member*, typ'''''' <- typ''''''*}) be synthtyp)

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. If ((Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}, then

            1. The relation holds

          1. Else Phantom#208 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (exists ~(Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}

        2. Else Phantom#209 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member, typ'''''')*{member <- member*, typ'''''' <- typ''''''*}) be synthtyp)

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. If ((Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}, then

            1. The relation holds

          1. Else Phantom#210 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (exists ~(Type_wf: tidset |- typ'''''' holds))*{typ'''''' <- typ''''''*}

        2. Else Phantom#211 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      5. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ'''''') be synthtyp)

        2. (Let typ'''''' be $canon_typ(typ''''''))

        3. If ($nestable_sett(typ'''''')), then

          1. If ((Type_wf: tidset |- typ'''''' holds)), then

            1. The relation holds

          1. Else Phantom#212 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ ($nestable_sett(typ'''''')) /\ (~(Type_wf: tidset |- typ'''''' holds))

        3. Else Phantom#213 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ (~$nestable_sett(typ''''''))

      6. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT _id member*{member <- member*}) be synthtyp)

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. The relation holds

        2. Else Phantom#214 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `TableEnumT%%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      7. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT _id (member, typ'''''')*{member <- member*, typ'''''' <- typ''''''*}) be synthtyp)

        2. If ((member*{member <- member*} = ["hit", "miss", "action_run"])), then

          1. (Let typ'''''*{typ''''' <- typ'''''*} be typ''''''*{typ'''''' <- typ''''''*})

          2. If ((typ'''''*{typ''''' <- typ'''''*} matches pattern [ _/3 ])), then

            1. (Let [typ'''''', typ''', typ''''] be typ'''''*{typ''''' <- typ'''''*})

            2. If ((typ'''''' = ((BoolT) as typ))), then

              1. If ((typ''' = ((BoolT) as typ))), then

                1. If ((typ'''' has type synthtyp)), then

                  1. (Let synthtyp' be (typ'''' as synthtyp))

                  2. If ((synthtyp' matches pattern `TableEnumT%%`)), then

                    1. (Let (TableEnumT id_e member_e*{member_e <- member_e*}) be synthtyp')

                    2. If ((Type_wf: tidset |- ((TableEnumT id_e member_e*{member_e <- member_e*}) as typ) holds)), then

                      1. The relation holds

                    2. Else Phantom#215 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((member*{member <- member*} = ["hit", "miss", "action_run"])) /\ ((typ'''''*{typ''''' <- typ'''''*} matches pattern [ _/3 ])) /\ ((typ'''''' = ((BoolT) as typ))) /\ ((typ''' = ((BoolT) as typ))) /\ ((typ'''' has type synthtyp)) /\ ((synthtyp' matches pattern `TableEnumT%%`)) /\ (~(Type_wf: tidset |- ((TableEnumT id_e member_e*{member_e <- member_e*}) as typ) holds))

                  2. Else Phantom#216 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((member*{member <- member*} = ["hit", "miss", "action_run"])) /\ ((typ'''''*{typ''''' <- typ'''''*} matches pattern [ _/3 ])) /\ ((typ'''''' = ((BoolT) as typ))) /\ ((typ''' = ((BoolT) as typ))) /\ ((typ'''' has type synthtyp)) /\ (~(synthtyp' matches pattern `TableEnumT%%`))

                1. Else Phantom#217 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((member*{member <- member*} = ["hit", "miss", "action_run"])) /\ ((typ'''''*{typ''''' <- typ'''''*} matches pattern [ _/3 ])) /\ ((typ'''''' = ((BoolT) as typ))) /\ ((typ''' = ((BoolT) as typ))) /\ (~(typ'''' has type synthtyp))

              1. Else Phantom#218 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((member*{member <- member*} = ["hit", "miss", "action_run"])) /\ ((typ'''''*{typ''''' <- typ'''''*} matches pattern [ _/3 ])) /\ ((typ'''''' = ((BoolT) as typ))) /\ (~(typ''' = ((BoolT) as typ)))

            2. Else Phantom#219 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((member*{member <- member*} = ["hit", "miss", "action_run"])) /\ ((typ'''''*{typ''''' <- typ'''''*} matches pattern [ _/3 ])) /\ (~(typ'''''' = ((BoolT) as typ)))

          2. Else Phantom#220 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ ((member*{member <- member*} = ["hit", "miss", "action_run"])) /\ (~(typ'''''*{typ''''' <- typ'''''*} matches pattern [ _/3 ]))

        2. Else Phantom#221 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ (~(member*{member <- member*} = ["hit", "miss", "action_run"]))

    2. Else Phantom#222 ((typ'''''' has type synthtyp)) /\ (~(synthtyp matches pattern `SeqT%`)) /\ (~(synthtyp matches pattern `SeqDefaultT%`)) /\ (~(synthtyp matches pattern `RecordT%`)) /\ (~(synthtyp matches pattern `RecordDefaultT%`)) /\ (~(synthtyp matches pattern `SetT%`)) /\ (~(synthtyp matches pattern `TableEnumT%%`)) /\ (~(synthtyp matches pattern `TableStructT%%`))

2. If ((typ'''''' = ((DefaultT) as typ))), then

  1. The relation holds

2. Else Phantom#223 (~(typ'''''' = ((DefaultT) as typ)))

3. If ((typ'''''' = ((InvalidT) as typ))), then

  1. The relation holds

3. Else Phantom#224 (~(typ'''''' = ((InvalidT) as typ)))

4. If ((typ'''''' = ((StateT) as typ))), then

  1. The relation holds

4. Else Phantom#225 (~(typ'''''' = ((StateT) as typ)))

5. If ((typ'''''' = ((AnyT) as typ))), then

  1. The relation holds

5. Else Phantom#226 (~(typ'''''' = ((AnyT) as typ)))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:6.1-6.42
relation TypeDef_wf: tidset, typdef

1. Case analysis on typdef

  1. Case (% has type monotypdef)

    1. (Let (MonoD typ) be (typdef as monotypdef))

    2. If ($nestable_monod(typ)), then

      1. If ((Type_wf: tidset |- typ holds)), then

        1. The relation holds

      1. Else Phantom#227 ((typdef has type monotypdef)) /\ ($nestable_monod(typ)) /\ (~(Type_wf: tidset |- typ holds))

    2. Else Phantom#228 ((typdef has type monotypdef)) /\ (~$nestable_monod(typ))

  2. Case (% has type polytypdef)

    1. (Let (PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ) be (typdef as polytypdef))

    2. If ($nestable_polyd(typ)), then

      1. If ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})), then

        1. (Let tidset' be $union_set<tid>(tidset, ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} })))

        2. If ((Type_wf: tidset' |- typ holds)), then

          1. The relation holds

        2. Else Phantom#229 ((typdef has type polytypdef)) /\ ($nestable_polyd(typ)) /\ ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})) /\ (~(Type_wf: tidset' |- typ holds))

      1. Else Phantom#230 ((typdef has type polytypdef)) /\ ($nestable_polyd(typ)) /\ (~$distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))

    2. Else Phantom#231 ((typdef has type polytypdef)) /\ (~$nestable_polyd(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:8.1-8.44
relation ParamType_wf: tidset, (_id dir typ val''?{val'' <- val''?})

1. (Let val be val'')?{val'' <- val''?, val <- val?}

2. If ((val?{val <- val?} matches pattern ())), then

  1. If ((Type_wf: tidset |- typ holds)), then

    1. If (($is_externt($canon_typ(typ)) => (dir = (NO)))), then

      1. The relation holds

    1. Else Phantom#232 ((val?{val <- val?} matches pattern ())) /\ ((Type_wf: tidset |- typ holds)) /\ (~($is_externt($canon_typ(typ)) => (dir = (NO))))

  1. Else Phantom#233 ((val?{val <- val?} matches pattern ())) /\ (~(Type_wf: tidset |- typ holds))

2. Else Phantom#234 (~(val?{val <- val?} matches pattern ()))

3. (Let val' be val'')?{val'' <- val''?, val' <- val'?}

4. If ((val'?{val' <- val'?} matches pattern (_))), then

  1. (Let ?(val) be val'?{val' <- val'?})

  2. If ((Type_wf: tidset |- typ holds)), then

    1. If (($is_externt($canon_typ(typ)) => (dir = (NO)))), then

      1. If (((dir = (IN)) \/ (dir = (NO)))), then

        1. The relation holds

      1. Else Phantom#235 ((val'?{val' <- val'?} matches pattern (_))) /\ ((Type_wf: tidset |- typ holds)) /\ (($is_externt($canon_typ(typ)) => (dir = (NO)))) /\ (~((dir = (IN)) \/ (dir = (NO))))

    1. Else Phantom#236 ((val'?{val' <- val'?} matches pattern (_))) /\ ((Type_wf: tidset |- typ holds)) /\ (~($is_externt($canon_typ(typ)) => (dir = (NO))))

  2. Else Phantom#237 ((val'?{val' <- val'?} matches pattern (_))) /\ (~(Type_wf: tidset |- typ holds))

4. Else Phantom#238 (~(val'?{val' <- val'?} matches pattern (_)))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:9.1-9.45
relation ParamTypes_wf: tidset, pt*{pt <- pt*}

1. (Let (id _dir _typ _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _typ <- _typ*, _val? <- _val?*, id <- id*, pt <- pt*}

2. If ($distinct_<id>(id*{id <- id*})), then

  1. If ((ParamType_wf: tidset |- pt holds))*{pt <- pt*}, then

    1. The relation holds

  1. Else Phantom#239 ($distinct_<id>(id*{id <- id*})) /\ (exists ~(ParamType_wf: tidset |- pt holds))*{pt <- pt*}

2. Else Phantom#240 (~$distinct_<id>(id*{id <- id*}))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:11.1-11.43
relation FuncType_wf: tidset, functyp

1. Case analysis on functyp

  1. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt*{pt <- pt*} typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

      1. If ((Type_wf: tidset |- typ_r holds)), then

        1. The relation holds

      1. Else Phantom#241 ((functyp matches pattern `BuiltinMethodT%%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (~(Type_wf: tidset |- typ_r holds))

    2. Else Phantom#242 ((functyp matches pattern `BuiltinMethodT%%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

  2. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt*{pt <- pt*}) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

      1. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

      2. If ($is_trailing_action(dir*{dir <- dir*})), then

        1. (Let typ' be $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}

        2. If (((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~$is_intt(typ')) /\ ~$is_obj(typ')) /\ (~$is_strt(typ') \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}, then

          1. The relation holds

        2. Else Phantom#243 ((functyp matches pattern `ActionT%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ ($is_trailing_action(dir*{dir <- dir*})) /\ (exists ~((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~$is_intt(typ')) /\ ~$is_obj(typ')) /\ (~$is_strt(typ') \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}

      2. Else Phantom#244 ((functyp matches pattern `ActionT%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (~$is_trailing_action(dir*{dir <- dir*}))

    2. Else Phantom#245 ((functyp matches pattern `ActionT%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

  3. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt*{pt <- pt*}) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

      1. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

      2. (Let typ' be $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}, then

        1. The relation holds

      3. Else Phantom#246 ((functyp matches pattern `ParserApplyMethodT%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (exists ~(((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}

    2. Else Phantom#247 ((functyp matches pattern `ParserApplyMethodT%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

  4. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt*{pt <- pt*}) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

      1. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

      2. (Let typ' be $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}

      3. The relation holds

    2. Else Phantom#248 ((functyp matches pattern `ControlApplyMethodT%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

  5. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ) be functyp)

    2. If ((typ has type synthtyp)), then

      1. (Let synthtyp be (typ as synthtyp))

      2. If ((synthtyp matches pattern `TableStructT%%`)), then

        1. (Let (TableStructT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be synthtyp)

        2. The relation holds

      2. Else Phantom#249 ((functyp matches pattern `TableApplyMethodT%`)) /\ ((typ has type synthtyp)) /\ (~(synthtyp matches pattern `TableStructT%%`))

    2. Else Phantom#250 ((functyp matches pattern `TableApplyMethodT%`)) /\ (~(typ has type synthtyp))

  6. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt*{pt <- pt*} typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

      1. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

      2. (Let typ' be $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}, then

        1. If ((Type_wf: tidset |- typ_r holds)), then

          1. The relation holds

        1. Else Phantom#251 ((functyp matches pattern `ExternFuncT%%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (forall (((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*} /\ (~(Type_wf: tidset |- typ_r holds))

      3. Else Phantom#252 ((functyp matches pattern `ExternFuncT%%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (exists ~(((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}

    2. Else Phantom#253 ((functyp matches pattern `ExternFuncT%%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

  7. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt*{pt <- pt*} typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

      1. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

      2. (Let typ' be $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~$is_obj(typ')) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}, then

        1. If ((Type_wf: tidset |- typ_r holds)), then

          1. The relation holds

        1. Else Phantom#254 ((functyp matches pattern `FuncT%%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (forall (((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~$is_obj(typ')) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*} /\ (~(Type_wf: tidset |- typ_r holds))

      3. Else Phantom#255 ((functyp matches pattern `FuncT%%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (exists ~(((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~$is_obj(typ')) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}

    2. Else Phantom#256 ((functyp matches pattern `FuncT%%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

  8. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt*{pt <- pt*} typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

      1. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

      2. (Let typ' be $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}, then

        1. If ((Type_wf: tidset |- typ_r holds)), then

          1. The relation holds

        1. Else Phantom#257 ((functyp matches pattern `ExternMethodT%%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (forall (((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*} /\ (~(Type_wf: tidset |- typ_r holds))

      3. Else Phantom#258 ((functyp matches pattern `ExternMethodT%%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (exists ~(((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}

    2. Else Phantom#259 ((functyp matches pattern `ExternMethodT%%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

  9. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt*{pt <- pt*} typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)), then

      1. (Let (id dir typ val?{val <- val?}) be pt)*{dir <- dir*, id <- id*, pt <- pt*, typ <- typ*, val? <- val?*}

      2. (Let typ' be $canon_typ(typ))*{typ <- typ*, typ' <- typ'*}

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}, then

        1. If ((Type_wf: tidset |- typ_r holds)), then

          1. The relation holds

        1. Else Phantom#260 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (forall (((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*} /\ (~(Type_wf: tidset |- typ_r holds))

      3. Else Phantom#261 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((ParamTypes_wf: tidset |- pt*{pt <- pt*} holds)) /\ (exists ~(((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*{dir <- dir*, typ' <- typ'*}

    2. Else Phantom#262 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ (~(ParamTypes_wf: tidset |- pt*{pt <- pt*} holds))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:12.1-12.43
relation FuncDef_wf: tidset, funcdef

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. If ((((($is_builtinmethodt(ft) \/ $is_actiont(ft)) \/ $is_parserapplymethodt(ft)) \/ $is_controlapplymethodt(ft)) \/ $is_tableapplymethodt(ft))), then

      1. If ((FuncType_wf: tidset |- ft holds)), then

        1. The relation holds

      1. Else Phantom#263 ((funcdef has type monofuncdef)) /\ ((((($is_builtinmethodt(ft) \/ $is_actiont(ft)) \/ $is_parserapplymethodt(ft)) \/ $is_controlapplymethodt(ft)) \/ $is_tableapplymethodt(ft))) /\ (~(FuncType_wf: tidset |- ft holds))

    2. Else Phantom#264 ((funcdef has type monofuncdef)) /\ (~(((($is_builtinmethodt(ft) \/ $is_actiont(ft)) \/ $is_parserapplymethodt(ft)) \/ $is_controlapplymethodt(ft)) \/ $is_tableapplymethodt(ft)))

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> ft) be (funcdef as polyfuncdef))

    2. If (((($is_externfunct(ft) \/ $is_funct(ft)) \/ $is_externmethodt(ft)) \/ $is_externabstractmethodt(ft))), then

      1. If ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})), then

        1. (Let tidset' be $union_set<tid>(tidset, ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} })))

        2. If ((FuncType_wf: tidset' |- ft holds)), then

          1. The relation holds

        2. Else Phantom#265 ((funcdef has type polyfuncdef)) /\ (((($is_externfunct(ft) \/ $is_funct(ft)) \/ $is_externmethodt(ft)) \/ $is_externabstractmethodt(ft))) /\ ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})) /\ (~(FuncType_wf: tidset' |- ft holds))

      1. Else Phantom#266 ((funcdef has type polyfuncdef)) /\ (((($is_externfunct(ft) \/ $is_funct(ft)) \/ $is_externmethodt(ft)) \/ $is_externabstractmethodt(ft))) /\ (~$distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))

    2. Else Phantom#267 ((funcdef has type polyfuncdef)) /\ (~((($is_externfunct(ft) \/ $is_funct(ft)) \/ $is_externmethodt(ft)) \/ $is_externabstractmethodt(ft)))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:14.52-14.60
syntax consctxt = 
   | `CONSCTXT`()

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:15.1-15.53
relation CParamType_wf: tidset, consctxt, (id dir typ val?{val <- val?})

1. If ((dir matches pattern `NO`)), then

  1. If ((Type_wf: tidset |- typ holds)), then

    1. The relation holds

  1. Else Phantom#268 ((dir matches pattern `NO`)) /\ (~(Type_wf: tidset |- typ holds))

1. Else Phantom#269 (~(dir matches pattern `NO`))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:16.1-16.54
relation CParamTypes_wf: tidset, consctxt, pt*{pt <- pt*}

1. (Let (id _dir _typ _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _typ <- _typ*, _val? <- _val?*, id <- id*, pt <- pt*}

2. If ($distinct_<id>(id*{id <- id*})), then

  1. If ((CParamType_wf: tidset consctxt |- pt holds))*{pt <- pt*}, then

    1. The relation holds

  1. Else Phantom#270 ($distinct_<id>(id*{id <- id*})) /\ (exists ~(CParamType_wf: tidset consctxt |- pt holds))*{pt <- pt*}

2. Else Phantom#271 (~$distinct_<id>(id*{id <- id*}))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:18.1-18.43
relation ConsType_wf: tidset, (ConsT pt*{pt <- pt*} typ)

1. If ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)), then

  1. If ((Type_wf: tidset |- typ holds)), then

    1. (Let typ'' be $canon_typ(typ))

    2. If ((typ'' has type objtyp)), then

      1. (Let objtyp be (typ'' as objtyp))

      2. If ((objtyp matches pattern `ExternT%%`)), then

        1. (Let (ExternT id fmap) be objtyp)

        2. (Let (_id _dir typ_p _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}

        3. (Let typ' be $canon_typ(typ_p))*{typ' <- typ'*, typ_p <- typ_p*}

        4. If (((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))))*{typ' <- typ'*}, then

          1. The relation holds

        4. Else Phantom#272 ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)) /\ ((Type_wf: tidset |- typ holds)) /\ ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ (exists ~((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))))*{typ' <- typ'*}

      2. Else Phantom#273 ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)) /\ ((Type_wf: tidset |- typ holds)) /\ ((typ'' has type objtyp)) /\ (~(objtyp matches pattern `ExternT%%`))

    2. Else Phantom#274 ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)) /\ ((Type_wf: tidset |- typ holds)) /\ (~(typ'' has type objtyp))

    3. (Let typ' be $canon_typ(typ))

    4. If ((typ' has type objtyp)), then

      1. (Let objtyp be (typ' as objtyp))

      2. Case analysis on objtyp

        1. Case (% matches pattern `ParserT%`)

          1. (Let (ParserT _paramtyp*{_paramtyp <- _paramtyp*}) be objtyp)

          2. (Let (_id _dir typ_p _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}

          3. (Let typ_p' be $canon_typ(typ_p))*{typ_p <- typ_p*, typ_p' <- typ_p'*}

          4. If (((((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_controlt(typ_p')) /\ ~$is_packaget(typ_p')) /\ ~$is_tablet(typ_p')))*{typ_p' <- typ_p'*}, then

            1. The relation holds

          4. Else Phantom#275 ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)) /\ ((Type_wf: tidset |- typ holds)) /\ ((typ' has type objtyp)) /\ ((objtyp matches pattern `ParserT%`)) /\ (exists ~((((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_controlt(typ_p')) /\ ~$is_packaget(typ_p')) /\ ~$is_tablet(typ_p')))*{typ_p' <- typ_p'*}

        2. Case (% matches pattern `ControlT%`)

          1. (Let (ControlT _paramtyp*{_paramtyp <- _paramtyp*}) be objtyp)

          2. (Let (_id _dir typ_p _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}

          3. (Let typ_p' be $canon_typ(typ_p))*{typ_p <- typ_p*, typ_p' <- typ_p'*}

          4. If (((((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_parsert(typ_p')) /\ ~$is_packaget(typ_p')) /\ ~$is_tablet(typ_p')))*{typ_p' <- typ_p'*}, then

            1. The relation holds

          4. Else Phantom#276 ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)) /\ ((Type_wf: tidset |- typ holds)) /\ ((typ' has type objtyp)) /\ ((objtyp matches pattern `ControlT%`)) /\ (exists ~((((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_parsert(typ_p')) /\ ~$is_packaget(typ_p')) /\ ~$is_tablet(typ_p')))*{typ_p' <- typ_p'*}

        3. Case (% matches pattern `PackageT%`)

          1. (Let (PackageT _typ*{_typ <- _typ*}) be objtyp)

          2. (Let (_id _dir typ_p _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, pt <- pt*, typ_p <- typ_p*}

          3. (Let typ_p' be $canon_typ(typ_p))*{typ_p <- typ_p*, typ_p' <- typ_p'*}

          4. If (((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_tablet(typ_p')))*{typ_p' <- typ_p'*}, then

            1. The relation holds

          4. Else Phantom#277 ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)) /\ ((Type_wf: tidset |- typ holds)) /\ ((typ' has type objtyp)) /\ ((objtyp matches pattern `PackageT%`)) /\ (exists ~((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_tablet(typ_p')))*{typ_p' <- typ_p'*}

      2. Else Phantom#278 ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)) /\ ((Type_wf: tidset |- typ holds)) /\ ((typ' has type objtyp)) /\ (~(objtyp matches pattern `ParserT%`)) /\ (~(objtyp matches pattern `ControlT%`)) /\ (~(objtyp matches pattern `PackageT%`))

    4. Else Phantom#279 ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)) /\ ((Type_wf: tidset |- typ holds)) /\ (~(typ' has type objtyp))

  1. Else Phantom#280 ((CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds)) /\ (~(Type_wf: tidset |- typ holds))

1. Else Phantom#281 (~(CParamTypes_wf: tidset (CONSCTXT) |- pt*{pt <- pt*} holds))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:19.1-19.43
relation ConsDef_wf: tidset, (ConsD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> constyp)

1. (Let (ConsT _paramtyp*{_paramtyp <- _paramtyp*} typ_r) be constyp)

2. (Let typ_r' be $canon_typ(typ_r))

3. If ($is_externt(typ_r')), then

  1. If ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})), then

    1. (Let tidset' be $union_set<tid>(tidset, ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} })))

    2. If ((ConsType_wf: tidset' |- constyp holds)), then

      1. The relation holds

    2. Else Phantom#282 ($is_externt(typ_r')) /\ ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})) /\ (~(ConsType_wf: tidset' |- constyp holds))

  1. Else Phantom#283 ($is_externt(typ_r')) /\ (~$distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))

3. Else Phantom#284 (~$is_externt(typ_r'))

4. If ($is_parsert(typ_r')), then

  1. If ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})), then

    1. (Let tidset' be $union_set<tid>(tidset, ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} })))

    2. If ((ConsType_wf: tidset' |- constyp holds)), then

      1. The relation holds

    2. Else Phantom#285 ($is_parsert(typ_r')) /\ ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})) /\ (~(ConsType_wf: tidset' |- constyp holds))

  1. Else Phantom#286 ($is_parsert(typ_r')) /\ (~$distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))

4. Else Phantom#287 (~$is_parsert(typ_r'))

5. If ($is_controlt(typ_r')), then

  1. If ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})), then

    1. (Let tidset' be $union_set<tid>(tidset, ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} })))

    2. If ((ConsType_wf: tidset' |- constyp holds)), then

      1. The relation holds

    2. Else Phantom#288 ($is_controlt(typ_r')) /\ ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})) /\ (~(ConsType_wf: tidset' |- constyp holds))

  1. Else Phantom#289 ($is_controlt(typ_r')) /\ (~$distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))

5. Else Phantom#290 (~$is_controlt(typ_r'))

6. If ($is_packaget(typ_r')), then

  1. If ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})), then

    1. (Let tidset' be $union_set<tid>(tidset, ({ tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*} })))

    2. If ((ConsType_wf: tidset' |- constyp holds)), then

      1. The relation holds

    2. Else Phantom#291 ($is_packaget(typ_r')) /\ ($distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})) /\ (~(ConsType_wf: tidset' |- constyp holds))

  1. Else Phantom#292 ($is_packaget(typ_r')) /\ (~$distinct_<tid>(tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*}))

6. Else Phantom#293 (~$is_packaget(typ_r'))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:37.1-37.31
def $nestable_deft(typ)

1. Return $nestable'_deft($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:38.1-38.32
def $nestable'_deft(typ)

1. Case analysis on typ

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ as basetyp))

    2. Return (~$is_voidt((basetyp as typ)) /\ ~$is_matchkindt((basetyp as typ)))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:52.1-52.31
def $nestable_newt(typ)

1. Return $nestable'_newt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:53.1-53.32
def $nestable'_newt(typ)

1. If ((typ = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id _typ) be datatyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:73.1-73.33
def $nestable_senumt(typ)

1. Return $nestable'_senumt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:74.1-74.34
def $nestable'_senumt(typ'')

1. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $nestable_newt_in_senumt(typ'')

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:75.1-75.41
def $nestable_newt_in_senumt(typ)

1. Return $nestable_newt_in_senumt'($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:76.1-76.42
def $nestable_newt_in_senumt'(typ)

1. Case analysis on typ

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id _typ) be datatyp)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:100.1-100.32
def $nestable_listt(typ)

1. Return $nestable'_listt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:101.1-101.33
def $nestable'_listt(typ)

1. Case analysis on typ

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ as basetyp))

    2. Return ~$is_voidt((basetyp as typ))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:114.1-114.33
def $nestable_tuplet(typ)

1. Return $nestable'_tuplet($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:115.1-115.34
def $nestable'_tuplet(typ)

1. If ((typ = ((ErrT) as typ))), then

  1. Return true

2. If ((typ = ((BoolT) as typ))), then

  1. Return true

3. Case analysis on typ

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ as numtyp))

    2. Return ~$is_intt((numtyp as typ))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Return ~$is_listt((datatyp as typ))

4. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:131.1-131.33
def $nestable_stackt(typ)

1. Return $nestable'_stackt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:132.1-132.34
def $nestable'_stackt(typ)

1. Case analysis on typ

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT tid) be abstyp)

      2. Return true

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. Return true

      2. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:147.1-147.34
def $nestable_structt(typ)

1. Return $nestable'_structt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:148.1-148.35
def $nestable'_structt(typ)

1. If ((typ = ((ErrT) as typ))), then

  1. Return true

2. If ((typ = ((BoolT) as typ))), then

  1. Return true

3. Case analysis on typ

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ as numtyp))

    2. Return ~$is_intt((numtyp as typ))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Return ~$is_listt((datatyp as typ))

4. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:165.1-165.34
def $nestable_headert(typ)

1. Return $nestable'_headert($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:166.1-166.35
def $nestable'_headert(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Return ~$is_intt((numtyp as typ))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return true

      3. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. If ($nestable_structt_in_headert(typ''))*{typ'' <- typ''*}, then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:167.1-167.45
def $nestable_structt_in_headert(typ)

1. Return $nestable'_structt_in_headert($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:168.1-168.46
def $nestable'_structt_in_headert(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return true

      3. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. If ($nestable_structt_in_headert(typ''))*{typ'' <- typ''*}, then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:199.1-199.33
def $nestable_uniont(typ)

1. Return $nestable'_uniont($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:200.1-200.34
def $nestable'_uniont(typ)

1. Case analysis on typ

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:262.1-262.31
def $nestable_sett(typ)

1. Return $nestable'_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:263.1-263.32
def $nestable'_sett(typ'')

1. If ((typ'' = ((ErrT) as typ))), then

  1. Return true

2. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

3. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*{_member <- _member*}) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return true

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*{typ'' <- typ''*}) be datatyp)

        2. If ($nestable_tuplet_in_sett(typ''))*{typ'' <- typ''*}, then

          1. Return true

  4. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SeqT%`)), then

      1. (Let (SeqT typ''*{typ'' <- typ''*}) be synthtyp)

      2. If ($nestable_seqt_in_sett(typ''))*{typ'' <- typ''*}, then

        1. Return true

4. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:264.1-264.41
def $nestable_tuplet_in_sett(typ)

1. Return $nestable'_tuplet_in_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:265.1-265.42
def $nestable'_tuplet_in_sett(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*{_member <- _member*}) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return true

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*{typ'' <- typ''*}) be datatyp)

        2. If ($nestable_tuplet_in_sett(typ''))*{typ'' <- typ''*}, then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:266.1-266.39
def $nestable_seqt_in_sett(typ)

1. Return $nestable'_seqt_in_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:267.1-267.40
def $nestable'_seqt_in_sett(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*{_member <- _member*}) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return true

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*{typ'' <- typ''*}) be datatyp)

        2. If ($nestable_seqt_in_sett(typ''))*{typ'' <- typ''*}, then

          1. Return true

  4. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SeqT%`)), then

      1. (Let (SeqT typ''*{typ'' <- typ''*}) be synthtyp)

      2. If ($nestable_seqt_in_sett(typ''))*{typ'' <- typ''*}, then

        1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:339.1-339.32
def $nestable_monod(typ)

1. Case analysis on typ

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  2. Case (% has type aliastyp)

    1. (Let (DefT _typ) be (typ as aliastyp))

    2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*{_member <- _member*}) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return true

  4. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. If ((objtyp matches pattern `TableT%%`)), then

      1. (Let (TableT _id _typ) be objtyp)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:355.1-355.32
def $nestable_polyd(typ)

1. Case analysis on typ

  1. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT _typ*{_typ <- _typ*}) be datatyp)

        2. Return true

      2. Case (% matches pattern `StackT%%`)

        1. (Let (StackT _typ _int) be datatyp)

        2. Return true

      3. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. Return true

      4. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. Return true

      5. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. Return true

  2. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id _map<fid, funcdef>) be objtyp)

        2. Return true

      2. Case (% matches pattern `ParserT%`)

        1. (Let (ParserT _paramtyp*{_paramtyp <- _paramtyp*}) be objtyp)

        2. Return true

      3. Case (% matches pattern `ControlT%`)

        1. (Let (ControlT _paramtyp*{_paramtyp <- _paramtyp*}) be objtyp)

        2. Return true

      4. Case (% matches pattern `PackageT%`)

        1. (Let (PackageT _typ*{_typ <- _typ*}) be objtyp)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:406.1-407.38
def $is_trailing_action(dir*{dir <- dir*})

1. Return $is_trailing_action'(true, $rev_<dir>(dir*{dir <- dir*}))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:408.1-408.44
def $is_trailing_action'(_bool', dir''*{dir'' <- dir''*})

1. (Let dir be dir'')*{dir'' <- dir''*, dir <- dir*}

2. If ((dir*{dir <- dir*} matches pattern [])), then

  1. Return true

2. Else Phantom#294 (~(dir*{dir <- dir*} matches pattern []))

3. (Let dir' be dir'')*{dir'' <- dir''*, dir' <- dir'*}

4. Case analysis on _bool'

  1. Case (% = true)

    1. If ((dir'*{dir' <- dir'*} matches pattern _ :: _)), then

      1. (Let dir :: dir_t*{dir_t <- dir_t*} be dir'*{dir' <- dir'*})

      2. If ((dir matches pattern `NO`)), then

        1. Return $is_trailing_action'(true, dir_t*{dir_t <- dir_t*})

      2. Else Phantom#295 ((_bool' = true)) /\ ((dir'*{dir' <- dir'*} matches pattern _ :: _)) /\ (~(dir matches pattern `NO`))

    1. Else Phantom#296 ((_bool' = true)) /\ (~(dir'*{dir' <- dir'*} matches pattern _ :: _))

  2. Case (% = false)

    1. If ((dir'*{dir' <- dir'*} matches pattern _ :: _)), then

      1. (Let dir :: dir_t*{dir_t <- dir_t*} be dir'*{dir' <- dir'*})

      2. If ((dir matches pattern `NO`)), then

        1. Return false

      2. Else Phantom#297 ((_bool' = false)) /\ ((dir'*{dir' <- dir'*} matches pattern _ :: _)) /\ (~(dir matches pattern `NO`))

    1. Else Phantom#298 ((_bool' = false)) /\ (~(dir'*{dir' <- dir'*} matches pattern _ :: _))

4. Else Phantom#299 (~(_bool' = true)) /\ (~(_bool' = false))

5. If ((dir*{dir <- dir*} matches pattern _ :: _)), then

  1. (Let dir_h :: dir_t*{dir_t <- dir_t*} be dir*{dir <- dir*})

  2. If (~(dir_h matches pattern `NO`)), then

    1. Return $is_trailing_action'(false, dir_t*{dir_t <- dir_t*})

  2. Else Phantom#300 ((dir*{dir <- dir*} matches pattern _ :: _)) /\ (~~(dir_h matches pattern `NO`))

5. Else Phantom#301 (~(dir*{dir <- dir*} matches pattern _ :: _))

;; ../../../../spec/2d1-runtime-numerics.watsup:5.1-5.21
def $pow2



;; ../../../../spec/2d1-runtime-numerics.watsup:7.1-7.25
def $shl



;; ../../../../spec/2d1-runtime-numerics.watsup:8.1-8.25
def $shr



;; ../../../../spec/2d1-runtime-numerics.watsup:9.1-9.36
def $shr_arith



;; ../../../../spec/2d1-runtime-numerics.watsup:11.1-11.21
def $bneg



;; ../../../../spec/2d1-runtime-numerics.watsup:12.1-12.26
def $band



;; ../../../../spec/2d1-runtime-numerics.watsup:13.1-13.26
def $bxor



;; ../../../../spec/2d1-runtime-numerics.watsup:14.1-14.25
def $bor



;; ../../../../spec/2d1-runtime-numerics.watsup:16.1-16.33
def $bitacc



;; ../../../../spec/2d1-runtime-numerics.watsup:22.1-23.32
def $un_op(unop, val)

1. Case analysis on unop

  1. Case (% matches pattern `BNOT`)

    1. Return $un_bnot(val)

  2. Case (% matches pattern `LNOT`)

    1. Return $un_lnot(val)

  3. Case (% matches pattern `UPLUS`)

    1. Return $un_plus(val)

  4. Case (% matches pattern `UMINUS`)

    1. Return $un_minus(val)

;; ../../../../spec/2d1-runtime-numerics.watsup:27.1-27.24
def $un_bnot(val)

1. If ((val matches pattern `FBitV%%`)), then

  1. (Let (FBitV w bs) be val)

  2. (Let i be $bneg(bs))

  3. Return (FBitV w $to_bitstr((w as int), $bneg(bs)))

1. Else Phantom#302 (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:36.1-36.24
def $un_lnot(val)

1. If ((val matches pattern `BoolV%`)), then

  1. (Let (BoolV b) be val)

  2. Return (BoolV ~b)

1. Else Phantom#303 (~(val matches pattern `BoolV%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:44.1-44.24
def $un_plus(val)

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i) be val)

    2. Return (IntV i)

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs) be val)

    2. Return (FIntV w bs)

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs) be val)

    2. Return (FBitV w bs)

1. Else Phantom#304 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:54.1-54.25
def $un_minus(val)

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i) be val)

    2. Return (IntV -i)

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs) be val)

    2. (Let bs' be $to_bitstr((w as int), $to_int((w as int), -bs)))

    3. Return (FIntV w bs')

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs) be val)

    2. (Let bs' be ($pow2(w) - bs))

    3. Return (FBitV w bs')

1. Else Phantom#305 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:70.1-71.24
def $bin_op(binop, val_l, val_r)

1. Case analysis on binop

  1. Case (% matches pattern `PLUS`)

    1. Return $bin_plus(val_l, val_r)

  2. Case (% matches pattern `MINUS`)

    1. Return $bin_minus(val_l, val_r)

  3. Case (% matches pattern `MUL`)

    1. Return $bin_mul(val_l, val_r)

  4. Case (% matches pattern `DIV`)

    1. Return $bin_div(val_l, val_r)

  5. Case (% matches pattern `MOD`)

    1. Return $bin_mod(val_l, val_r)

  6. Case (% matches pattern `SHL`)

    1. Return $bin_shl(val_l, val_r)

  7. Case (% matches pattern `SHR`)

    1. Return $bin_shr(val_l, val_r)

  8. Case (% matches pattern `LE`)

    1. Return (BoolV $bin_le(val_l, val_r))

  9. Case (% matches pattern `GE`)

    1. Return (BoolV $bin_ge(val_l, val_r))

  10. Case (% matches pattern `LT`)

    1. Return (BoolV $bin_lt(val_l, val_r))

  11. Case (% matches pattern `GT`)

    1. Return (BoolV $bin_gt(val_l, val_r))

  12. Case (% matches pattern `EQ`)

    1. Return (BoolV $bin_eq(val_l, val_r))

  13. Case (% matches pattern `NE`)

    1. Return (BoolV ~$bin_eq(val_l, val_r))

  14. Case (% matches pattern `BAND`)

    1. Return $bin_band(val_l, val_r)

  15. Case (% matches pattern `BXOR`)

    1. Return $bin_bxor(val_l, val_r)

  16. Case (% matches pattern `BOR`)

    1. Return $bin_bor(val_l, val_r)

  17. Case (% matches pattern `CONCAT`)

    1. Return $bin_concat(val_l, val_r)

  18. Case (% matches pattern `LAND`)

    1. Return $bin_land(val_l, val_r)

  19. Case (% matches pattern `LOR`)

    1. Return $bin_lor(val_l, val_r)

1. Else Phantom#306 (~(binop matches pattern `PLUS`)) /\ (~(binop matches pattern `MINUS`)) /\ (~(binop matches pattern `MUL`)) /\ (~(binop matches pattern `DIV`)) /\ (~(binop matches pattern `MOD`)) /\ (~(binop matches pattern `SHL`)) /\ (~(binop matches pattern `SHR`)) /\ (~(binop matches pattern `LE`)) /\ (~(binop matches pattern `GE`)) /\ (~(binop matches pattern `LT`)) /\ (~(binop matches pattern `GT`)) /\ (~(binop matches pattern `EQ`)) /\ (~(binop matches pattern `NE`)) /\ (~(binop matches pattern `BAND`)) /\ (~(binop matches pattern `BXOR`)) /\ (~(binop matches pattern `BOR`)) /\ (~(binop matches pattern `CONCAT`)) /\ (~(binop matches pattern `LAND`)) /\ (~(binop matches pattern `LOR`))

;; ../../../../spec/2d1-runtime-numerics.watsup:75.1-75.30
def $bin_plus(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (IntV (i_l + i_r))

    2. Else Phantom#307 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l + i_r)))

        4. Return (FIntV w bs)

      2. Else Phantom#308 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#309 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l + i_r)))

        4. Return (FBitV w bs)

      2. Else Phantom#310 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#311 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#312 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:93.1-93.31
def $bin_minus(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (IntV (i_l - i_r))

    2. Else Phantom#313 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l - i_r)))

        4. Return (FIntV w bs)

      2. Else Phantom#314 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#315 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l - i_r)))

        4. Return (FBitV w bs)

      2. Else Phantom#316 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#317 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#318 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:111.1-111.29
def $bin_mul(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (IntV (i_l * i_r))

    2. Else Phantom#319 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l * i_r)))

        4. Return (FIntV w bs)

      2. Else Phantom#320 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#321 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l * i_r)))

        4. Return (FBitV w bs)

      2. Else Phantom#322 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#323 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#324 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:127.1-127.29
def $bin_div(val, val')

1. If ((val matches pattern `IntV%`)), then

  1. (Let (IntV i_l) be val)

  2. If ((val' matches pattern `IntV%`)), then

    1. (Let (IntV i_r) be val')

    2. Return (IntV (i_l / i_r))

  2. Else Phantom#325 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

1. Else Phantom#326 (~(val matches pattern `IntV%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:135.1-135.29
def $bin_mod(val, val')

1. If ((val matches pattern `IntV%`)), then

  1. (Let (IntV i_l) be val)

  2. If ((val' matches pattern `IntV%`)), then

    1. (Let (IntV i_r) be val')

    2. Return (IntV (i_l \ i_r))

  2. Else Phantom#327 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

1. Else Phantom#328 (~(val matches pattern `IntV%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:143.1-143.29
def $bin_shl(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. Return (IntV $shl(i_l, i_r))

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_r be $to_int((w_r as int), bs_r))

        3. Return (IntV $shl(i_l, i_r))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. Return (IntV $shl(i_l, bs_r))

    2. Else Phantom#329 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`)) /\ (~(val' matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FBitV%%`))

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. (Let val_r be (FIntV w_l $to_int((w_l as int), i_r)))

        3. Return $bin_shl((FIntV w_l bs_l), val_r)

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i_r be $to_int((w_r as int), bs_r))

        4. (Let i be $shl(i_l, i_r))

        5. Return (FIntV w_l $to_bitstr((w_l as int), i))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i be $shl(i_l, bs_r))

        4. Return (FIntV w_l $to_bitstr((w_l as int), i))

    2. Else Phantom#330 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `IntV%`)) /\ (~(val' matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FBitV%%`))

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. (Let val_r be (FBitV w_l $to_int((w_l as int), i_r)))

        3. Return $bin_shl((FBitV w_l bs_l), val_r)

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_r be $to_int((w_r as int), bs_r))

        3. (Let i be $shl(bs_l, i_r))

        4. Return (FBitV w_l $to_bitstr((w_l as int), i))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i be $shl(bs_l, bs_r))

        3. Return (FBitV w_l $to_bitstr((w_l as int), i))

    2. Else Phantom#331 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `IntV%`)) /\ (~(val' matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#332 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:176.1-176.29
def $bin_shr(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. Return (IntV $shr(i_l, i_r))

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_r be $to_int((w_r as int), bs_r))

        3. Return (IntV $shr(i_l, i_r))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. Return (IntV $shr(i_l, bs_r))

    2. Else Phantom#333 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`)) /\ (~(val' matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FBitV%%`))

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. If ((i_l < (0 as int))), then

          1. (Let i be $shr_arith(bs_l, i_r, ($pow2(w_l) - (1 as int))))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        3. Else Phantom#334 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `IntV%`)) /\ (~(i_l < (0 as int)))

        4. If ((i_l >= (0 as int))), then

          1. (Let i be $shr(bs_l, i_r))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        4. Else Phantom#335 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `IntV%`)) /\ (~(i_l >= (0 as int)))

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i_r be $to_int((w_r as int), bs_r))

        4. If ((i_l < (0 as int))), then

          1. (Let i be $shr_arith(bs_l, i_r, ($pow2(w_l) - (1 as int))))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        4. Else Phantom#336 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(i_l < (0 as int)))

        5. If ((i_l >= (0 as int))), then

          1. (Let i be $shr(bs_l, i_r))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        5. Else Phantom#337 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(i_l >= (0 as int)))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. If ((i_l < (0 as int))), then

          1. (Let i be $shr_arith(bs_l, bs_r, ($pow2(w_l) - (1 as int))))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        3. Else Phantom#338 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(i_l < (0 as int)))

        4. If ((i_l >= (0 as int))), then

          1. (Let i be $shr(bs_l, bs_r))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        4. Else Phantom#339 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(i_l >= (0 as int)))

    2. Else Phantom#340 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `IntV%`)) /\ (~(val' matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FBitV%%`))

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. (Let val_r be (FBitV w_l $to_int((w_l as int), i_r)))

        3. Return $bin_shr((FBitV w_l bs_l), val_r)

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_r be $to_int((w_r as int), bs_r))

        3. (Let i be $shr(bs_l, i_r))

        4. Return (FBitV w_l $to_bitstr((w_l as int), i))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i be $shr(bs_l, bs_r))

        3. Return (FBitV w_l $to_bitstr((w_l as int), i))

    2. Else Phantom#341 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `IntV%`)) /\ (~(val' matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#342 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:229.1-229.29
def $bin_le(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (i_l <= i_r)

    2. Else Phantom#343 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. Return (i_l <= i_r)

      2. Else Phantom#344 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#345 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. Return (bs_l <= bs_r)

      2. Else Phantom#346 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#347 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#348 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:241.1-241.29
def $bin_ge(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (i_l >= i_r)

    2. Else Phantom#349 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. Return (i_l >= i_r)

      2. Else Phantom#350 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#351 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. Return (bs_l >= bs_r)

      2. Else Phantom#352 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#353 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#354 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:253.1-253.29
def $bin_lt(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (i_l < i_r)

    2. Else Phantom#355 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. Return (i_l < i_r)

      2. Else Phantom#356 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#357 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. Return (bs_l < bs_r)

      2. Else Phantom#358 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#359 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#360 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:265.1-265.29
def $bin_gt(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (i_l > i_r)

    2. Else Phantom#361 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. Return (i_l > i_r)

      2. Else Phantom#362 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#363 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. Return (bs_l > bs_r)

      2. Else Phantom#364 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#365 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#366 (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:277.1-277.29
def $bin_eq(val, val')

1. Case analysis on val

  1. Case (% matches pattern `ErrV%`)

    1. (Let (ErrV member_a) be val)

    2. If ((val' matches pattern `ErrV%`)), then

      1. (Let (ErrV member_b) be val')

      2. Return (member_a = member_b)

    2. Else Phantom#367 ((val matches pattern `ErrV%`)) /\ (~(val' matches pattern `ErrV%`))

  2. Case (% matches pattern `MatchKindV%`)

    1. (Let (MatchKindV member_a) be val)

    2. If ((val' matches pattern `MatchKindV%`)), then

      1. (Let (MatchKindV member_b) be val')

      2. Return (member_a = member_b)

    2. Else Phantom#368 ((val matches pattern `MatchKindV%`)) /\ (~(val' matches pattern `MatchKindV%`))

  3. Case (% matches pattern `StrV%`)

    1. (Let (StrV text_a) be val)

    2. If ((val' matches pattern `StrV%`)), then

      1. (Let (StrV text_b) be val')

      2. Return (text_a = text_b)

    2. Else Phantom#369 ((val matches pattern `StrV%`)) /\ (~(val' matches pattern `StrV%`))

  4. Case (% matches pattern `BoolV%`)

    1. (Let (BoolV b_a) be val)

    2. If ((val' matches pattern `BoolV%`)), then

      1. (Let (BoolV b_b) be val')

      2. Return (b_a = b_b)

    2. Else Phantom#370 ((val matches pattern `BoolV%`)) /\ (~(val' matches pattern `BoolV%`))

  5. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_a) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_b) be val')

      2. Return (i_a = i_b)

    2. Else Phantom#371 ((val matches pattern `IntV%`)) /\ (~(val' matches pattern `IntV%`))

  6. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_a) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_b) be val')

      2. If ((w = w')), then

        1. Return (bs_a = bs_b)

      2. Else Phantom#372 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#373 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  7. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_a) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_b) be val')

      2. If ((w = w')), then

        1. Return (bs_a = bs_b)

      2. Else Phantom#374 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#375 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

  8. Case (% matches pattern `VBitV%%%`)

    1. (Let (VBitV w _width bs_a) be val)

    2. If ((val' matches pattern `VBitV%%%`)), then

      1. (Let (VBitV w' _width' bs_b) be val')

      2. If ((w = w')), then

        1. Return (bs_a = bs_b)

      2. Else Phantom#376 ((val matches pattern `VBitV%%%`)) /\ ((val' matches pattern `VBitV%%%`)) /\ (~(w = w'))

    2. Else Phantom#377 ((val matches pattern `VBitV%%%`)) /\ (~(val' matches pattern `VBitV%%%`))

  9. Case (% matches pattern `EnumFieldV%%`)

    1. (Let (EnumFieldV id_a member_a) be val)

    2. If ((val' matches pattern `EnumFieldV%%`)), then

      1. (Let (EnumFieldV id_b member_b) be val')

      2. Return ((id_a = id_b) /\ (member_a = member_b))

    2. Else Phantom#378 ((val matches pattern `EnumFieldV%%`)) /\ (~(val' matches pattern `EnumFieldV%%`))

  10. Case (% matches pattern `SEnumFieldV%%%`)

    1. (Let (SEnumFieldV id_a member_a val_a) be val)

    2. If ((val' matches pattern `SEnumFieldV%%%`)), then

      1. (Let (SEnumFieldV id_b member_b val_b) be val')

      2. Return (((id_a = id_b) /\ (member_a = member_b)) /\ $bin_eq(val_a, val_b))

    2. Else Phantom#379 ((val matches pattern `SEnumFieldV%%%`)) /\ (~(val' matches pattern `SEnumFieldV%%%`))

  11. Case (% matches pattern `ListV%`)

    1. (Let (ListV val_a*{val_a <- val_a*}) be val)

    2. If ((val' matches pattern `ListV%`)), then

      1. (Let (ListV val_b*{val_b <- val_b*}) be val')

      2. Return $bin_eqs(val_a*{val_a <- val_a*}, val_b*{val_b <- val_b*})

    2. Else Phantom#380 ((val matches pattern `ListV%`)) /\ (~(val' matches pattern `ListV%`))

  12. Case (% matches pattern `TupleV%`)

    1. (Let (TupleV val_a*{val_a <- val_a*}) be val)

    2. If ((val' matches pattern `TupleV%`)), then

      1. (Let (TupleV val_b*{val_b <- val_b*}) be val')

      2. Return $bin_eqs(val_a*{val_a <- val_a*}, val_b*{val_b <- val_b*})

    2. Else Phantom#381 ((val matches pattern `TupleV%`)) /\ (~(val' matches pattern `TupleV%`))

  13. Case (% matches pattern `StackV%%%`)

    1. (Let (StackV val_a*{val_a <- val_a*} _int i_size_a) be val)

    2. If ((val' matches pattern `StackV%%%`)), then

      1. (Let (StackV val_b*{val_b <- val_b*} _int' i_size_b) be val')

      2. Return ($bin_eqs(val_a*{val_a <- val_a*}, val_b*{val_b <- val_b*}) /\ (i_size_a = i_size_b))

    2. Else Phantom#382 ((val matches pattern `StackV%%%`)) /\ (~(val' matches pattern `StackV%%%`))

  14. Case (% matches pattern `StructV%%`)

    1. (Let (StructV id_a (member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}) be val)

    2. If ((val' matches pattern `StructV%%`)), then

      1. (Let (StructV id_b (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}) be val')

      2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}, (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}))

    2. Else Phantom#383 ((val matches pattern `StructV%%`)) /\ (~(val' matches pattern `StructV%%`))

  15. Case (% matches pattern `HeaderV%%`)

    1. (Let (HeaderV id_a (member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}) be val)

    2. If ((val' matches pattern `StructV%%`)), then

      1. (Let (StructV id_b (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}) be val')

      2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}, (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}))

    2. Else Phantom#384 ((val matches pattern `HeaderV%%`)) /\ (~(val' matches pattern `StructV%%`))

  16. Case (% matches pattern `UnionV%%`)

    1. (Let (UnionV id_a (member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}) be val)

    2. If ((val' matches pattern `StructV%%`)), then

      1. (Let (StructV id_b (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}) be val')

      2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*{member_a <- member_a*, val_a <- val_a*}, (member_b, val_b)*{member_b <- member_b*, val_b <- val_b*}))

    2. Else Phantom#385 ((val matches pattern `UnionV%%`)) /\ (~(val' matches pattern `StructV%%`))

  17. Case (% matches pattern `InvalidV`)

    1. If ((val' matches pattern `InvalidV`)), then

      1. Return true

    1. Else Phantom#386 ((val matches pattern `InvalidV`)) /\ (~(val' matches pattern `InvalidV`))

1. Else Phantom#387 (~(val matches pattern `ErrV%`)) /\ (~(val matches pattern `MatchKindV%`)) /\ (~(val matches pattern `StrV%`)) /\ (~(val matches pattern `BoolV%`)) /\ (~(val matches pattern `IntV%`)) /\ (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`)) /\ (~(val matches pattern `VBitV%%%`)) /\ (~(val matches pattern `EnumFieldV%%`)) /\ (~(val matches pattern `SEnumFieldV%%%`)) /\ (~(val matches pattern `ListV%`)) /\ (~(val matches pattern `TupleV%`)) /\ (~(val matches pattern `StackV%%%`)) /\ (~(val matches pattern `StructV%%`)) /\ (~(val matches pattern `HeaderV%%`)) /\ (~(val matches pattern `UnionV%%`)) /\ (~(val matches pattern `InvalidV`))

;; ../../../../spec/2d1-runtime-numerics.watsup:278.1-278.32
def $bin_eqs(val*{val <- val*}, val'*{val' <- val'*})

1. Case analysis on val*{val <- val*}

  1. Case (% matches pattern [])

    1. Case analysis on val'*{val' <- val'*}

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _val :: _val'*{_val' <- _val'*} be val'*{val' <- val'*})

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _val :: _val'*{_val' <- _val'*} be val*{val <- val*})

    2. If ((val'*{val' <- val'*} matches pattern [])), then

      1. Return false

    2. Else Phantom#388 ((val*{val <- val*} matches pattern _ :: _)) /\ (~(val'*{val' <- val'*} matches pattern []))

    3. (Let val_ah :: val_at*{val_at <- val_at*} be val*{val <- val*})

    4. If ((val'*{val' <- val'*} matches pattern _ :: _)), then

      1. (Let val_bh :: val_bt*{val_bt <- val_bt*} be val'*{val' <- val'*})

      2. Return ($bin_eq(val_ah, val_bh) /\ $bin_eqs(val_at*{val_at <- val_at*}, val_bt*{val_bt <- val_bt*}))

    4. Else Phantom#389 ((val*{val <- val*} matches pattern _ :: _)) /\ (~(val'*{val' <- val'*} matches pattern _ :: _))

;; ../../../../spec/2d1-runtime-numerics.watsup:279.1-279.53
def $bin_eqs_((member, val)*{(member, val) <- (member, val)*}, (member, val)'*{(member, val)' <- (member, val)'*})

1. Case analysis on (member, val)*{(member, val) <- (member, val)*}

  1. Case (% matches pattern [])

    1. Case analysis on (member, val)'*{(member, val)' <- (member, val)'*}

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _(member, val) :: _(member, val)'*{_(member, val)' <- _(member, val)'*} be (member, val)'*{(member, val)' <- (member, val)'*})

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _(member, val) :: _(member, val)'*{_(member, val)' <- _(member, val)'*} be (member, val)*{(member, val) <- (member, val)*})

    2. If (((member, val)'*{(member, val)' <- (member, val)'*} matches pattern [])), then

      1. Return false

    2. Else Phantom#390 (((member, val)*{(member, val) <- (member, val)*} matches pattern _ :: _)) /\ (~((member, val)'*{(member, val)' <- (member, val)'*} matches pattern []))

    3. (Let (member, val_a) :: (member_at, val_at)*{member_at <- member_at*, val_at <- val_at*} be (member, val)*{(member, val) <- (member, val)*})

    4. If (((member, val)'*{(member, val)' <- (member, val)'*} matches pattern _ :: _)), then

      1. (Let (member', val_b) :: (member_bt, val_bt)*{member_bt <- member_bt*, val_bt <- val_bt*} be (member, val)'*{(member, val)' <- (member, val)'*})

      2. If ((member = member')), then

        1. Return ($bin_eq(val_a, val_b) /\ $bin_eqs_((member_at, val_at)*{member_at <- member_at*, val_at <- val_at*}, (member_bt, val_bt)*{member_bt <- member_bt*, val_bt <- val_bt*}))

      2. Else Phantom#391 (((member, val)*{(member, val) <- (member, val)*} matches pattern _ :: _)) /\ (((member, val)'*{(member, val)' <- (member, val)'*} matches pattern _ :: _)) /\ (~(member = member'))

    4. Else Phantom#392 (((member, val)*{(member, val) <- (member, val)*} matches pattern _ :: _)) /\ (~((member, val)'*{(member, val)' <- (member, val)'*} matches pattern _ :: _))

;; ../../../../spec/2d1-runtime-numerics.watsup:325.1-325.30
def $bin_band(val, val')

1. Case analysis on val

  1. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let i be $band(i_l, i_r))

        4. Return (FIntV w $to_bitstr((w as int), i))

      2. Else Phantom#393 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#394 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  2. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i be $band(bs_l, bs_r))

        2. Return (FBitV w $to_bitstr((w as int), i))

      2. Else Phantom#395 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#396 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#397 (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:341.1-341.30
def $bin_bxor(val, val')

1. Case analysis on val

  1. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let i be $bxor(i_l, i_r))

        4. Return (FIntV w $to_bitstr((w as int), i))

      2. Else Phantom#398 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#399 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  2. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i be $bxor(bs_l, bs_r))

        2. Return (FBitV w $to_bitstr((w as int), i))

      2. Else Phantom#400 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#401 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#402 (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:357.1-357.29
def $bin_bor(val, val')

1. Case analysis on val

  1. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let i be $bor(i_l, i_r))

        4. Return (FIntV w $to_bitstr((w as int), i))

      2. Else Phantom#403 ((val matches pattern `FIntV%%`)) /\ ((val' matches pattern `FIntV%%`)) /\ (~(w = w'))

    2. Else Phantom#404 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`))

  2. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i be $bor(bs_l, bs_r))

        2. Return (FBitV w $to_bitstr((w as int), i))

      2. Else Phantom#405 ((val matches pattern `FBitV%%`)) /\ ((val' matches pattern `FBitV%%`)) /\ (~(w = w'))

    2. Else Phantom#406 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#407 (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:373.1-373.32
def $bin_concat(val, val')

1. Case analysis on val

  1. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i_l' be $shl(i_l, (w_r as int)))

        4. (Let i_l'' be (i_l' + bs_r))

        5. (Let w be (w_l + w_r))

        6. Return (FIntV w $to_bitstr((w as int), i_l''))

      2. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i_l' be $shl(i_l, (w_r as int)))

        4. (Let i_l'' be (i_l' + bs_r))

        5. (Let w be (w_l + w_r))

        6. Return (FIntV w $to_bitstr((w as int), i_l''))

    2. Else Phantom#408 ((val matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FBitV%%`))

  2. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_l be $shl(bs_l, (w_r as int)))

        3. (Let i_l' be (i_l + bs_r))

        4. (Let w be (w_l + w_r))

        5. Return (FBitV w $to_bitstr((w as int), i_l'))

      2. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i_l be $shl(bs_l, (w_r as int)))

        3. (Let i_l' be (i_l + bs_r))

        4. (Let w be (w_l + w_r))

        5. Return (FBitV w $to_bitstr((w as int), i_l'))

    2. Else Phantom#409 ((val matches pattern `FBitV%%`)) /\ (~(val' matches pattern `FIntV%%`)) /\ (~(val' matches pattern `FBitV%%`))

1. Else Phantom#410 (~(val matches pattern `FIntV%%`)) /\ (~(val matches pattern `FBitV%%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:402.1-402.30
def $bin_land(val, val')

1. If ((val matches pattern `BoolV%`)), then

  1. (Let (BoolV b_l) be val)

  2. If ((val' matches pattern `BoolV%`)), then

    1. (Let (BoolV b_r) be val')

    2. Return (BoolV (b_l /\ b_r))

  2. Else Phantom#411 ((val matches pattern `BoolV%`)) /\ (~(val' matches pattern `BoolV%`))

1. Else Phantom#412 (~(val matches pattern `BoolV%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:410.1-410.29
def $bin_lor(val, val')

1. If ((val matches pattern `BoolV%`)), then

  1. (Let (BoolV b_l) be val)

  2. If ((val' matches pattern `BoolV%`)), then

    1. (Let (BoolV b_r) be val')

    2. Return (BoolV (b_l \/ b_r))

  2. Else Phantom#413 ((val matches pattern `BoolV%`)) /\ (~(val' matches pattern `BoolV%`))

1. Else Phantom#414 (~(val matches pattern `BoolV%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:420.1-421.21
def $cast_op(typ, val'')

1. Case analysis on val''

  1. Case (% matches pattern `BoolV%`)

    1. (Let (BoolV b) be val'')

    2. Return $cast_bool(typ, b)

  2. Case (% matches pattern `IntV%`)

    1. (Let (IntV i) be val'')

    2. Return $cast_int(typ, i)

  3. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs) be val'')

    2. Return $cast_fint(typ, w, bs)

  4. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs) be val'')

    2. Return $cast_fbit(typ, w, bs)

  5. Case (% matches pattern `SEnumFieldV%%%`)

    1. (Let (SEnumFieldV _id _member val'') be val'')

    2. Return $cast_op(typ, val'')

  6. Case (% matches pattern `StructV%%`)

    1. (Let (StructV id (member, val'')*{member <- member*, val'' <- val''*}) be val'')

    2. Return $cast_struct(typ, id, (member, val'')*{member <- member*, val'' <- val''*})

  7. Case (% matches pattern `HeaderV%%`)

    1. (Let (HeaderV id (member, val'')*{member <- member*, val'' <- val''*}) be val'')

    2. Return $cast_header(typ, id, (member, val'')*{member <- member*, val'' <- val''*})

  8. Case (% matches pattern `SeqV%`)

    1. (Let (SeqV val''*{val'' <- val''*}) be val'')

    2. Return $cast_seq(typ, val''*{val'' <- val''*})

  9. Case (% matches pattern `RecordV%`)

    1. (Let (RecordV (member, val'')*{member <- member*, val'' <- val''*}) be val'')

    2. Return $cast_record(typ, (member, val'')*{member <- member*, val'' <- val''*})

  10. Case (% matches pattern `DefaultV`)

    1. Return $default(typ)

  11. Case (% matches pattern `SetV%`)

    1. (Let (SetV setval) be val'')

    2. Case analysis on setval

      1. Case (% matches pattern `SingletonSet%`)

        1. (Let (SingletonSet val'') be setval)

        2. Return $cast_set_singleton(typ, val'')

      2. Case (% matches pattern `MaskSet%%`)

        1. (Let (MaskSet val_b val_m) be setval)

        2. Return $cast_set_mask(typ, val_b, val_m)

      3. Case (% matches pattern `RangeSet%%`)

        1. (Let (RangeSet val_l val_u) be setval)

        2. Return $cast_set_range(typ, val_l, val_u)

1. Else Phantom#415 (~(val'' matches pattern `BoolV%`)) /\ (~(val'' matches pattern `IntV%`)) /\ (~(val'' matches pattern `FIntV%%`)) /\ (~(val'' matches pattern `FBitV%%`)) /\ (~(val'' matches pattern `SEnumFieldV%%%`)) /\ (~(val'' matches pattern `StructV%%`)) /\ (~(val'' matches pattern `HeaderV%%`)) /\ (~(val'' matches pattern `SeqV%`)) /\ (~(val'' matches pattern `RecordV%`)) /\ (~(val'' matches pattern `DefaultV`)) /\ (~(val'' matches pattern `SetV%`))

;; ../../../../spec/2d1-runtime-numerics.watsup:423.1-423.24
def $default(typ)

1. Return $default'($canon_typ(typ))

;; ../../../../spec/2d1-runtime-numerics.watsup:424.1-424.25
def $default'(typ'')

1. If ((typ'' = ((ErrT) as typ))), then

  1. Return (ErrV "NoError")

1. Else Phantom#416 (~(typ'' = ((ErrT) as typ)))

2. If ((typ'' = ((StrT) as typ))), then

  1. Return (StrV "")

2. Else Phantom#417 (~(typ'' = ((StrT) as typ)))

3. If ((typ'' = ((BoolT) as typ))), then

  1. Return (BoolV false)

3. Else Phantom#418 (~(typ'' = ((BoolT) as typ)))

4. If ((typ'' = ((IntT) as typ))), then

  1. Return (IntV (0 as int))

4. Else Phantom#419 (~(typ'' = ((IntT) as typ)))

5. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return (FIntV w (0 as bitstr))

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return (FBitV w (0 as bitstr))

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT w) be numtyp)

        2. Return (VBitV w 0 (0 as bitstr))

    2. Else Phantom#420 ((typ'' has type numtyp)) /\ (~(numtyp matches pattern `FIntT%`)) /\ (~(numtyp matches pattern `FBitT%`)) /\ (~(numtyp matches pattern `VBitT%`))

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT id member*{member <- member*}) be datatyp)

        2. If ((member*{member <- member*} matches pattern _ :: _)), then

          1. (Let member_h :: _member*{_member <- _member*} be member*{member <- member*})

          2. Return (EnumFieldV id member_h)

        2. Else Phantom#421 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `EnumT%%`)) /\ (~(member*{member <- member*} matches pattern _ :: _))

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT id typ'' (member, val)*{member <- member*, val <- val*}) be datatyp)

        2. (Let val_zero be $cast_int(typ'', (0 as int)))

        3. (Let member'?{member' <- member'?} be $assoc_<val, member>(val_zero, (val, member)*{member <- member*, val <- val*}))

        4. If ((member'?{member' <- member'?} matches pattern (_))), then

          1. (Let ?(member_zero) be member'?{member' <- member'?})

          2. Return (SEnumFieldV id member_zero val_zero)

        4. Else Phantom#422 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ (~(member'?{member' <- member'?} matches pattern (_)))

        5. If ((?() = $assoc_<val, member>(val_zero, (val, member)*{member <- member*, val <- val*}))), then

          1. Return (SEnumFieldV id "__UNSPECIFIED" val_zero)

        5. Else Phantom#423 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ (~(?() = $assoc_<val, member>(val_zero, (val, member)*{member <- member*, val <- val*})))

      3. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*{typ'' <- typ''*}) be datatyp)

        2. Return (TupleV $default(typ'')*{typ'' <- typ''*})

      4. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' int) be datatyp)

        2. If ((int has type nat)), then

          1. (Let n_s be (int as nat))

          2. (Let val*{val <- val*} be $repeat_<val>($default(typ''), n_s))

          3. Return (StackV val*{val <- val*} (0 as int) (n_s as int))

        2. Else Phantom#424 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~(int has type nat))

      5. Case (% matches pattern `StructT%%`)

        1. (Let (StructT id (member, typ'')*{member <- member*, typ'' <- typ''*}) be datatyp)

        2. Return (StructV id (member, $default(typ''))*{member <- member*, typ'' <- typ''*})

      6. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT id (member, typ'')*{member <- member*, typ'' <- typ''*}) be datatyp)

        2. Return (HeaderV id (member, $default(typ''))*{member <- member*, typ'' <- typ''*})

      7. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT id (member, typ'')*{member <- member*, typ'' <- typ''*}) be datatyp)

        2. Return (UnionV id (member, $default(typ''))*{member <- member*, typ'' <- typ''*})

    2. Else Phantom#425 ((typ'' has type datatyp)) /\ (~(datatyp matches pattern `EnumT%%`)) /\ (~(datatyp matches pattern `SEnumT%%%`)) /\ (~(datatyp matches pattern `TupleT%`)) /\ (~(datatyp matches pattern `StackT%%`)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`)) /\ (~(datatyp matches pattern `UnionT%%`))

5. Else Phantom#426 (~(typ'' has type numtyp)) /\ (~(typ'' has type datatyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:428.1-428.32
def $cast_bool(typ, b)

1. Return $cast_bool'($canon_typ(typ), b)

;; ../../../../spec/2d1-runtime-numerics.watsup:429.1-429.33
def $cast_bool'(typ'', b')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return (BoolV b')

1. Else Phantom#427 (~(typ'' = ((BoolT) as typ)))

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. If ((numtyp matches pattern `FBitT%`)), then

      1. (Let (FBitT w) be numtyp)

      2. Case analysis on b'

        1. Case (% = true)

          1. Return (FBitV w (1 as bitstr))

        2. Case (% = false)

          1. Return (FBitV w (0 as bitstr))

      2. Else Phantom#428 ((typ'' has type numtyp)) /\ ((numtyp matches pattern `FBitT%`)) /\ (~(b' = true)) /\ (~(b' = false))

    2. Else Phantom#429 ((typ'' has type numtyp)) /\ (~(numtyp matches pattern `FBitT%`))

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $cast_bool(typ'', b')

    2. Else Phantom#430 ((typ'' has type datatyp)) /\ (~(datatyp matches pattern `NewT%%`))

2. Else Phantom#431 (~(typ'' has type numtyp)) /\ (~(typ'' has type datatyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:442.1-442.30
def $cast_int(typ, i)

1. Return $cast_int'($canon_typ(typ), i)

;; ../../../../spec/2d1-runtime-numerics.watsup:443.1-443.31
def $cast_int'(typ'', i)

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return (BoolV (i = (0 as int)))

1. Else Phantom#432 (~(typ'' = ((BoolT) as typ)))

2. If ((typ'' = ((IntT) as typ))), then

  1. Return (IntV i)

2. Else Phantom#433 (~(typ'' = ((IntT) as typ)))

3. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return (FIntV w $to_bitstr((w as int), i))

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return (FBitV w $to_bitstr((w as int), i))

    2. Else Phantom#434 ((typ'' has type numtyp)) /\ (~(numtyp matches pattern `FIntT%`)) /\ (~(numtyp matches pattern `FBitT%`))

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $cast_int(typ'', i)

    2. Else Phantom#435 ((typ'' has type datatyp)) /\ (~(datatyp matches pattern `NewT%%`))

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SetT%`)), then

      1. (Let (SetT typ'') be synthtyp)

      2. (Let val be $cast_int(typ'', i))

      3. Return (SetV (SingletonSet val))

    2. Else Phantom#436 ((typ'' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

3. Else Phantom#437 (~(typ'' has type numtyp)) /\ (~(typ'' has type datatyp)) /\ (~(typ'' has type synthtyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:459.1-459.41
def $cast_fint(typ, w, bs)

1. Return $cast_fint'($canon_typ(typ), w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:460.1-460.42
def $cast_fint'(typ'', w', bs)

1. If ((typ'' = ((IntT) as typ))), then

  1. Return (IntV $to_int((w' as int), bs))

1. Else Phantom#438 (~(typ'' = ((IntT) as typ)))

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w_to) be numtyp)

        2. (Let bs' be $to_bitstr((w_to as int), $to_int((w' as int), bs)))

        3. Return (FIntV w_to bs')

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w_to) be numtyp)

        2. (Let bs' be $to_bitstr((w_to as int), $to_int((w' as int), bs)))

        3. Return (FBitV w_to bs')

    2. Else Phantom#439 ((typ'' has type numtyp)) /\ (~(numtyp matches pattern `FIntT%`)) /\ (~(numtyp matches pattern `FBitT%`))

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $cast_fint(typ'', w', bs)

    2. Else Phantom#440 ((typ'' has type datatyp)) /\ (~(datatyp matches pattern `NewT%%`))

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SetT%`)), then

      1. (Let (SetT typ'') be synthtyp)

      2. (Let val be $cast_fint(typ'', w', bs))

      3. Return (SetV (SingletonSet val))

    2. Else Phantom#441 ((typ'' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

2. Else Phantom#442 (~(typ'' has type numtyp)) /\ (~(typ'' has type datatyp)) /\ (~(typ'' has type synthtyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:477.1-477.41
def $cast_fbit(typ, w, bs)

1. Return $cast_fbit'($canon_typ(typ), w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:478.1-478.42
def $cast_fbit'(typ'', w', bs)

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return (BoolV (bs = (1 as bitstr)))

1. Else Phantom#443 (~(typ'' = ((BoolT) as typ)))

2. If ((typ'' = ((IntT) as typ))), then

  1. Return (IntV bs)

2. Else Phantom#444 (~(typ'' = ((IntT) as typ)))

3. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w_to) be numtyp)

        2. (Let bs' be $to_bitstr((w_to as int), bs))

        3. Return (FIntV w_to bs')

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w_to) be numtyp)

        2. (Let bs' be $to_bitstr((w_to as int), bs))

        3. Return (FBitV w_to bs')

    2. Else Phantom#445 ((typ'' has type numtyp)) /\ (~(numtyp matches pattern `FIntT%`)) /\ (~(numtyp matches pattern `FBitT%`))

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $cast_fbit(typ'', w', bs)

    2. Else Phantom#446 ((typ'' has type datatyp)) /\ (~(datatyp matches pattern `NewT%%`))

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SetT%`)), then

      1. (Let (SetT typ'') be synthtyp)

      2. (Let val be $cast_fbit(typ'', w', bs))

      3. Return (SetV (SingletonSet val))

    2. Else Phantom#447 ((typ'' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

3. Else Phantom#448 (~(typ'' has type numtyp)) /\ (~(typ'' has type datatyp)) /\ (~(typ'' has type synthtyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:500.1-500.48
def $cast_struct(typ, id, (member, val)*{member <- member*, val <- val*})

1. Return $cast_struct'($canon_typ(typ), id, (member, val)*{member <- member*, val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:501.1-501.49
def $cast_struct'(typ, id', (member, val)*{member <- member*, val <- val*})

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `StructT%%`)), then

    1. (Let (StructT id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

    2. If ((id = id')), then

      1. Return (StructV id (member, val)*{member <- member*, val <- val*})

    2. Else Phantom#449 ((typ has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~(id = id'))

  2. Else Phantom#450 ((typ has type datatyp)) /\ (~(datatyp matches pattern `StructT%%`))

1. Else Phantom#451 (~(typ has type datatyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:513.1-513.48
def $cast_header(typ, id, (member, val)*{member <- member*, val <- val*})

1. Return $cast_header'($canon_typ(typ), id, (member, val)*{member <- member*, val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:514.1-514.49
def $cast_header'(typ, id', (member, val)*{member <- member*, val <- val*})

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `HeaderT%%`)), then

    1. (Let (HeaderT id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

    2. If ((id = id')), then

      1. Return (HeaderV id (member, val)*{member <- member*, val <- val*})

    2. Else Phantom#452 ((typ has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~(id = id'))

  2. Else Phantom#453 ((typ has type datatyp)) /\ (~(datatyp matches pattern `HeaderT%%`))

1. Else Phantom#454 (~(typ has type datatyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:526.1-526.31
def $cast_seq(typ, val*{val <- val*})

1. Return $cast_seq'($canon_typ(typ), val*{val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:527.1-527.32
def $cast_seq'(typ', val*{val <- val*})

1. If ((typ' has type datatyp)), then

  1. (Let datatyp be (typ' as datatyp))

  2. Case analysis on datatyp

    1. Case (% matches pattern `ListT%`)

      1. (Let (ListT typ) be datatyp)

      2. (Let val' be $cast_op(typ, val))*{val <- val*, val' <- val'*}

      3. Return (ListV val'*{val' <- val'*})

    2. Case (% matches pattern `TupleT%`)

      1. (Let (TupleT typ*{typ <- typ*}) be datatyp)

      2. (Let val' be $cast_op(typ, val))*{typ <- typ*, val <- val*, val' <- val'*}

      3. Return (TupleV val'*{val' <- val'*})

    3. Case (% matches pattern `StackT%%`)

      1. (Let (StackT typ i_size) be datatyp)

      2. (Let val' be $cast_op(typ, val))*{val <- val*, val' <- val'*}

      3. (Let i_idx be (|val*{val <- val*}| as int))

      4. Return (StackV val'*{val' <- val'*} i_idx i_size)

    4. Case (% matches pattern `StructT%%`)

      1. (Let (StructT id (member, typ)*{member <- member*, typ <- typ*}) be datatyp)

      2. (Let val' be $cast_op(typ, val))*{typ <- typ*, val <- val*, val' <- val'*}

      3. Return (StructV id (member, val')*{member <- member*, val' <- val'*})

    5. Case (% matches pattern `HeaderT%%`)

      1. (Let (HeaderT id (member, typ)*{member <- member*, typ <- typ*}) be datatyp)

      2. (Let val' be $cast_op(typ, val))*{typ <- typ*, val <- val*, val' <- val'*}

      3. Return (HeaderV id (member, val')*{member <- member*, val' <- val'*})

  2. Else Phantom#455 ((typ' has type datatyp)) /\ (~(datatyp matches pattern `ListT%`)) /\ (~(datatyp matches pattern `TupleT%`)) /\ (~(datatyp matches pattern `StackT%%`)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

1. Else Phantom#456 (~(typ' has type datatyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:553.1-553.44
def $cast_record(typ, (member, val)*{member <- member*, val <- val*})

1. Return $cast_record'($canon_typ(typ), (member, val)*{member <- member*, val <- val*})

;; ../../../../spec/2d1-runtime-numerics.watsup:554.1-554.45
def $cast_record'(typ', (member, val)*{member <- member*, val <- val*})

1. If ((typ' has type datatyp)), then

  1. (Let datatyp be (typ' as datatyp))

  2. Case analysis on datatyp

    1. Case (% matches pattern `StructT%%`)

      1. (Let (StructT id (member_t, typ)*{member_t <- member_t*, typ <- typ*}) be datatyp)

      2. (Let val'''?{val''' <- val'''?} be $find_map<member, val>(({ (member -> val)*{member <- member*, val <- val*} }), member_t))*{member_t <- member_t*, val'''? <- val'''?*}

      3. If ((val'''?{val''' <- val'''?} matches pattern (_)))*{val'''? <- val'''?*}, then

        1. (Let ?(val') be val'''?{val''' <- val'''?})*{val' <- val'*, val'''? <- val'''?*}

        2. (Let val'' be $cast_op(typ, val'))*{typ <- typ*, val' <- val'*, val'' <- val''*}

        3. Return (StructV id (member_t, val'')*{member_t <- member_t*, val'' <- val''*})

      3. Else Phantom#457 ((typ' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (exists ~(val'''?{val''' <- val'''?} matches pattern (_)))*{val'''? <- val'''?*}

    2. Case (% matches pattern `HeaderT%%`)

      1. (Let (HeaderT id (member_t, typ)*{member_t <- member_t*, typ <- typ*}) be datatyp)

      2. (Let val'''?{val''' <- val'''?} be $find_map<member, val>(({ (member -> val)*{member <- member*, val <- val*} }), member_t))*{member_t <- member_t*, val'''? <- val'''?*}

      3. If ((val'''?{val''' <- val'''?} matches pattern (_)))*{val'''? <- val'''?*}, then

        1. (Let ?(val') be val'''?{val''' <- val'''?})*{val' <- val'*, val'''? <- val'''?*}

        2. (Let val'' be $cast_op(typ, val'))*{typ <- typ*, val' <- val'*, val'' <- val''*}

        3. Return (HeaderV id (member_t, val'')*{member_t <- member_t*, val'' <- val''*})

      3. Else Phantom#458 ((typ' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (exists ~(val'''?{val''' <- val'''?} matches pattern (_)))*{val'''? <- val'''?*}

  2. Else Phantom#459 ((typ' has type datatyp)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

1. Else Phantom#460 (~(typ' has type datatyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:581.1-581.40
def $cast_set_singleton(typ, val)

1. Return $cast_set_singleton'($canon_typ(typ), val)

;; ../../../../spec/2d1-runtime-numerics.watsup:582.1-582.41
def $cast_set_singleton'(typ', val)

1. If ((typ' has type synthtyp)), then

  1. (Let synthtyp be (typ' as synthtyp))

  2. If ((synthtyp matches pattern `SetT%`)), then

    1. (Let (SetT typ) be synthtyp)

    2. (Let val' be $cast_op(typ, val))

    3. Return (SetV (SingletonSet val'))

  2. Else Phantom#461 ((typ' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

1. Else Phantom#462 (~(typ' has type synthtyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:589.1-589.40
def $cast_set_mask(typ, val_b, val_m)

1. Return $cast_set_mask'($canon_typ(typ), val_b, val_m)

;; ../../../../spec/2d1-runtime-numerics.watsup:590.1-590.41
def $cast_set_mask'(typ', val_b, val_m)

1. If ((typ' has type synthtyp)), then

  1. (Let synthtyp be (typ' as synthtyp))

  2. If ((synthtyp matches pattern `SetT%`)), then

    1. (Let (SetT typ) be synthtyp)

    2. (Let val_b' be $cast_op(typ, val_b))

    3. (Let val_m' be $cast_op(typ, val_m))

    4. Return (SetV (MaskSet val_b' val_m'))

  2. Else Phantom#463 ((typ' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

1. Else Phantom#464 (~(typ' has type synthtyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:598.1-598.41
def $cast_set_range(typ, val_l, val_u)

1. Return $cast_set_range'($canon_typ(typ), val_l, val_u)

;; ../../../../spec/2d1-runtime-numerics.watsup:599.1-599.42
def $cast_set_range'(typ', val_l, val_u)

1. If ((typ' has type synthtyp)), then

  1. (Let synthtyp be (typ' as synthtyp))

  2. If ((synthtyp matches pattern `SetT%`)), then

    1. (Let (SetT typ) be synthtyp)

    2. (Let val_l' be $cast_op(typ, val_l))

    3. (Let val_u' be $cast_op(typ, val_u))

    4. Return (SetV (RangeSet val_l' val_u'))

  2. Else Phantom#465 ((typ' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

1. Else Phantom#466 (~(typ' has type synthtyp))

;; ../../../../spec/2d1-runtime-numerics.watsup:650.1-650.58
def $bitacc_op(val_b, val_h, val_l)

1. (Let i_b be $get_num(val_b))

2. (Let i_h be $get_num(val_h))

3. (Let i_l be $get_num(val_l))

4. (Let int be ((i_h + (1 as int)) - i_l))

5. If ((int has type nat)), then

  1. (Let w be (int as nat))

  2. (Let i be $bitacc(i_b, i_h, i_l))

  3. Return (FBitV w i)

5. Else Phantom#467 (~(int has type nat))

;; ../../../../spec/2d2-runtime-builtins.watsup:5.1-6.34
def $size(typ, text)

1. Case analysis on text

  1. Case (% = "minSizeInBits")

    1. Return $size_minSizeInBits(typ)

  2. Case (% = "minSizeInBytes")

    1. Return $size_minSizeInBytes(typ)

  3. Case (% = "maxSizeInBits")

    1. Return $size_maxSizeInBits(typ)

  4. Case (% = "maxSizeInBytes")

    1. Return $size_maxSizeInBytes(typ)

1. Else Phantom#468 (~(text = "minSizeInBits")) /\ (~(text = "minSizeInBytes")) /\ (~(text = "maxSizeInBits")) /\ (~(text = "maxSizeInBytes"))

;; ../../../../spec/2d2-runtime-builtins.watsup:8.1-8.35
def $size_minSizeInBits(typ)

1. Return (IntV ($size_minSizeInBits'(typ) as int))

;; ../../../../spec/2d2-runtime-builtins.watsup:9.1-9.36
def $size_minSizeInBits'(typ)

1. Return $size_minSizeInBits''($canon_typ(typ))

;; ../../../../spec/2d2-runtime-builtins.watsup:10.1-10.37
def $size_minSizeInBits''(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return 1

1. Else Phantom#469 (~(typ'' = ((BoolT) as typ)))

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return w

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return w

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT _width) be numtyp)

        2. Return 0

    2. Else Phantom#470 ((typ'' has type numtyp)) /\ (~(numtyp matches pattern `FIntT%`)) /\ (~(numtyp matches pattern `FBitT%`)) /\ (~(numtyp matches pattern `VBitT%`))

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'') be datatyp)

        2. Return $size_minSizeInBits'(typ'')

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return $size_minSizeInBits'(typ'')

      3. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*{typ'' <- typ''*}) be datatyp)

        2. Return $sum($size_minSizeInBits'(typ'')*{typ'' <- typ''*})

      4. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' int) be datatyp)

        2. If ((int has type nat)), then

          1. (Let n_s be (int as nat))

          2. Return ($size_minSizeInBits'(typ'') * n_s)

        2. Else Phantom#471 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~(int has type nat))

      5. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. Return $sum($size_minSizeInBits'(typ'')*{typ'' <- typ''*})

      6. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. Return $sum($size_minSizeInBits'(typ'')*{typ'' <- typ''*})

      7. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. Return $min($size_minSizeInBits'(typ'')*{typ'' <- typ''*})

    2. Else Phantom#472 ((typ'' has type datatyp)) /\ (~(datatyp matches pattern `NewT%%`)) /\ (~(datatyp matches pattern `SEnumT%%%`)) /\ (~(datatyp matches pattern `TupleT%`)) /\ (~(datatyp matches pattern `StackT%%`)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`)) /\ (~(datatyp matches pattern `UnionT%%`))

2. Else Phantom#473 (~(typ'' has type numtyp)) /\ (~(typ'' has type datatyp))

;; ../../../../spec/2d2-runtime-builtins.watsup:12.1-12.36
def $size_minSizeInBytes(typ)

1. (Let n be $size_minSizeInBits'(typ))

2. Return (IntV ((n / 8) as int))

;; ../../../../spec/2d2-runtime-builtins.watsup:14.1-14.35
def $size_maxSizeInBits(typ)

1. Return (IntV ($size_maxSizeInBits'(typ) as int))

;; ../../../../spec/2d2-runtime-builtins.watsup:15.1-15.36
def $size_maxSizeInBits'(typ)

1. Return $size_maxSizeInBits''($canon_typ(typ))

;; ../../../../spec/2d2-runtime-builtins.watsup:16.1-16.37
def $size_maxSizeInBits''(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return 1

1. Else Phantom#474 (~(typ'' = ((BoolT) as typ)))

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return w

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return w

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT w) be numtyp)

        2. Return w

    2. Else Phantom#475 ((typ'' has type numtyp)) /\ (~(numtyp matches pattern `FIntT%`)) /\ (~(numtyp matches pattern `FBitT%`)) /\ (~(numtyp matches pattern `VBitT%`))

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'') be datatyp)

        2. Return $size_maxSizeInBits'(typ'')

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. Return $size_maxSizeInBits'(typ'')

      3. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*{typ'' <- typ''*}) be datatyp)

        2. Return $sum($size_maxSizeInBits'(typ'')*{typ'' <- typ''*})

      4. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' int) be datatyp)

        2. If ((int has type nat)), then

          1. (Let n_s be (int as nat))

          2. Return ($size_maxSizeInBits'(typ'') * n_s)

        2. Else Phantom#476 ((typ'' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~(int has type nat))

      5. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. Return $sum($size_maxSizeInBits'(typ'')*{typ'' <- typ''*})

      6. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. Return $sum($size_maxSizeInBits'(typ'')*{typ'' <- typ''*})

      7. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (_member, typ'')*{_member <- _member*, typ'' <- typ''*}) be datatyp)

        2. Return $max($size_maxSizeInBits'(typ'')*{typ'' <- typ''*})

    2. Else Phantom#477 ((typ'' has type datatyp)) /\ (~(datatyp matches pattern `NewT%%`)) /\ (~(datatyp matches pattern `SEnumT%%%`)) /\ (~(datatyp matches pattern `TupleT%`)) /\ (~(datatyp matches pattern `StackT%%`)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`)) /\ (~(datatyp matches pattern `UnionT%%`))

2. Else Phantom#478 (~(typ'' has type numtyp)) /\ (~(typ'' has type datatyp))

;; ../../../../spec/2d2-runtime-builtins.watsup:18.1-18.36
def $size_maxSizeInBytes(typ)

1. (Let n be $size_maxSizeInBits'(typ))

2. Return (IntV ((n / 8) as int))

;; ../../../../spec/2e-runtime-env.watsup:11.15-11.31
syntax styp = 
   | `%%%%`(typ, dir, ctk, val?)

;; ../../../../spec/2e-runtime-env.watsup:18.45-18.58
syntax frame = map<id, styp>

;; ../../../../spec/2e-runtime-env.watsup:20.1-20.27
def $empty_frame

1. Return $empty_map<id, styp>

;; ../../../../spec/2e-runtime-env.watsup:24.57-24.73
syntax tdenv = map<tid, typdef>

;; ../../../../spec/2e-runtime-env.watsup:26.1-26.27
def $empty_tdenv

1. Return $empty_map<tid, typdef>

;; ../../../../spec/2e-runtime-env.watsup:30.57-30.74
syntax fdenv = map<fid, funcdef>

;; ../../../../spec/2e-runtime-env.watsup:32.1-32.27
def $empty_fdenv

1. Return $empty_map<fid, funcdef>

;; ../../../../spec/2e-runtime-env.watsup:36.57-36.74
syntax cdenv = map<fid, consdef>

;; ../../../../spec/2e-runtime-env.watsup:38.1-38.27
def $empty_cdenv

1. Return $empty_map<cid, consdef>

;; ../../../../spec/2e-runtime-env.watsup:45.1-45.36
def $check_func_name(id_l, id_r)

1. Return (id_l = id_r)

;; ../../../../spec/2e-runtime-env.watsup:49.1-49.42
def $check_arity_more(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})

1. Return (|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| > |id_p*{id_p <- id_p*}|)

;; ../../../../spec/2e-runtime-env.watsup:53.1-53.37
def $check_arity(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})

1. Return (|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| = |id_p*{id_p <- id_p*}|)

;; ../../../../spec/2e-runtime-env.watsup:57.1-57.42
def $check_arity_less(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})

1. Return (|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| < |id_p*{id_p <- id_p*}|)

;; ../../../../spec/2e-runtime-env.watsup:61.1-61.46
def $get_params_missing_names(id*{id <- id*}, id_a*{id_a <- id_a*})

1. Case analysis on id*{id <- id*}

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let id_p_h :: id_p_t*{id_p_t <- id_p_t*} be id*{id <- id*})

    2. If (~$in_set<id>(id_p_h, ({ id_a*{id_a <- id_a*} }))), then

      1. Return id_p_h :: $get_params_missing_names(id_p_t*{id_p_t <- id_p_t*}, id_a*{id_a <- id_a*})

    2. Else Phantom#479 ((id*{id <- id*} matches pattern _ :: _)) /\ (~~$in_set<id>(id_p_h, ({ id_a*{id_a <- id_a*} })))

    3. Otherwise

      1. Return $get_params_missing_names(id_p_t*{id_p_t <- id_p_t*}, id_a*{id_a <- id_a*})

;; ../../../../spec/2e-runtime-env.watsup:73.1-73.68
def $find_match_named<V>(fid, V, id_a*{id_a <- id_a*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})

1. If ($eq_set<id>(({ id_a*{id_a <- id_a*} }), ({ id_p*{id_p <- id_p*} }))), then

  1. Return ?((fid, V, []))

2. Otherwise

  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:83.1-84.59
def $find_match_named_default<V>(fid, V, id_a*{id_a <- id_a*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})

1. (Let id_deft*{id_deft <- id_deft*} be $get_params_missing_names(id_p*{id_p <- id_p*}, id_a*{id_a <- id_a*}))

2. If (($find_match_named<V>(fid, V, id_a*{id_a <- id_a*} ++ id_deft*{id_deft <- id_deft*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}) =/= ?())), then

  1. Return ?((fid, V, id_deft*{id_deft <- id_deft*}))

3. Otherwise

  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:94.1-95.61
def $find_match_unnamed_default<V>(fid, V, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})

1. (Let ((id, bool)*{bool <- bool*, id <- id*}, (id_deft, bool')*{bool' <- bool'*, id_deft <- id_deft*}) be $partition_<(id, bool)>((id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}, |id_a?{id_a <- id_a?}*{id_a? <- id_a?*}|))

2. If ((bool' = true))*{bool' <- bool'*}, then

  1. Return ?((fid, V, id_deft*{id_deft <- id_deft*}))

3. Otherwise

  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:104.1-105.57
def $find_matching_func<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a''*{id_a'' <- id_a''*}, (id_f' (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V)

1. (Let id_a' be id_a'')*{id_a'' <- id_a''*, id_a' <- id_a'*}

2. Case analysis on $check_func_name(id_f, id_f')

  1. Case false

    1. Return ?()

  2. Case true

    1. If ($check_arity_more(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})), then

      1. Return ?()

    1. Else Phantom#480 ($check_func_name(id_f, id_f')) /\ (~$check_arity_more(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}))

3. If ((|id_a'*{id_a' <- id_a'*}| > 0)), then

  1. If ($check_func_name(id_f, id_f')), then

    1. If ($check_arity(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})), then

      1. Return $find_match_named<V>((id_f' (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V, id_a'*{id_a' <- id_a'*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})

    1. Else Phantom#481 ((|id_a'*{id_a' <- id_a'*}| > 0)) /\ ($check_func_name(id_f, id_f')) /\ (~$check_arity(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}))

  1. Else Phantom#482 ((|id_a'*{id_a' <- id_a'*}| > 0)) /\ (~$check_func_name(id_f, id_f'))

3. Else Phantom#483 (~(|id_a'*{id_a' <- id_a'*}| > 0))

4. (Let id be id_a'')*{id_a'' <- id_a''*, id <- id*}

5. If ((id*{id <- id*} matches pattern [])), then

  1. If ($check_func_name(id_f, id_f')), then

    1. If ($check_arity(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})), then

      1. Return ?(((id_f' (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V, []))

    1. Else Phantom#484 ((id*{id <- id*} matches pattern [])) /\ ($check_func_name(id_f, id_f')) /\ (~$check_arity(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}))

    2. If ($check_arity_less(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})), then

      1. Return $find_match_unnamed_default<V>((id_f' (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})

    2. Else Phantom#485 ((id*{id <- id*} matches pattern [])) /\ ($check_func_name(id_f, id_f')) /\ (~$check_arity_less(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}))

  1. Else Phantom#486 ((id*{id <- id*} matches pattern [])) /\ (~$check_func_name(id_f, id_f'))

5. Else Phantom#487 (~(id*{id <- id*} matches pattern []))

6. If ((|id_a'*{id_a' <- id_a'*}| > 0)), then

  1. If ($check_func_name(id_f, id_f')), then

    1. If ($check_arity_less(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*})), then

      1. Return $find_match_named_default<V>((id_f' (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*}), V, id_a'*{id_a' <- id_a'*}, (id_p, bool_p)*{bool_p <- bool_p*, id_p <- id_p*})

    1. Else Phantom#488 ((|id_a'*{id_a' <- id_a'*}| > 0)) /\ ($check_func_name(id_f, id_f')) /\ (~$check_arity_less(id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_p*{id_p <- id_p*}))

  1. Else Phantom#489 ((|id_a'*{id_a' <- id_a'*}| > 0)) /\ (~$check_func_name(id_f, id_f'))

6. Else Phantom#490 (~(|id_a'*{id_a' <- id_a'*}| > 0))

;; ../../../../spec/2e-runtime-env.watsup:142.1-143.58
def $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid''*{fid'' <- fid''*}, V''*{V'' <- V''*})

1. (Let fid be fid'')*{fid'' <- fid''*, fid <- fid*}

2. (Let V be V'')*{V'' <- V''*, V <- V*}

3. Case analysis on fid*{fid <- fid*}

  1. Case (% matches pattern [])

    1. If ((V*{V <- V*} matches pattern [])), then

      1. Return []

    1. Else Phantom#491 ((fid*{fid <- fid*} matches pattern [])) /\ (~(V*{V <- V*} matches pattern []))

  2. Case (% matches pattern _ :: _)

    1. (Let fid_h :: fid_t*{fid_t <- fid_t*} be fid*{fid <- fid*})

    2. If ((V*{V <- V*} matches pattern _ :: _)), then

      1. (Let V_h :: V_t*{V_t <- V_t*} be V*{V <- V*})

      2. If (($find_matching_func<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid_h, V_h) = ?())), then

        1. Return $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid_t*{fid_t <- fid_t*}, V_t*{V_t <- V_t*})

      2. Else Phantom#492 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ ((V*{V <- V*} matches pattern _ :: _)) /\ (~($find_matching_func<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid_h, V_h) = ?()))

    2. Else Phantom#493 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ (~(V*{V <- V*} matches pattern _ :: _))

4. (Let fid' be fid'')*{fid'' <- fid''*, fid' <- fid'*}

5. (Let V' be V'')*{V'' <- V''*, V' <- V'*}

6. If ((fid'*{fid' <- fid'*} matches pattern _ :: _)), then

  1. (Let fid_h :: fid_t*{fid_t <- fid_t*} be fid'*{fid' <- fid'*})

  2. If ((V'*{V' <- V'*} matches pattern _ :: _)), then

    1. (Let V_h :: V_t*{V_t <- V_t*} be V'*{V' <- V'*})

    2. (Let (fid, V, id*)?{(fid, V, id*) <- (fid, V, id*)?} be $find_matching_func<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid_h, V_h))

    3. If (((fid, V, id*)?{(fid, V, id*) <- (fid, V, id*)?} matches pattern (_))), then

      1. (Let ?((fid, V, id_deft*{id_deft <- id_deft*})) be (fid, V, id*)?{(fid, V, id*) <- (fid, V, id*)?})

      2. Return (fid, V, id_deft*{id_deft <- id_deft*}) :: $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid_t*{fid_t <- fid_t*}, V_t*{V_t <- V_t*})

    3. Else Phantom#494 ((fid'*{fid' <- fid'*} matches pattern _ :: _)) /\ ((V'*{V' <- V'*} matches pattern _ :: _)) /\ (~((fid, V, id*)?{(fid, V, id*) <- (fid, V, id*)?} matches pattern (_)))

  2. Else Phantom#495 ((fid'*{fid' <- fid'*} matches pattern _ :: _)) /\ (~(V'*{V' <- V'*} matches pattern _ :: _))

6. Else Phantom#496 (~(fid'*{fid' <- fid'*} matches pattern _ :: _))

;; ../../../../spec/2e-runtime-env.watsup:156.1-157.41
def $find_func<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, ({ (fid -> V)*{V <- V*, fid <- fid*} }))

1. If ((|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| > 0)), then

  1. (Let id?{id <- id?} be id_a?{id_a <- id_a?})*{id? <- id?*, id_a? <- id_a?*}

  2. If ((id?{id <- id?} matches pattern (_)))*{id? <- id?*}, then

    1. (Let ?(id_a') be id?{id <- id?})*{id? <- id?*, id_a' <- id_a'*}

    2. If (($find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid*{fid <- fid*}, V*{V <- V*}) = [])), then

      1. Return ?()

    2. Else Phantom#497 ((|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| > 0)) /\ (forall (id?{id <- id?} matches pattern (_)))*{id? <- id?*} /\ (~($find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid*{fid <- fid*}, V*{V <- V*}) = []))

    3. (Let (fid, V, id*)*{(fid, V, id*) <- (fid, V, id*)*} be $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, id_a'*{id_a' <- id_a'*}, fid*{fid <- fid*}, V*{V <- V*}))

    4. If (((fid, V, id*)*{(fid, V, id*) <- (fid, V, id*)*} matches pattern [ _/1 ])), then

      1. (Let [(fid', V', id_deft*{id_deft <- id_deft*})] be (fid, V, id*)*{(fid, V, id*) <- (fid, V, id*)*})

      2. Return ?((fid', V', id_deft*{id_deft <- id_deft*}))

    4. Else Phantom#498 ((|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| > 0)) /\ (forall (id?{id <- id?} matches pattern (_)))*{id? <- id?*} /\ (~((fid, V, id*)*{(fid, V, id*) <- (fid, V, id*)*} matches pattern [ _/1 ]))

  2. Else Phantom#499 ((|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| > 0)) /\ (exists ~(id?{id <- id?} matches pattern (_)))*{id? <- id?*}

1. Else Phantom#500 (~(|id_a?{id_a <- id_a?}*{id_a? <- id_a?*}| > 0))

2. If ((id_a?{id_a <- id_a?} = ?()))*{id_a? <- id_a?*}, then

  1. If (($find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, [], fid*{fid <- fid*}, V*{V <- V*}) = [])), then

    1. Return ?()

  1. Else Phantom#501 (forall (id_a?{id_a <- id_a?} = ?()))*{id_a? <- id_a?*} /\ (~($find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, [], fid*{fid <- fid*}, V*{V <- V*}) = []))

  2. (Let (fid, V, id*)*{(fid, V, id*) <- (fid, V, id*)*} be $find_matching_funcs<V>(id_f, id_a?{id_a <- id_a?}*{id_a? <- id_a?*}, [], fid*{fid <- fid*}, V*{V <- V*}))

  3. If (((fid, V, id*)*{(fid, V, id*) <- (fid, V, id*)*} matches pattern [ _/1 ])), then

    1. (Let [(fid', V', id_deft*{id_deft <- id_deft*})] be (fid, V, id*)*{(fid, V, id*) <- (fid, V, id*)*})

    2. Return ?((fid', V', id_deft*{id_deft <- id_deft*}))

  3. Else Phantom#502 (forall (id_a?{id_a <- id_a?} = ?()))*{id_a? <- id_a?*} /\ (~((fid, V, id*)*{(fid, V, id*) <- (fid, V, id*)*} matches pattern [ _/1 ]))

2. Else Phantom#503 (exists ~(id_a?{id_a <- id_a?} = ?()))*{id_a? <- id_a?*}

;; ../../../../spec/2e-runtime-env.watsup:180.1-180.55
def $find_funcs_by_name(id_f, fid*{fid <- fid*}, funcdef*{funcdef <- funcdef*})

1. Case analysis on fid*{fid <- fid*}

  1. Case (% matches pattern [])

    1. If ((funcdef*{funcdef <- funcdef*} matches pattern [])), then

      1. Return []

    1. Else Phantom#504 ((fid*{fid <- fid*} matches pattern [])) /\ (~(funcdef*{funcdef <- funcdef*} matches pattern []))

  2. Case (% matches pattern _ :: _)

    1. (Let (id_h _(id, bool)*{_(id, bool) <- _(id, bool)*}) :: fid_t*{fid_t <- fid_t*} be fid*{fid <- fid*})

    2. If ((funcdef*{funcdef <- funcdef*} matches pattern _ :: _)), then

      1. (Let fd_h :: fd_t*{fd_t <- fd_t*} be funcdef*{funcdef <- funcdef*})

      2. If ((id_f = id_h)), then

        1. Return fd_h :: $find_funcs_by_name(id_f, fid_t*{fid_t <- fid_t*}, fd_t*{fd_t <- fd_t*})

      2. Else Phantom#505 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ ((funcdef*{funcdef <- funcdef*} matches pattern _ :: _)) /\ (~(id_f = id_h))

    2. Else Phantom#506 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ (~(funcdef*{funcdef <- funcdef*} matches pattern _ :: _))

    3. (Let _fid :: fid_t*{fid_t <- fid_t*} be fid*{fid <- fid*})

    4. If ((funcdef*{funcdef <- funcdef*} matches pattern _ :: _)), then

      1. (Let _funcdef :: fd_t*{fd_t <- fd_t*} be funcdef*{funcdef <- funcdef*})

      2. Otherwise

        1. Return $find_funcs_by_name(id_f, fid_t*{fid_t <- fid_t*}, fd_t*{fd_t <- fd_t*})

    4. Else Phantom#507 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ (~(funcdef*{funcdef <- funcdef*} matches pattern _ :: _))

;; ../../../../spec/2e-runtime-env.watsup:192.1-193.23
def $find_func_by_name(id_f, ({ (fid -> fd)*{fd <- fd*, fid <- fid*} }))

1. If (([] = $find_funcs_by_name(id_f, fid*{fid <- fid*}, fd*{fd <- fd*}))), then

  1. Return ?()

1. Else Phantom#508 (~([] = $find_funcs_by_name(id_f, fid*{fid <- fid*}, fd*{fd <- fd*})))

2. (Let funcdef*{funcdef <- funcdef*} be $find_funcs_by_name(id_f, fid*{fid <- fid*}, fd*{fd <- fd*}))

3. If ((funcdef*{funcdef <- funcdef*} matches pattern [ _/1 ])), then

  1. (Let [fd_f] be funcdef*{funcdef <- funcdef*})

  2. Return ?(fd_f)

3. Else Phantom#509 (~(funcdef*{funcdef <- funcdef*} matches pattern [ _/1 ]))

;; ../../../../spec/2f-runtime-ctk.watsup:5.14-5.30
syntax ctk = 
   | `LCTK`()
   | `CTK`()
   | `DYN`()

;; ../../../../spec/2f-runtime-ctk.watsup:7.1-7.81
def $join_ctk(ctk'', ctk''')

1. Case analysis on ctk''

  1. Case (% matches pattern `LCTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (LCTK)

      2. Case (% matches pattern `CTK`)

        1. Return (CTK)

  2. Case (% matches pattern `CTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (CTK)

      2. Case (% matches pattern `CTK`)

        1. Return (CTK)

2. Otherwise

  1. Return (DYN)

;; ../../../../spec/2f-runtime-ctk.watsup:16.1-16.75
def $joins_ctk(ctk''*{ctk'' <- ctk''*})

1. (Let ctk be ctk'')*{ctk'' <- ctk''*, ctk <- ctk*}

2. If ((ctk*{ctk <- ctk*} matches pattern [])), then

  1. Return (DYN)

2. Else Phantom#510 (~(ctk*{ctk <- ctk*} matches pattern []))

3. (Let ctk' be ctk'')*{ctk'' <- ctk''*, ctk' <- ctk'*}

4. Case analysis on ctk'*{ctk' <- ctk'*}

  1. Case (% matches pattern [ _/1 ])

    1. (Let [ctk] be ctk'*{ctk' <- ctk'*})

    2. Return ctk

  2. Case (% matches pattern _ :: _)

    1. (Let ctk_a :: ctk*{ctk <- ctk*} be ctk'*{ctk' <- ctk'*})

    2. Case analysis on ctk*{ctk <- ctk*}

      1. Case (% matches pattern [ _/1 ])

        1. (Let [ctk_b] be ctk*{ctk <- ctk*})

        2. Return $join_ctk(ctk_a, ctk_b)

      2. Case (% matches pattern _ :: _)

        1. (Let ctk_b :: ctk_c*{ctk_c <- ctk_c*} be ctk*{ctk <- ctk*})

        2. (Let ctk_d be $join_ctk(ctk_a, ctk_b))

        3. Return $joins_ctk(ctk_d :: ctk_c*{ctk_c <- ctk_c*})

    2. Else Phantom#511 ((ctk'*{ctk' <- ctk'*} matches pattern _ :: _)) /\ (~(ctk*{ctk <- ctk*} matches pattern [ _/1 ])) /\ (~(ctk*{ctk <- ctk*} matches pattern _ :: _))

4. Else Phantom#512 (~(ctk'*{ctk' <- ctk'*} matches pattern [ _/1 ])) /\ (~(ctk'*{ctk' <- ctk'*} matches pattern _ :: _))

;; ../../../../spec/2g-runtime-flow.watsup:5.15-5.25
syntax flow = 
   | `CONT`()
   | `RET`()

;; ../../../../spec/2g-runtime-flow.watsup:9.1-9.85
def $join_flow(flow'', flow''')

1. If ((flow'' matches pattern `RET`)), then

  1. If ((flow''' matches pattern `RET`)), then

    1. Return (RET)

  1. Else Phantom#513 ((flow'' matches pattern `RET`)) /\ (~(flow''' matches pattern `RET`))

1. Else Phantom#514 (~(flow'' matches pattern `RET`))

2. Return (CONT)

;; ../../../../spec/3-syntax-il.watsup:5.16-5.19
syntax numIL = num

;; ../../../../spec/3-syntax-il.watsup:15.15-15.17
syntax idIL = id

;; ../../../../spec/3-syntax-il.watsup:21.17-21.21
syntax nameIL = name

;; ../../../../spec/3-syntax-il.watsup:27.19-27.23
syntax memberIL = idIL

;; ../../../../spec/3-syntax-il.watsup:33.22-33.26
syntax matchkindIL = idIL

;; ../../../../spec/3-syntax-il.watsup:39.23-39.27
syntax statelabelIL = idIL

;; ../../../../spec/3-syntax-il.watsup:45.17-45.21
syntax unopIL = unop

;; ../../../../spec/3-syntax-il.watsup:51.18-51.23
syntax binopIL = binop

;; ../../../../spec/3-syntax-il.watsup:57.16-57.19
syntax dirIL = dir

;; ../../../../spec/3-syntax-il.watsup:69.17-69.20
syntax typeIL = typ

;; ../../../../spec/3-syntax-il.watsup:75.19-75.21
syntax tparamIL = id

;; ../../../../spec/3-syntax-il.watsup:81.18-81.40
syntax paramIL = 
   | `%%%%`(idIL, dirIL, typeIL, val?)

;; ../../../../spec/3-syntax-il.watsup:87.19-87.26
syntax cparamIL = paramIL

;; ../../../../spec/3-syntax-il.watsup:93.17-93.23
syntax targIL = typeIL

;; ../../../../spec/3-syntax-il.watsup:100.1-102.39
syntax argIL = 
   | `ExprA%`(exprIL)
   | `NameA%%`(idIL, exprIL?)
   | `AnyA`()

;; ../../../../spec/3-syntax-il.watsup:109.1-111.33
syntax keysetIL = 
   | `ExprK%`(exprIL)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec/3-syntax-il.watsup:117.23-117.45
syntax selectcaseIL = 
   | `%%`(keysetIL*, statelabelIL)

;; ../../../../spec/3-syntax-il.watsup:123.18-123.29
syntax annotIL = 
   | `(%;%)`(typ, ctk)

;; ../../../../spec/3-syntax-il.watsup:125.1-145.128
syntax exprIL = 
   | `ValueE%%`(val, annotIL)
   | `NameE%%`(nameIL, annotIL)
   | `SeqE%%`(exprIL*, annotIL)
   | `SeqDefaultE%%`(exprIL*, annotIL)
   | `RecordE%%`((memberIL, exprIL)*, annotIL)
   | `RecordDefaultE%%`((memberIL, exprIL)*, annotIL)
   | `DefaultE%`(annotIL)
   | `UnE%%%`(unopIL, exprIL, annotIL)
   | `BinE%%%%`(binopIL, exprIL, exprIL, annotIL)
   | `TernE%%%%`(exprIL, exprIL, exprIL, annotIL)
   | `CastE%%%`(typeIL, exprIL, annotIL)
   | `MaskE%%%`(exprIL, exprIL, annotIL)
   | `RangeE%%%`(exprIL, exprIL, annotIL)
   | `SelectE%%%`(exprIL*, selectcaseIL*, annotIL)
   | `ArrAccE%%%`(exprIL, exprIL, annotIL)
   | `BitAccE%%%%`(exprIL, exprIL, exprIL, annotIL)
   | `ExprAccE%%%`(exprIL, memberIL, annotIL)
   | `CallFuncE%%%%`(nameIL, targIL*, argIL*, annotIL)
   | `CallMethodE%%%%%`(exprIL, memberIL, targIL*, argIL*, annotIL)
   | `CallTypeE%%%%%`(nameIL, memberIL, targIL*, argIL*, annotIL)
   | `InstE%%%%`(nameIL, targIL*, argIL*, annotIL)

;; ../../../../spec/3-syntax-il.watsup:151.18-151.75
syntax blockIL = 
   | `BlockB%`(stmtIL*)

;; ../../../../spec/3-syntax-il.watsup:158.1-169.67
syntax stmtIL = 
   | `EmptyS`()
   | `AssignS%%`(exprIL, exprIL)
   | `SwitchS%%`(exprIL, switchcaseIL*)
   | `IfS%%%`(exprIL, stmtIL, stmtIL)
   | `BlockS%`(blockIL)
   | `ExitS`()
   | `RetS%`(exprIL?)
   | `CallFuncS%%%`(nameIL, targIL*, argIL*)
   | `CallMethodS%%%%`(exprIL, memberIL, targIL*, argIL*)
   | `CallInstS%%%%`(typeIL, nameIL, targIL*, argIL*)
   | `TransS%`(exprIL)
   | `DeclS%`(declIL)

;; ../../../../spec/3-syntax-il.watsup:176.1-177.39
syntax switchlabelIL = 
   | `ExprL%`(exprIL)
   | `DefaultL`()

;; ../../../../spec/3-syntax-il.watsup:180.1-181.56
syntax switchcaseIL = 
   | `MatchC%%`(switchlabelIL, blockIL)
   | `FallC%`(switchlabelIL)

;; ../../../../spec/3-syntax-il.watsup:187.24-187.44
syntax parserstateIL = 
   | `%%`(statelabelIL, blockIL)

;; ../../../../spec/3-syntax-il.watsup:193.16-193.26
syntax tblIL = tblpropIL*

;; ../../../../spec/3-syntax-il.watsup:199.19-199.37
syntax tblkeyIL = 
   | `%%`(exprIL, matchkindIL)

;; ../../../../spec/3-syntax-il.watsup:200.23-200.32
syntax tblkeypropIL = tblkeyIL*

;; ../../../../spec/3-syntax-il.watsup:206.22-206.53
syntax tblactionIL = 
   | `%%%%`(nameIL, argIL*, paramIL*, paramIL*)

;; ../../../../spec/3-syntax-il.watsup:207.26-207.38
syntax tblactionpropIL = tblactionIL*

;; ../../../../spec/3-syntax-il.watsup:213.21-213.52
syntax tblentryIL = 
   | `%%%%`(bool, keysetIL*, tblactionIL, val?)

;; ../../../../spec/3-syntax-il.watsup:214.25-214.41
syntax tblentrypropIL = 
   | `%%`(bool, tblentryIL*)

;; ../../../../spec/3-syntax-il.watsup:220.27-220.43
syntax tbldefaultpropIL = 
   | `%%`(bool, tblactionIL)

;; ../../../../spec/3-syntax-il.watsup:226.26-226.46
syntax tblcustompropIL = 
   | `%%%`(bool, memberIL, exprIL)

;; ../../../../spec/3-syntax-il.watsup:233.1-237.80
syntax tblpropIL = 
   | `KeyP%`(tblkeypropIL)
   | `ActionP%`(tblactionpropIL)
   | `EntryP%`(tblentrypropIL)
   | `DefaultP%`(tbldefaultpropIL)
   | `CustomP%`(tblcustompropIL)

;; ../../../../spec/3-syntax-il.watsup:244.1-246.53
syntax methodIL = 
   | `ExternConsM%%%`(idIL, tparamIL*, cparamIL*)
   | `ExternAbstractM%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)
   | `ExternM%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)

;; ../../../../spec/3-syntax-il.watsup:255.1-277.52
syntax declIL = 
   | `ConstD%%%`(idIL, typeIL, val)
   | `VarD%%%`(idIL, typeIL, exprIL?)
   | `ErrD%`(memberIL*)
   | `MatchKindD%`(memberIL*)
   | `InstD%%%%%%`(idIL, typeIL, nameIL, targIL*, argIL*, declIL*)
   | `StructD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `HeaderD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `UnionD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `EnumD%%`(idIL, memberIL*)
   | `SEnumD%%%`(idIL, typeIL, (memberIL, val)*)
   | `NewTypeD%%`(idIL, typedefIL)
   | `TypeDefD%%`(idIL, typedefIL)
   | `ValueSetD%%%`(idIL, typeIL, exprIL)
   | `ParserTypeD%%%%`(idIL, tparamIL*, tparamIL*, paramIL*)
   | `ParserD%%%%%`(idIL, paramIL*, cparamIL*, declIL*, parserstateIL*)
   | `TableD%%%`(idIL, typeIL, tblIL)
   | `ControlTypeD%%%%`(idIL, tparamIL*, tparamIL*, paramIL*)
   | `ControlD%%%%%`(idIL, paramIL*, cparamIL*, declIL*, blockIL)
   | `ActionD%%%`(idIL, paramIL*, blockIL)
   | `FuncD%%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*, blockIL)
   | `ExternFuncD%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)
   | `ExternObjectD%%%`(idIL, tparamIL*, methodIL*)
   | `PackageTypeD%%%%`(idIL, tparamIL*, tparamIL*, cparamIL*)

;; ../../../../spec/3-syntax-il.watsup:280.1-281.17
syntax typedefIL = 
   | `TypeD%`(typeIL)
   | `DeclD%`(declIL)

;; ../../../../spec/3-syntax-il.watsup:287.20-287.27
syntax programIL = declIL*

;; ../../../../spec/4a1-typing-context.watsup:5.17-5.39
syntax cursor = 
   | `GLOBAL`()
   | `BLOCK`()
   | `LOCAL`()

;; ../../../../spec/4a1-typing-context.watsup:16.3-19.18
syntax glayer = {`CDENV%`(cdenv), `TDENV%`(tdenv), `FDENV%`(fdenv), `FRAME%`(frame)}

;; ../../../../spec/4a1-typing-context.watsup:23.16-23.59
syntax bkind = 
   | `EMPTY`()
   | `EXTERN`()
   | `PARSER`()
   | `CONTROL`()
   | `PACKAGE`()

;; ../../../../spec/4a1-typing-context.watsup:26.3-30.18
syntax blayer = {`ID%`(id), `KIND%`(bkind), `TDENV%`(tdenv), `FDENV%`(fdenv), `FRAME%`(frame)}

;; ../../../../spec/4a1-typing-context.watsup:35.1-43.21
syntax lkind = 
   | `EMPTY`()
   | `EXTERNFUNC`()
   | `FUNC%`(typ)
   | `ACTION`()
   | `EXTERNMETHOD`()
   | `EXTERNABSTRACTMETHOD%`(typ)
   | `PARSERSTATE`()
   | `CONTROLAPPLYMETHOD`()
   | `TABLEAPPLYMETHOD`()

;; ../../../../spec/4a1-typing-context.watsup:46.3-49.20
syntax llayer = {`ID%`(id), `KIND%`(lkind), `TDENV%`(tdenv), `FRAMES%`(frame*)}

;; ../../../../spec/4a1-typing-context.watsup:56.3-58.19
syntax context = {`GLOBAL%`(glayer), `BLOCK%`(blayer), `LOCAL%`(llayer)}

;; ../../../../spec/4a1-typing-context.watsup:66.1-66.29
def $empty_context

1. (Let glayer be {CDENV $empty_map<cid, consdef>, TDENV $empty_map<tid, typdef>, FDENV $empty_map<fid, funcdef>, FRAME $empty_map<id, styp>})

2. (Let blayer be {ID "", KIND (EMPTY), TDENV $empty_map<tid, typdef>, FDENV $empty_map<fid, funcdef>, FRAME $empty_map<id, styp>})

3. (Let llayer be {ID "", KIND (EMPTY), TDENV $empty_map<tid, typdef>, FRAMES [$empty_map<id, styp>]})

4. (Let C be {GLOBAL glayer, BLOCK blayer, LOCAL llayer})

5. Return C

;; ../../../../spec/4a1-typing-context.watsup:91.1-92.23
def $enter(C)

1. Return C[LOCAL.FRAMES = $empty_map<id, styp> :: C.LOCAL.FRAMES]

;; ../../../../spec/4a1-typing-context.watsup:96.1-97.22
def $exit(C)

1. (Let frame*{frame <- frame*} be C.LOCAL.FRAMES)

2. If ((frame*{frame <- frame*} matches pattern _ :: _)), then

  1. (Let frame_h :: frame_t*{frame_t <- frame_t*} be frame*{frame <- frame*})

  2. Return C[LOCAL.FRAMES = frame_t*{frame_t <- frame_t*}]

2. Else Phantom#515 (~(frame*{frame <- frame*} matches pattern _ :: _))

;; ../../../../spec/4a1-typing-context.watsup:106.1-107.34
def $set_blockkind(C, bkind)

1. Return C[BLOCK.KIND = bkind]

;; ../../../../spec/4a1-typing-context.watsup:111.1-112.35
def $set_localkind(C, lkind)

1. Return C[LOCAL.KIND = lkind]

;; ../../../../spec/4a1-typing-context.watsup:116.1-117.63
def $set_blockframe



;; ../../../../spec/4a1-typing-context.watsup:123.1-124.32
def $get_typ_ret_lkind(lkind)

1. Case analysis on lkind

  1. Case (% matches pattern `FUNC%`)

    1. (Let (FUNC typ) be lkind)

    2. Return typ

  2. Case (% matches pattern `ACTION`)

    1. Return ((VoidT) as typ)

  3. Case (% matches pattern `EXTERNABSTRACTMETHOD%`)

    1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

    2. Return typ

  4. Case (% matches pattern `CONTROLAPPLYMETHOD`)

    1. Return ((VoidT) as typ)

1. Else Phantom#516 (~(lkind matches pattern `FUNC%`)) /\ (~(lkind matches pattern `ACTION`)) /\ (~(lkind matches pattern `EXTERNABSTRACTMETHOD%`)) /\ (~(lkind matches pattern `CONTROLAPPLYMETHOD`))

;; ../../../../spec/4a1-typing-context.watsup:135.1-135.42
def $bound_tids(cursor, C)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return $empty_set<tid>

  2. Case (% matches pattern `BLOCK`)

    1. Return $dom_map<tid, typdef>(C.BLOCK.TDENV)

  3. Case (% matches pattern `LOCAL`)

    1. Return $union_set<tid>($dom_map<tid, typdef>(C.LOCAL.TDENV), $bound_tids((BLOCK), C))

;; ../../../../spec/4a1-typing-context.watsup:147.1-148.84
def $add_styp(cursor, C, id, styp)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. If (~$in_set<id>(id, $dom_map<id, styp>(C.GLOBAL.FRAME))), then

      1. (Let frame be $add_map<id, styp>(C.GLOBAL.FRAME, id, styp))

      2. Return C[GLOBAL.FRAME = frame]

    1. Else Phantom#517 ((cursor matches pattern `GLOBAL`)) /\ (~~$in_set<id>(id, $dom_map<id, styp>(C.GLOBAL.FRAME)))

  2. Case (% matches pattern `BLOCK`)

    1. If (~$in_set<id>(id, $dom_map<id, styp>(C.BLOCK.FRAME))), then

      1. (Let frame be $add_map<id, styp>(C.BLOCK.FRAME, id, styp))

      2. Return C[BLOCK.FRAME = frame]

    1. Else Phantom#518 ((cursor matches pattern `BLOCK`)) /\ (~~$in_set<id>(id, $dom_map<id, styp>(C.BLOCK.FRAME)))

  3. Case (% matches pattern `LOCAL`)

    1. (Let frame'*{frame' <- frame'*} be C.LOCAL.FRAMES)

    2. If ((frame'*{frame' <- frame'*} matches pattern _ :: _)), then

      1. (Let frame_h :: frame_t*{frame_t <- frame_t*} be frame'*{frame' <- frame'*})

      2. If (~$in_set<id>(id, $dom_map<id, styp>(frame_h))), then

        1. (Let frame_h' be $add_map<id, styp>(frame_h, id, styp))

        2. (Let frame*{frame <- frame*} be frame_h' :: frame_t*{frame_t <- frame_t*})

        3. Return C[LOCAL.FRAMES = frame*{frame <- frame*}]

      2. Else Phantom#519 ((cursor matches pattern `LOCAL`)) /\ ((frame'*{frame' <- frame'*} matches pattern _ :: _)) /\ (~~$in_set<id>(id, $dom_map<id, styp>(frame_h)))

    2. Else Phantom#520 ((cursor matches pattern `LOCAL`)) /\ (~(frame'*{frame' <- frame'*} matches pattern _ :: _))

;; ../../../../spec/4a1-typing-context.watsup:162.1-163.88
def $add_styps(cursor, C, id*{id <- id*}, styp*{styp <- styp*})

1. Case analysis on id*{id <- id*}

  1. Case (% matches pattern [])

    1. If ((styp*{styp <- styp*} matches pattern [])), then

      1. Return C

    1. Else Phantom#521 ((id*{id <- id*} matches pattern [])) /\ (~(styp*{styp <- styp*} matches pattern []))

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t*{id_t <- id_t*} be id*{id <- id*})

    2. If ((styp*{styp <- styp*} matches pattern _ :: _)), then

      1. (Let styp_h :: styp_t*{styp_t <- styp_t*} be styp*{styp <- styp*})

      2. (Let C' be $add_styp(cursor, C, id_h, styp_h))

      3. (Let C'' be $add_styps(cursor, C', id_t*{id_t <- id_t*}, styp_t*{styp_t <- styp_t*}))

      4. Return C''

    2. Else Phantom#522 ((id*{id <- id*} matches pattern _ :: _)) /\ (~(styp*{styp <- styp*} matches pattern _ :: _))

;; ../../../../spec/4a1-typing-context.watsup:172.1-172.52
def $add_param(p, C, pt)

1. (Let (id dir typ val?{val <- val?}) be pt)

2. Case analysis on dir

  1. Case (% matches pattern `NO`)

    1. (Let C' be $add_styp(p, C, id, (typ (NO) (CTK) ?())))

    2. Return C'

  2. Case (% matches pattern `IN`)

    1. (Let C' be $add_styp(p, C, id, (typ dir (DYN) ?())))

    2. Return C'

  3. Case (% matches pattern `OUT`)

    1. (Let C' be $add_styp(p, C, id, (typ dir (DYN) ?())))

    2. Return C'

  4. Case (% matches pattern `INOUT`)

    1. (Let C' be $add_styp(p, C, id, (typ dir (DYN) ?())))

    2. Return C'

;; ../../../../spec/4a1-typing-context.watsup:182.1-182.54
def $add_params(p, C, paramtyp*{paramtyp <- paramtyp*})

1. Case analysis on paramtyp*{paramtyp <- paramtyp*}

  1. Case (% matches pattern [])

    1. Return C

  2. Case (% matches pattern _ :: _)

    1. (Let pt_h :: pt_t*{pt_t <- pt_t*} be paramtyp*{paramtyp <- paramtyp*})

    2. (Let C' be $add_param(p, C, pt_h))

    3. (Let C'' be $add_params(p, C', pt_t*{pt_t <- pt_t*}))

    4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:191.1-192.80
def $add_typdef(cursor, C, tid, td)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. If (~$in_set<tid>(tid, $dom_map<tid, typdef>(C.GLOBAL.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.GLOBAL.TDENV, tid, td))

      2. Return C[GLOBAL.TDENV = tdenv]

    1. Else Phantom#523 ((cursor matches pattern `GLOBAL`)) /\ (~~$in_set<tid>(tid, $dom_map<tid, typdef>(C.GLOBAL.TDENV)))

  2. Case (% matches pattern `BLOCK`)

    1. If (~$in_set<tid>(tid, $dom_map<tid, typdef>(C.BLOCK.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.BLOCK.TDENV, tid, td))

      2. Return C[BLOCK.TDENV = tdenv]

    1. Else Phantom#524 ((cursor matches pattern `BLOCK`)) /\ (~~$in_set<tid>(tid, $dom_map<tid, typdef>(C.BLOCK.TDENV)))

  3. Case (% matches pattern `LOCAL`)

    1. If (~$in_set<tid>(tid, $dom_map<tid, typdef>(C.LOCAL.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.LOCAL.TDENV, tid, td))

      2. Return C[LOCAL.TDENV = tdenv]

    1. Else Phantom#525 ((cursor matches pattern `LOCAL`)) /\ (~~$in_set<tid>(tid, $dom_map<tid, typdef>(C.LOCAL.TDENV)))

;; ../../../../spec/4a1-typing-context.watsup:204.1-205.84
def $add_typdefs(p, C, tid*{tid <- tid*}, typdef*{typdef <- typdef*})

1. Case analysis on tid*{tid <- tid*}

  1. Case (% matches pattern [])

    1. If ((typdef*{typdef <- typdef*} matches pattern [])), then

      1. Return C

    1. Else Phantom#526 ((tid*{tid <- tid*} matches pattern [])) /\ (~(typdef*{typdef <- typdef*} matches pattern []))

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t*{tid_t <- tid_t*} be tid*{tid <- tid*})

    2. If ((typdef*{typdef <- typdef*} matches pattern _ :: _)), then

      1. (Let td_h :: td_t*{td_t <- td_t*} be typdef*{typdef <- typdef*})

      2. (Let C' be $add_typdef(p, C, tid_h, td_h))

      3. (Let C'' be $add_typdefs(p, C', tid_t*{tid_t <- tid_t*}, td_t*{td_t <- td_t*}))

      4. Return C''

    2. Else Phantom#527 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ (~(typdef*{typdef <- typdef*} matches pattern _ :: _))

;; ../../../../spec/4a1-typing-context.watsup:214.1-214.51
def $add_tparam(cursor, C, tparam)

1. Case analysis on cursor

  1. Case (% matches pattern `BLOCK`)

    1. (Let td be ((MonoD ((VarT tparam) as typ)) as typdef))

    2. If (~$in_set<tid>(tparam, $dom_map<tid, typdef>(C.BLOCK.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.BLOCK.TDENV, tparam, td))

      2. Return C[BLOCK.TDENV = tdenv]

    2. Else Phantom#528 ((cursor matches pattern `BLOCK`)) /\ (~~$in_set<tid>(tparam, $dom_map<tid, typdef>(C.BLOCK.TDENV)))

  2. Case (% matches pattern `LOCAL`)

    1. (Let td be ((MonoD ((VarT tparam) as typ)) as typdef))

    2. If (~$in_set<tid>(tparam, $dom_map<tid, typdef>(C.LOCAL.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.LOCAL.TDENV, tparam, td))

      2. Return C[LOCAL.TDENV = tdenv]

    2. Else Phantom#529 ((cursor matches pattern `LOCAL`)) /\ (~~$in_set<tid>(tparam, $dom_map<tid, typdef>(C.LOCAL.TDENV)))

1. Else Phantom#530 (~(cursor matches pattern `BLOCK`)) /\ (~(cursor matches pattern `LOCAL`))

;; ../../../../spec/4a1-typing-context.watsup:225.1-225.53
def $add_tparams(p, C, tparam*{tparam <- tparam*})

1. Case analysis on tparam*{tparam <- tparam*}

  1. Case (% matches pattern [])

    1. Return C

  2. Case (% matches pattern _ :: _)

    1. (Let tparam_h :: tparam_t*{tparam_t <- tparam_t*} be tparam*{tparam <- tparam*})

    2. (Let C' be $add_tparam(p, C, tparam_h))

    3. (Let C'' be $add_tparams(p, C', tparam_t*{tparam_t <- tparam_t*}))

    4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:234.1-235.80
def $add_funcdef(cursor, C, fid, fd)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. If (~$in_set<fid>(fid, $dom_map<fid, funcdef>(C.GLOBAL.FDENV))), then

      1. (Let fdenv be $add_map<fid, funcdef>(C.GLOBAL.FDENV, fid, fd))

      2. Return C[GLOBAL.FDENV = fdenv]

    1. Else Phantom#531 ((cursor matches pattern `GLOBAL`)) /\ (~~$in_set<fid>(fid, $dom_map<fid, funcdef>(C.GLOBAL.FDENV)))

  2. Case (% matches pattern `BLOCK`)

    1. If (~$in_set<fid>(fid, $dom_map<fid, funcdef>(C.BLOCK.FDENV))), then

      1. (Let fdenv be $add_map<fid, funcdef>(C.BLOCK.FDENV, fid, fd))

      2. Return C[BLOCK.FDENV = fdenv]

    1. Else Phantom#532 ((cursor matches pattern `BLOCK`)) /\ (~~$in_set<fid>(fid, $dom_map<fid, funcdef>(C.BLOCK.FDENV)))

1. Else Phantom#533 (~(cursor matches pattern `GLOBAL`)) /\ (~(cursor matches pattern `BLOCK`))

;; ../../../../spec/4a1-typing-context.watsup:244.1-245.80
def $add_funcdef_non_overload(cursor, C, fid, fd)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let ({ (id_k _(id, bool)*{_(id, bool) <- _(id, bool)*})*{_(id, bool)* <- _(id, bool)**, id_k <- id_k*} }) be $dom_map<fid, funcdef>(C.GLOBAL.FDENV))

    2. (Let (id _(id, bool)'*{_(id, bool)' <- _(id, bool)'*}) be fid)

    3. If (~id is in id_k*{id_k <- id_k*}), then

      1. (Let fdenv be $add_map<fid, funcdef>(C.GLOBAL.FDENV, fid, fd))

      2. Return C[GLOBAL.FDENV = fdenv]

    3. Else Phantom#534 ((cursor matches pattern `GLOBAL`)) /\ (~~id is in id_k*{id_k <- id_k*})

  2. Case (% matches pattern `BLOCK`)

    1. (Let ({ (id_k _(id, bool)*{_(id, bool) <- _(id, bool)*})*{_(id, bool)* <- _(id, bool)**, id_k <- id_k*} }) be $dom_map<fid, funcdef>(C.BLOCK.FDENV))

    2. (Let (id _(id, bool)'*{_(id, bool)' <- _(id, bool)'*}) be fid)

    3. If (~id is in id_k*{id_k <- id_k*}), then

      1. (Let fdenv be $add_map<fid, funcdef>(C.BLOCK.FDENV, fid, fd))

      2. Return C[BLOCK.FDENV = fdenv]

    3. Else Phantom#535 ((cursor matches pattern `BLOCK`)) /\ (~~id is in id_k*{id_k <- id_k*})

1. Else Phantom#536 (~(cursor matches pattern `GLOBAL`)) /\ (~(cursor matches pattern `BLOCK`))

;; ../../../../spec/4a1-typing-context.watsup:260.1-261.80
def $add_consdef(cursor, C, cid, cd)

1. If ((cursor matches pattern `GLOBAL`)), then

  1. If (~$in_set<cid>(cid, $dom_map<cid, consdef>(C.GLOBAL.CDENV))), then

    1. (Let cdenv be $add_map<cid, consdef>(C.GLOBAL.CDENV, cid, cd))

    2. Return C[GLOBAL.CDENV = cdenv]

  1. Else Phantom#537 ((cursor matches pattern `GLOBAL`)) /\ (~~$in_set<cid>(cid, $dom_map<cid, consdef>(C.GLOBAL.CDENV)))

1. Else Phantom#538 (~(cursor matches pattern `GLOBAL`))

;; ../../../../spec/4a1-typing-context.watsup:273.1-274.57
def $find_styp(p', C, name)

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_map<id, styp>(C.GLOBAL.FRAME, id)

1. Else Phantom#539 (~(name matches pattern `TOP%`))

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_map<id, styp>(C.GLOBAL.FRAME, id)

    1. Else Phantom#540 ((p' matches pattern `GLOBAL`)) /\ (~(name matches pattern `CURRENT%`))

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let styp'?{styp' <- styp'?} be $find_map<id, styp>(C.BLOCK.FRAME, id))

      3. If ((styp'?{styp' <- styp'?} matches pattern (_))), then

        1. (Let ?(styp) be styp'?{styp' <- styp'?})

        2. Return ?(styp)

      3. Else Phantom#541 ((p' matches pattern `BLOCK`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(styp'?{styp' <- styp'?} matches pattern (_)))

      4. If ((?() = $find_map<id, styp>(C.BLOCK.FRAME, id))), then

        1. Return $find_styp((GLOBAL), C, (CURRENT id))

      4. Else Phantom#542 ((p' matches pattern `BLOCK`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(?() = $find_map<id, styp>(C.BLOCK.FRAME, id)))

    1. Else Phantom#543 ((p' matches pattern `BLOCK`)) /\ (~(name matches pattern `CURRENT%`))

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let styp'?{styp' <- styp'?} be $find_maps<id, styp>(C.LOCAL.FRAMES, id))

      3. If ((styp'?{styp' <- styp'?} matches pattern (_))), then

        1. (Let ?(styp) be styp'?{styp' <- styp'?})

        2. Return ?(styp)

      3. Else Phantom#544 ((p' matches pattern `LOCAL`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(styp'?{styp' <- styp'?} matches pattern (_)))

      4. If ((?() = $find_maps<id, styp>(C.LOCAL.FRAMES, id))), then

        1. Return $find_styp((BLOCK), C, (CURRENT id))

      4. Else Phantom#545 ((p' matches pattern `LOCAL`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(?() = $find_maps<id, styp>(C.LOCAL.FRAMES, id)))

    1. Else Phantom#546 ((p' matches pattern `LOCAL`)) /\ (~(name matches pattern `CURRENT%`))

;; ../../../../spec/4a1-typing-context.watsup:289.1-290.44
def $find_val(p, C, name)

1. (Let styp?{styp <- styp?} be $find_styp(p, C, name))

2. If ((styp?{styp <- styp?} matches pattern (_))), then

  1. (Let ?((typ dir ctk val'?{val' <- val'?})) be styp?{styp <- styp?})

  2. If ((val'?{val' <- val'?} matches pattern (_))), then

    1. (Let ?(val) be val'?{val' <- val'?})

    2. Return ?(val)

  2. Else Phantom#547 ((styp?{styp <- styp?} matches pattern (_))) /\ (~(val'?{val' <- val'?} matches pattern (_)))

2. Else Phantom#548 (~(styp?{styp <- styp?} matches pattern (_)))

;; ../../../../spec/4a1-typing-context.watsup:297.1-298.44
def $find_typdef(p', C, name)

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_map<tid, typdef>(C.GLOBAL.TDENV, id)

1. Else Phantom#549 (~(name matches pattern `TOP%`))

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_map<tid, typdef>(C.GLOBAL.TDENV, id)

    1. Else Phantom#550 ((p' matches pattern `GLOBAL`)) /\ (~(name matches pattern `CURRENT%`))

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let typdef?{typdef <- typdef?} be $find_map<tid, typdef>(C.BLOCK.TDENV, id))

      3. If ((typdef?{typdef <- typdef?} matches pattern (_))), then

        1. (Let ?(td) be typdef?{typdef <- typdef?})

        2. Return ?(td)

      3. Else Phantom#551 ((p' matches pattern `BLOCK`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(typdef?{typdef <- typdef?} matches pattern (_)))

      4. If ((?() = $find_map<tid, typdef>(C.BLOCK.TDENV, id))), then

        1. Return $find_typdef((GLOBAL), C, (CURRENT id))

      4. Else Phantom#552 ((p' matches pattern `BLOCK`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(?() = $find_map<tid, typdef>(C.BLOCK.TDENV, id)))

    1. Else Phantom#553 ((p' matches pattern `BLOCK`)) /\ (~(name matches pattern `CURRENT%`))

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let typdef?{typdef <- typdef?} be $find_map<tid, typdef>(C.LOCAL.TDENV, id))

      3. If ((typdef?{typdef <- typdef?} matches pattern (_))), then

        1. (Let ?(td) be typdef?{typdef <- typdef?})

        2. Return ?(td)

      3. Else Phantom#554 ((p' matches pattern `LOCAL`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(typdef?{typdef <- typdef?} matches pattern (_)))

      4. If ((?() = $find_map<tid, typdef>(C.LOCAL.TDENV, id))), then

        1. Return $find_typdef((BLOCK), C, (CURRENT id))

      4. Else Phantom#555 ((p' matches pattern `LOCAL`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(?() = $find_map<tid, typdef>(C.LOCAL.TDENV, id)))

    1. Else Phantom#556 ((p' matches pattern `LOCAL`)) /\ (~(name matches pattern `CURRENT%`))

;; ../../../../spec/4a1-typing-context.watsup:313.1-313.28
def $to_fkey(arg*{arg <- arg*})

1. Case analysis on arg*{arg <- arg*}

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let arg_h :: arg_t*{arg_t <- arg_t*} be arg*{arg <- arg*})

    2. (Let arg' be arg_h)

    3. If ((arg' matches pattern `NameA%%`)), then

      1. (Let (NameA id _expr?{_expr <- _expr?}) be arg')

      2. Return ?(id) :: $to_fkey(arg_t*{arg_t <- arg_t*})

    3. Else Phantom#557 ((arg*{arg <- arg*} matches pattern _ :: _)) /\ (~(arg' matches pattern `NameA%%`))

    4. Otherwise

      1. Return ?() :: $to_fkey(arg_t*{arg_t <- arg_t*})

;; ../../../../spec/4a1-typing-context.watsup:321.1-322.58
def $find_funcdef(p', C, name, arg*{arg <- arg*})

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_func<funcdef>(id, $to_fkey(arg*{arg <- arg*}), C.GLOBAL.FDENV)

1. Else Phantom#558 (~(name matches pattern `TOP%`))

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_func<funcdef>(id, $to_fkey(arg*{arg <- arg*}), C.GLOBAL.FDENV)

    1. Else Phantom#559 ((p' matches pattern `GLOBAL`)) /\ (~(name matches pattern `CURRENT%`))

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} be $find_func<funcdef>(id, $to_fkey(arg*{arg <- arg*}), C.BLOCK.FDENV))

      3. If (((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_))), then

        1. (Let ?((fid, fd, id_deft*{id_deft <- id_deft*})) be (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?})

        2. Return ?((fid, fd, id_deft*{id_deft <- id_deft*}))

      3. Else Phantom#560 ((p' matches pattern `BLOCK`)) /\ ((name matches pattern `CURRENT%`)) /\ (~((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_)))

      4. If ((?() = $find_func<funcdef>(id, $to_fkey(arg*{arg <- arg*}), C.BLOCK.FDENV))), then

        1. Return $find_funcdef((GLOBAL), C, (CURRENT id), arg*{arg <- arg*})

      4. Else Phantom#561 ((p' matches pattern `BLOCK`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(?() = $find_func<funcdef>(id, $to_fkey(arg*{arg <- arg*}), C.BLOCK.FDENV)))

    1. Else Phantom#562 ((p' matches pattern `BLOCK`)) /\ (~(name matches pattern `CURRENT%`))

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_funcdef((BLOCK), C, (CURRENT id), arg*{arg <- arg*})

    1. Else Phantom#563 ((p' matches pattern `LOCAL`)) /\ (~(name matches pattern `CURRENT%`))

;; ../../../../spec/4a1-typing-context.watsup:332.1-333.44
def $find_funcdef_by_name(p', C, name)

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_func_by_name(id, C.GLOBAL.FDENV)

1. Else Phantom#564 (~(name matches pattern `TOP%`))

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_func_by_name(id, C.GLOBAL.FDENV)

    1. Else Phantom#565 ((p' matches pattern `GLOBAL`)) /\ (~(name matches pattern `CURRENT%`))

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let funcdef?{funcdef <- funcdef?} be $find_func_by_name(id, C.BLOCK.FDENV))

      3. If ((funcdef?{funcdef <- funcdef?} matches pattern (_))), then

        1. (Let ?(fd) be funcdef?{funcdef <- funcdef?})

        2. Return ?(fd)

      3. Else Phantom#566 ((p' matches pattern `BLOCK`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(funcdef?{funcdef <- funcdef?} matches pattern (_)))

      4. If ((?() = $find_func_by_name(id, C.BLOCK.FDENV))), then

        1. Return $find_funcdef_by_name((GLOBAL), C, (CURRENT id))

      4. Else Phantom#567 ((p' matches pattern `BLOCK`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(?() = $find_func_by_name(id, C.BLOCK.FDENV)))

    1. Else Phantom#568 ((p' matches pattern `BLOCK`)) /\ (~(name matches pattern `CURRENT%`))

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_funcdef_by_name((BLOCK), C, (CURRENT id))

    1. Else Phantom#569 ((p' matches pattern `LOCAL`)) /\ (~(name matches pattern `CURRENT%`))

;; ../../../../spec/4a1-typing-context.watsup:345.1-346.58
def $find_consdef(p', C, name, arg*{arg <- arg*})

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_func<consdef>(id, $to_fkey(arg*{arg <- arg*}), C.GLOBAL.CDENV)

1. Else Phantom#570 (~(name matches pattern `TOP%`))

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_func<consdef>(id, $to_fkey(arg*{arg <- arg*}), C.GLOBAL.CDENV)

    1. Else Phantom#571 ((p' matches pattern `GLOBAL`)) /\ (~(name matches pattern `CURRENT%`))

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_consdef((GLOBAL), C, (CURRENT id), arg*{arg <- arg*})

    1. Else Phantom#572 ((p' matches pattern `BLOCK`)) /\ (~(name matches pattern `CURRENT%`))

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_consdef((BLOCK), C, (CURRENT id), arg*{arg <- arg*})

    1. Else Phantom#573 ((p' matches pattern `LOCAL`)) /\ (~(name matches pattern `CURRENT%`))

;; ../../../../spec/4a2-typing-tblctx.watsup:6.1-9.11
syntax mode = 
   | `NOPRI`()
   | `NOPRILPM%`(nat)
   | `PRI`()
   | `PRILPM`()

;; ../../../../spec/4a2-typing-tblctx.watsup:12.3-15.24
syntax priority = {`VALUES%`(int*), `INIT%`(bool), `DELTA%`(int), `LARGEST_WINS%`(bool)}

;; ../../../../spec/4a2-typing-tblctx.watsup:18.3-19.17
syntax entry = {`SIZE%`(int), `CONST%`(bool)}

;; ../../../../spec/4a2-typing-tblctx.watsup:24.14-24.30
syntax key = (typ, matchkind)

;; ../../../../spec/4a2-typing-tblctx.watsup:25.17-25.42
syntax action = (name, paramtyp*, argIL*)

;; ../../../../spec/4a2-typing-tblctx.watsup:28.3-32.16
syntax tblctx = {`KEYS%`(key*), `ACTIONS%`(action*), `PRIORITIES%`(priority), `ENTRIES%`(entry), `MODE%`(mode)}

;; ../../../../spec/4a2-typing-tblctx.watsup:39.1-40.10
syntax tblstate = 
   | `LPM%`(nat)
   | `NOLPM`()

;; ../../../../spec/4a2-typing-tblctx.watsup:46.1-46.26
def $empty_pt

1. Return {VALUES [], INIT false, DELTA (1 as int), LARGEST_WINS true}

;; ../../../../spec/4a2-typing-tblctx.watsup:53.1-53.23
def $empty_et

1. Return {SIZE (0 as int), CONST true}

;; ../../../../spec/4a2-typing-tblctx.watsup:58.1-58.28
def $empty_tblctx

1. Return {KEYS [], ACTIONS [], PRIORITIES $empty_pt, ENTRIES $empty_et, MODE (NOPRI)}

;; ../../../../spec/4a2-typing-tblctx.watsup:70.1-70.35
def $add_key(key, tblctx)

1. Return tblctx[KEYS = tblctx.KEYS ++ [key]]

;; ../../../../spec/4a2-typing-tblctx.watsup:74.1-74.41
def $add_action(action, tblctx)

1. Return tblctx[ACTIONS = tblctx.ACTIONS ++ [action]]

;; ../../../../spec/4a2-typing-tblctx.watsup:78.1-78.40
def $add_priority(i, tblctx)

1. Return tblctx[PRIORITIES.VALUES = tblctx.PRIORITIES.VALUES ++ [i]]

;; ../../../../spec/4a2-typing-tblctx.watsup:87.1-87.36
def $get_lpm_prefix(val)

1. Return (LPM $get_lpm_prefix'(val, 0))

;; ../../../../spec/4a2-typing-tblctx.watsup:88.1-88.37
def $get_lpm_prefix'(val, n_prefix')

1. If ((val matches pattern `FBitV%%`)), then

  1. (Let (FBitV nat _bitstr) be val)

  2. If ((nat = 0)), then

    1. Return n_prefix'

  2. Else Phantom#574 ((val matches pattern `FBitV%%`)) /\ (~(nat = 0))

  3. (Let (FBitV w bitstr) be val)

  4. If ((bitstr has type nat)), then

    1. (Let n be (bitstr as nat))

    2. If ((w > 0)), then

      1. If (((n \ 2) =/= 0)), then

        1. (Let val' be (FBitV (w - 1) (((n - 1) / 2) as bitstr)))

        2. Return $get_lpm_prefix'(val', (n_prefix' + 1))

      1. Else Phantom#575 ((val matches pattern `FBitV%%`)) /\ ((bitstr has type nat)) /\ ((w > 0)) /\ (~((n \ 2) =/= 0))

    2. Else Phantom#576 ((val matches pattern `FBitV%%`)) /\ ((bitstr has type nat)) /\ (~(w > 0))

    3. If ((n_prefix' = 0)), then

      1. If ((w > 0)), then

        1. If (((n \ 2) = 0)), then

          1. (Let val' be (FBitV (w - 1) ((n / 2) as bitstr)))

          2. Return $get_lpm_prefix'(val', 0)

        1. Else Phantom#577 ((val matches pattern `FBitV%%`)) /\ ((bitstr has type nat)) /\ ((n_prefix' = 0)) /\ ((w > 0)) /\ (~((n \ 2) = 0))

      1. Else Phantom#578 ((val matches pattern `FBitV%%`)) /\ ((bitstr has type nat)) /\ ((n_prefix' = 0)) /\ (~(w > 0))

    3. Else Phantom#579 ((val matches pattern `FBitV%%`)) /\ ((bitstr has type nat)) /\ (~(n_prefix' = 0))

  4. Else Phantom#580 ((val matches pattern `FBitV%%`)) /\ (~(bitstr has type nat))

1. Else Phantom#581 (~(val matches pattern `FBitV%%`))

;; ../../../../spec/4a2-typing-tblctx.watsup:107.1-107.45
def $update_mode(text', typ', tblctx)

1. Case analysis on text'

  1. Case (% = "lpm")

    1. Case analysis on tblctx.MODE

      1. Case (% matches pattern `NOPRI`)

        1. (Let w be $get_width(typ'))

        2. Return tblctx[MODE = (NOPRILPM w)]

      2. Case (% matches pattern `PRI`)

        1. Return tblctx[MODE = (PRILPM)]

  2. Case (% = "range")

    1. If ((tblctx.MODE matches pattern `NOPRI`)), then

      1. Return tblctx[MODE = (PRI)]

    2. (Let mode be tblctx.MODE)

    3. If ((mode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM _nat) be mode)

      2. Return tblctx[MODE = (PRILPM)]

  3. Case (% = "ternary")

    1. If ((tblctx.MODE matches pattern `NOPRI`)), then

      1. Return tblctx[MODE = (PRI)]

    2. (Let mode be tblctx.MODE)

    3. If ((mode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM _nat) be mode)

      2. Return tblctx[MODE = (PRILPM)]

  4. Case (% = "optional")

    1. If ((tblctx.MODE matches pattern `NOPRI`)), then

      1. Return tblctx[MODE = (PRI)]

    2. (Let mode be tblctx.MODE)

    3. If ((mode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM _nat) be mode)

      2. Return tblctx[MODE = (PRILPM)]

2. Otherwise

  1. Return tblctx

;; ../../../../spec/4a2-typing-tblctx.watsup:129.1-129.49
def $update_state(tblstate, tblstate')

1. Case analysis on tblstate

  1. Case (% matches pattern `NOLPM`)

    1. Case analysis on tblstate'

      1. Case (% matches pattern `LPM%`)

        1. (Let (LPM nat) be tblstate')

        2. Return (LPM nat)

      2. Case (% matches pattern `NOLPM`)

        1. Return (NOLPM)

  2. Case (% matches pattern `LPM%`)

    1. (Let (LPM nat) be tblstate)

    2. If ((tblstate' matches pattern `NOLPM`)), then

      1. Return (LPM nat)

    2. Else Phantom#582 ((tblstate matches pattern `LPM%`)) /\ (~(tblstate' matches pattern `NOLPM`))

;; ../../../../spec/4a2-typing-tblctx.watsup:139.1-139.54
def $find_action(tblctx, name)

1. (Let (name_a, pt_a*{pt_a <- pt_a*}, argIL_a*{argIL_a <- argIL_a*})*{argIL_a* <- argIL_a**, name_a <- name_a*, pt_a* <- pt_a**} be tblctx.ACTIONS)

2. Return $assoc_<name, (paramtyp*, argIL*)>(name, (name_a, (pt_a*{pt_a <- pt_a*}, argIL_a*{argIL_a <- argIL_a*}))*{argIL_a* <- argIL_a**, name_a <- name_a*, pt_a* <- pt_a**})

;; ../../../../spec/4a2-typing-tblctx.watsup:145.1-145.38
def $find_last_priority(tblctx)

1. (Let i_pri*{i_pri <- i_pri*} be tblctx.PRIORITIES.VALUES)

2. Return i_pri*{i_pri <- i_pri*}[(|i_pri*{i_pri <- i_pri*}| - 1)]

;; ../../../../spec/4a2-typing-tblctx.watsup:154.1-154.38
def $keys_of_table(tblprop''*{tblprop'' <- tblprop''*})

1. (Let tblprop be tblprop'')*{tblprop'' <- tblprop''*, tblprop <- tblprop*}

2. If ((tblprop*{tblprop <- tblprop*} matches pattern [])), then

  1. Return []

2. Else Phantom#583 (~(tblprop*{tblprop <- tblprop*} matches pattern []))

3. (Let tblprop' be tblprop'')*{tblprop'' <- tblprop''*, tblprop' <- tblprop'*}

4. If ((tblprop'*{tblprop' <- tblprop'*} matches pattern _ :: _)), then

  1. (Let tblprop :: tblprop_t*{tblprop_t <- tblprop_t*} be tblprop'*{tblprop' <- tblprop'*})

  2. If ((tblprop matches pattern `KeyP%`)), then

    1. (Let (KeyP tblkeyprop) be tblprop)

    2. Return tblkeyprop :: $keys_of_table(tblprop_t*{tblprop_t <- tblprop_t*})

  2. Else Phantom#584 ((tblprop'*{tblprop' <- tblprop'*} matches pattern _ :: _)) /\ (~(tblprop matches pattern `KeyP%`))

4. Else Phantom#585 (~(tblprop'*{tblprop' <- tblprop'*} matches pattern _ :: _))

5. If ((tblprop*{tblprop <- tblprop*} matches pattern _ :: _)), then

  1. (Let tblprop_h :: tblprop_t*{tblprop_t <- tblprop_t*} be tblprop*{tblprop <- tblprop*})

  2. Otherwise

    1. Return $keys_of_table(tblprop_t*{tblprop_t <- tblprop_t*})

5. Else Phantom#586 (~(tblprop*{tblprop <- tblprop*} matches pattern _ :: _))

;; ../../../../spec/4a2-typing-tblctx.watsup:161.1-161.44
def $actions_of_table(tblprop''*{tblprop'' <- tblprop''*})

1. (Let tblprop be tblprop'')*{tblprop'' <- tblprop''*, tblprop <- tblprop*}

2. If ((tblprop*{tblprop <- tblprop*} matches pattern [])), then

  1. Return []

2. Else Phantom#587 (~(tblprop*{tblprop <- tblprop*} matches pattern []))

3. (Let tblprop' be tblprop'')*{tblprop'' <- tblprop''*, tblprop' <- tblprop'*}

4. If ((tblprop'*{tblprop' <- tblprop'*} matches pattern _ :: _)), then

  1. (Let tblprop :: tblprop_t*{tblprop_t <- tblprop_t*} be tblprop'*{tblprop' <- tblprop'*})

  2. If ((tblprop matches pattern `ActionP%`)), then

    1. (Let (ActionP tblactionprop) be tblprop)

    2. Return tblactionprop :: $actions_of_table(tblprop_t*{tblprop_t <- tblprop_t*})

  2. Else Phantom#588 ((tblprop'*{tblprop' <- tblprop'*} matches pattern _ :: _)) /\ (~(tblprop matches pattern `ActionP%`))

4. Else Phantom#589 (~(tblprop'*{tblprop' <- tblprop'*} matches pattern _ :: _))

5. If ((tblprop*{tblprop <- tblprop*} matches pattern _ :: _)), then

  1. (Let tblprop_h :: tblprop_t*{tblprop_t <- tblprop_t*} be tblprop*{tblprop <- tblprop*})

  2. Otherwise

    1. Return $actions_of_table(tblprop_t*{tblprop_t <- tblprop_t*})

5. Else Phantom#590 (~(tblprop*{tblprop <- tblprop*} matches pattern _ :: _))

;; ../../../../spec/4b-typing-relation.watsup:5.1-5.29
def $annot(exprIL)

1. Case analysis on exprIL

  1. Case (% matches pattern `ValueE%%`)

    1. (Let (ValueE _val annotIL) be exprIL)

    2. Return annotIL

  2. Case (% matches pattern `NameE%%`)

    1. (Let (NameE _nameIL annotIL) be exprIL)

    2. Return annotIL

  3. Case (% matches pattern `SeqE%%`)

    1. (Let (SeqE _exprIL*{_exprIL <- _exprIL*} annotIL) be exprIL)

    2. Return annotIL

  4. Case (% matches pattern `SeqDefaultE%%`)

    1. (Let (SeqDefaultE _exprIL*{_exprIL <- _exprIL*} annotIL) be exprIL)

    2. Return annotIL

  5. Case (% matches pattern `RecordE%%`)

    1. (Let (RecordE _(memberIL, exprIL)*{_(memberIL, exprIL) <- _(memberIL, exprIL)*} annotIL) be exprIL)

    2. Return annotIL

  6. Case (% matches pattern `RecordDefaultE%%`)

    1. (Let (RecordDefaultE _(memberIL, exprIL)*{_(memberIL, exprIL) <- _(memberIL, exprIL)*} annotIL) be exprIL)

    2. Return annotIL

  7. Case (% matches pattern `DefaultE%`)

    1. (Let (DefaultE annotIL) be exprIL)

    2. Return annotIL

  8. Case (% matches pattern `UnE%%%`)

    1. (Let (UnE _unopIL _exprIL annotIL) be exprIL)

    2. Return annotIL

  9. Case (% matches pattern `BinE%%%%`)

    1. (Let (BinE _binopIL _exprIL _exprIL' annotIL) be exprIL)

    2. Return annotIL

  10. Case (% matches pattern `TernE%%%%`)

    1. (Let (TernE _exprIL _exprIL' _exprIL'' annotIL) be exprIL)

    2. Return annotIL

  11. Case (% matches pattern `CastE%%%`)

    1. (Let (CastE _typeIL _exprIL annotIL) be exprIL)

    2. Return annotIL

  12. Case (% matches pattern `MaskE%%%`)

    1. (Let (MaskE _exprIL _exprIL' annotIL) be exprIL)

    2. Return annotIL

  13. Case (% matches pattern `RangeE%%%`)

    1. (Let (RangeE _exprIL _exprIL' annotIL) be exprIL)

    2. Return annotIL

  14. Case (% matches pattern `SelectE%%%`)

    1. (Let (SelectE _exprIL*{_exprIL <- _exprIL*} _selectcaseIL*{_selectcaseIL <- _selectcaseIL*} annotIL) be exprIL)

    2. Return annotIL

  15. Case (% matches pattern `ArrAccE%%%`)

    1. (Let (ArrAccE _exprIL _exprIL' annotIL) be exprIL)

    2. Return annotIL

  16. Case (% matches pattern `BitAccE%%%%`)

    1. (Let (BitAccE _exprIL _exprIL' _exprIL'' annotIL) be exprIL)

    2. Return annotIL

  17. Case (% matches pattern `ExprAccE%%%`)

    1. (Let (ExprAccE _exprIL _memberIL annotIL) be exprIL)

    2. Return annotIL

  18. Case (% matches pattern `CallFuncE%%%%`)

    1. (Let (CallFuncE _nameIL _targIL*{_targIL <- _targIL*} _argIL*{_argIL <- _argIL*} annotIL) be exprIL)

    2. Return annotIL

  19. Case (% matches pattern `CallMethodE%%%%%`)

    1. (Let (CallMethodE _exprIL _memberIL _targIL*{_targIL <- _targIL*} _argIL*{_argIL <- _argIL*} annotIL) be exprIL)

    2. Return annotIL

  20. Case (% matches pattern `CallTypeE%%%%%`)

    1. (Let (CallTypeE _nameIL _memberIL _targIL*{_targIL <- _targIL*} _argIL*{_argIL <- _argIL*} annotIL) be exprIL)

    2. Return annotIL

  21. Case (% matches pattern `InstE%%%%`)

    1. (Let (InstE _nameIL _targIL*{_targIL <- _targIL*} _argIL*{_argIL <- _argIL*} annotIL) be exprIL)

    2. Return annotIL

;; ../../../../spec/4b-typing-relation.watsup:34.1-36.23
relation Eval_static: p, C, exprIL''

1. Case analysis on exprIL''

  1. Case (% matches pattern `ValueE%%`)

    1. (Let (ValueE val _annotIL) be exprIL'')

    2. Result in val

  2. Case (% matches pattern `NameE%%`)

    1. (Let (NameE name _annotIL) be exprIL'')

    2. (Let val'?{val' <- val'?} be $find_val(p, C, name))

    3. If ((val'?{val' <- val'?} matches pattern (_))), then

      1. (Let ?(val) be val'?{val' <- val'?})

      2. Result in val

    3. Else Phantom#591 ((exprIL'' matches pattern `NameE%%`)) /\ (~(val'?{val' <- val'?} matches pattern (_)))

  3. Case (% matches pattern `SeqE%%`)

    1. (Let (SeqE exprIL''*{exprIL'' <- exprIL''*} _annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> val)*{exprIL'' <- exprIL''*, val <- val*}

    3. Result in (SeqV val*{val <- val*})

  4. Case (% matches pattern `SeqDefaultE%%`)

    1. (Let (SeqDefaultE exprIL''*{exprIL'' <- exprIL''*} _annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> val)*{exprIL'' <- exprIL''*, val <- val*}

    3. Result in (SeqDefaultV val*{val <- val*})

  5. Case (% matches pattern `RecordE%%`)

    1. (Let (RecordE (member, exprIL'')*{exprIL'' <- exprIL''*, member <- member*} _annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> val)*{exprIL'' <- exprIL''*, val <- val*}

    3. Result in (RecordV (member, val)*{member <- member*, val <- val*})

  6. Case (% matches pattern `RecordDefaultE%%`)

    1. (Let (RecordDefaultE (member, exprIL'')*{exprIL'' <- exprIL''*, member <- member*} _annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> val)*{exprIL'' <- exprIL''*, val <- val*}

    3. Result in (RecordDefaultV (member, val)*{member <- member*, val <- val*})

  7. Case (% matches pattern `DefaultE%`)

    1. (Let (DefaultE _annotIL) be exprIL'')

    2. Result in (DefaultV)

  8. Case (% matches pattern `UnE%%%`)

    1. (Let (UnE unop exprIL'' _annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> val)

    3. Result in $un_op(unop, val)

  9. Case (% matches pattern `BinE%%%%`)

    1. (Let (BinE binop exprIL_l exprIL_r _annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL_l ~> val_l)

    3. (Eval_static: p C |- exprIL_r ~> val_r)

    4. Result in $bin_op(binop, val_l, val_r)

  10. Case (% matches pattern `TernE%%%%`)

    1. (Let (TernE exprIL_c exprIL_t exprIL_f _annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL_c ~> val')

    3. If ((val' = (BoolV true))), then

      1. (Eval_static: p C |- exprIL_t ~> val)

      2. Result in val

    3. Else Phantom#592 ((exprIL'' matches pattern `TernE%%%%`)) /\ (~(val' = (BoolV true)))

    4. If ((val' = (BoolV false))), then

      1. (Eval_static: p C |- exprIL_f ~> val)

      2. Result in val

    4. Else Phantom#593 ((exprIL'' matches pattern `TernE%%%%`)) /\ (~(val' = (BoolV false)))

  11. Case (% matches pattern `CastE%%%`)

    1. (Let (CastE typ exprIL'' _annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> val)

    3. Result in $cast_op(typ, val)

  12. Case (% matches pattern `BitAccE%%%%`)

    1. (Let (BitAccE exprIL_b exprIL_l exprIL_h _annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL_b ~> val_b)

    3. (Eval_static: p C |- exprIL_l ~> val_l)

    4. (Eval_static: p C |- exprIL_h ~> val_h)

    5. Result in $bitacc_op(val_b, val_h, val_l)

  13. Case (% matches pattern `ExprAccE%%%`)

    1. (Let (ExprAccE exprIL_b text _annotIL) be exprIL'')

    2. If ((text = "size")), then

      1. (Eval_static: p C |- exprIL_b ~> val')

      2. If ((val' matches pattern `StackV%%%`)), then

        1. (Let (StackV val*{val <- val*} i_size i_idx) be val')

        2. Result in (IntV i_size)

      2. Else Phantom#594 ((exprIL'' matches pattern `ExprAccE%%%`)) /\ ((text = "size")) /\ (~(val' matches pattern `StackV%%%`))

    2. Else Phantom#595 ((exprIL'' matches pattern `ExprAccE%%%`)) /\ (~(text = "size"))

  14. Case (% matches pattern `CallMethodE%%%%%`)

    1. (Let (CallMethodE exprIL_b member targIL*{targIL <- targIL*} argIL*{argIL <- argIL*} _annotIL) be exprIL'')

    2. If ((targIL*{targIL <- targIL*} matches pattern [])), then

      1. If ((argIL*{argIL <- argIL*} matches pattern [])), then

        1. If (((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes"))), then

          1. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

          2. (Let val be $size(typ_b, member))

          3. Result in val

        1. Else Phantom#596 ((exprIL'' matches pattern `CallMethodE%%%%%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((argIL*{argIL <- argIL*} matches pattern [])) /\ (~((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes")))

      1. Else Phantom#597 ((exprIL'' matches pattern `CallMethodE%%%%%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(argIL*{argIL <- argIL*} matches pattern []))

    2. Else Phantom#598 ((exprIL'' matches pattern `CallMethodE%%%%%`)) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

  15. Case (% matches pattern `CallTypeE%%%%%`)

    1. (Let (CallTypeE name member targIL*{targIL <- targIL*} argIL*{argIL <- argIL*} _annotIL) be exprIL'')

    2. If ((targIL*{targIL <- targIL*} matches pattern [])), then

      1. If ((argIL*{argIL <- argIL*} matches pattern [])), then

        1. If (((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes"))), then

          1. (Let typdef'?{typdef' <- typdef'?} be $find_typdef(p, C, name))

          2. If ((typdef'?{typdef' <- typdef'?} matches pattern (_))), then

            1. (Let ?(typdef) be typdef'?{typdef' <- typdef'?})

            2. If ((typdef has type monotypdef)), then

              1. (Let (MonoD typ) be (typdef as monotypdef))

              2. Result in $size(typ, member)

            2. Else Phantom#599 ((exprIL'' matches pattern `CallTypeE%%%%%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((argIL*{argIL <- argIL*} matches pattern [])) /\ (((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes"))) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ (~(typdef has type monotypdef))

          2. Else Phantom#600 ((exprIL'' matches pattern `CallTypeE%%%%%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((argIL*{argIL <- argIL*} matches pattern [])) /\ (((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes"))) /\ (~(typdef'?{typdef' <- typdef'?} matches pattern (_)))

        1. Else Phantom#601 ((exprIL'' matches pattern `CallTypeE%%%%%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((argIL*{argIL <- argIL*} matches pattern [])) /\ (~((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes")))

      1. Else Phantom#602 ((exprIL'' matches pattern `CallTypeE%%%%%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(argIL*{argIL <- argIL*} matches pattern []))

    2. Else Phantom#603 ((exprIL'' matches pattern `CallTypeE%%%%%`)) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

1. Else Phantom#604 (~(exprIL'' matches pattern `ValueE%%`)) /\ (~(exprIL'' matches pattern `NameE%%`)) /\ (~(exprIL'' matches pattern `SeqE%%`)) /\ (~(exprIL'' matches pattern `SeqDefaultE%%`)) /\ (~(exprIL'' matches pattern `RecordE%%`)) /\ (~(exprIL'' matches pattern `RecordDefaultE%%`)) /\ (~(exprIL'' matches pattern `DefaultE%`)) /\ (~(exprIL'' matches pattern `UnE%%%`)) /\ (~(exprIL'' matches pattern `BinE%%%%`)) /\ (~(exprIL'' matches pattern `TernE%%%%`)) /\ (~(exprIL'' matches pattern `CastE%%%`)) /\ (~(exprIL'' matches pattern `BitAccE%%%%`)) /\ (~(exprIL'' matches pattern `ExprAccE%%%`)) /\ (~(exprIL'' matches pattern `CallMethodE%%%%%`)) /\ (~(exprIL'' matches pattern `CallTypeE%%%%%`))

;; ../../../../spec/4b-typing-relation.watsup:43.1-45.23
relation Type_ok: p, C, type''

1. Case analysis on type''

  1. Case (% matches pattern `VoidT`)

    1. Result in ((VoidT) as typ), []

  2. Case (% matches pattern `ErrT`)

    1. Result in ((ErrT) as typ), []

  3. Case (% matches pattern `MatchKindT`)

    1. Result in ((MatchKindT) as typ), []

  4. Case (% matches pattern `StrT`)

    1. Result in ((StrT) as typ), []

  5. Case (% matches pattern `BoolT`)

    1. Result in ((BoolT) as typ), []

  6. Case (% matches pattern `IntT`)

    1. Result in ((IntT) as typ), []

  7. Case (% matches pattern `FIntT%`)

    1. (Let (FIntT expr) be type'')

    2. (Expr_ok: p C |- expr : exprIL)

    3. (Let (( _typ ; ctk )) be $annot(exprIL))

    4. If ((ctk matches pattern `LCTK`)), then

      1. (Eval_static: p C |- exprIL ~> val)

      2. (Let int be $get_num(val))

      3. If ((int has type nat)), then

        1. (Let w be (int as nat))

        2. Result in ((FIntT w) as typ), []

      3. Else Phantom#605 ((type'' matches pattern `FIntT%`)) /\ ((ctk matches pattern `LCTK`)) /\ (~(int has type nat))

    4. Else Phantom#606 ((type'' matches pattern `FIntT%`)) /\ (~(ctk matches pattern `LCTK`))

  8. Case (% matches pattern `FBitT%`)

    1. (Let (FBitT expr) be type'')

    2. (Expr_ok: p C |- expr : exprIL)

    3. (Let (( _typ ; ctk )) be $annot(exprIL))

    4. If ((ctk matches pattern `LCTK`)), then

      1. (Eval_static: p C |- exprIL ~> val)

      2. (Let int be $get_num(val))

      3. If ((int has type nat)), then

        1. (Let w be (int as nat))

        2. Result in ((FBitT w) as typ), []

      3. Else Phantom#607 ((type'' matches pattern `FBitT%`)) /\ ((ctk matches pattern `LCTK`)) /\ (~(int has type nat))

    4. Else Phantom#608 ((type'' matches pattern `FBitT%`)) /\ (~(ctk matches pattern `LCTK`))

  9. Case (% matches pattern `VBitT%`)

    1. (Let (VBitT expr) be type'')

    2. (Expr_ok: p C |- expr : exprIL)

    3. (Let (( _typ ; ctk )) be $annot(exprIL))

    4. If ((ctk matches pattern `LCTK`)), then

      1. (Eval_static: p C |- exprIL ~> val)

      2. (Let int be $get_num(val))

      3. If ((int has type nat)), then

        1. (Let w be (int as nat))

        2. Result in ((VBitT w) as typ), []

      3. Else Phantom#609 ((type'' matches pattern `VBitT%`)) /\ ((ctk matches pattern `LCTK`)) /\ (~(int has type nat))

    4. Else Phantom#610 ((type'' matches pattern `VBitT%`)) /\ (~(ctk matches pattern `LCTK`))

  10. Case (% matches pattern `StackT%%`)

    1. (Let (StackT type'' expr) be type'')

    2. (Type_ok: p C |- type'' : typ tid_fresh*{tid_fresh <- tid_fresh*})

    3. (Expr_ok: p C |- expr : exprIL)

    4. (Let (( _typ ; ctk )) be $annot(exprIL))

    5. If ((ctk matches pattern `LCTK`)), then

      1. (Eval_static: p C |- exprIL ~> val)

      2. (Let i_size be $get_num(val))

      3. (Let ptd be (PolyD (["T"], []) -> ((StackT ((VarT "T") as typ) i_size) as typ)))

      4. Result in ((SpecT ptd [typ]) as typ), tid_fresh*{tid_fresh <- tid_fresh*}

    5. Else Phantom#611 ((type'' matches pattern `StackT%%`)) /\ (~(ctk matches pattern `LCTK`))

  11. Case (% matches pattern `ListT%`)

    1. (Let (ListT type'') be type'')

    2. (Type_ok: p C |- type'' : typ tid_fresh*{tid_fresh <- tid_fresh*})

    3. (Let ptd be (PolyD (["T"], []) -> ((ListT ((VarT "T") as typ)) as typ)))

    4. Result in ((SpecT ptd [typ]) as typ), tid_fresh*{tid_fresh <- tid_fresh*}

  12. Case (% matches pattern `TupleT%`)

    1. (Let (TupleT type''*{type'' <- type''*}) be type'')

    2. (Type_ok: p C |- type'' : typ tid_fresh_i*{tid_fresh_i <- tid_fresh_i*})*{tid_fresh_i* <- tid_fresh_i**, typ <- typ*, type'' <- type''*}

    3. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $concat_<tid>(tid_fresh_i*{tid_fresh_i <- tid_fresh_i*}*{tid_fresh_i* <- tid_fresh_i**}))

    4. (Let i_idx*{i_idx <- i_idx*} be ($init_(|typ*{typ <- typ*}|) as int*))

    5. (Let tid be $concat_text(["T", $int_to_text(i_idx)]))*{i_idx <- i_idx*, tid <- tid*}

    6. (Let ptd be (PolyD (tid*{tid <- tid*}, []) -> ((TupleT ((VarT tid) as typ)*{tid <- tid*}) as typ)))

    7. Result in ((SpecT ptd typ*{typ <- typ*}) as typ), tid_fresh*{tid_fresh <- tid_fresh*}

  13. Case (% matches pattern `NameT%`)

    1. (Let (NameT name) be type'')

    2. (Let typdef'?{typdef' <- typdef'?} be $find_typdef(p, C, name))

    3. If ((typdef'?{typdef' <- typdef'?} matches pattern (_))), then

      1. (Let ?(typdef) be typdef'?{typdef' <- typdef'?})

      2. Case analysis on typdef

        1. Case (% has type monotypdef)

          1. (Let (MonoD typ) be (typdef as monotypdef))

          2. Result in typ, []

        2. Case (% has type polytypdef)

          1. (Let (PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ) be (typdef as polytypdef))

          2. (Let ptd be (PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ))

          3. Result in ((SpecT ptd []) as typ), []

    3. Else Phantom#612 ((type'' matches pattern `NameT%`)) /\ (~(typdef'?{typdef' <- typdef'?} matches pattern (_)))

  14. Case (% matches pattern `SpecT%%`)

    1. (Let (SpecT name type''*{type'' <- type''*}) be type'')

    2. If ((type''*{type'' <- type''*} matches pattern [])), then

      1. (Let typdef'?{typdef' <- typdef'?} be $find_typdef(p, C, name))

      2. If ((typdef'?{typdef' <- typdef'?} matches pattern (_))), then

        1. (Let ?(typdef) be typdef'?{typdef' <- typdef'?})

        2. If ((typdef has type monotypdef)), then

          1. (Let (MonoD typ) be (typdef as monotypdef))

          2. Result in typ, []

        2. Else Phantom#613 ((type'' matches pattern `SpecT%%`)) /\ ((type''*{type'' <- type''*} matches pattern [])) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ (~(typdef has type monotypdef))

      2. Else Phantom#614 ((type'' matches pattern `SpecT%%`)) /\ ((type''*{type'' <- type''*} matches pattern [])) /\ (~(typdef'?{typdef' <- typdef'?} matches pattern (_)))

    2. Else Phantom#615 ((type'' matches pattern `SpecT%%`)) /\ (~(type''*{type'' <- type''*} matches pattern []))

    3. (Let typdef'?{typdef' <- typdef'?} be $find_typdef(p, C, name))

    4. If ((typdef'?{typdef' <- typdef'?} matches pattern (_))), then

      1. (Let ?(typdef) be typdef'?{typdef' <- typdef'?})

      2. If ((typdef has type polytypdef)), then

        1. (Let ptd be (typdef as polytypdef))

        2. (Let (PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ) be ptd)

        3. (Type_ok: p C |- type'' : typ_a tid_fresh_a*{tid_fresh_a <- tid_fresh_a*})*{tid_fresh_a* <- tid_fresh_a**, typ_a <- typ_a*, type'' <- type''*}

        4. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**}))

        5. Result in ((SpecT ptd typ_a*{typ_a <- typ_a*}) as typ), tid_fresh*{tid_fresh <- tid_fresh*}

      2. Else Phantom#616 ((type'' matches pattern `SpecT%%`)) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ (~(typdef has type polytypdef))

    4. Else Phantom#617 ((type'' matches pattern `SpecT%%`)) /\ (~(typdef'?{typdef' <- typdef'?} matches pattern (_)))

  15. Case (% matches pattern `AnyT`)

    1. (Let tid be $fresh_tid)

    2. Result in ((VarT tid) as typ), [tid]

;; ../../../../spec/4b-typing-relation.watsup:48.1-50.20
relation Sub_expl: typ_a, typ_b

1. If ((Sub_expl_canon: $canon_typ(typ_a) <: $canon_typ(typ_b) holds)), then

  1. The relation holds

1. Else Phantom#618 (~(Sub_expl_canon: $canon_typ(typ_a) <: $canon_typ(typ_b) holds))

;; ../../../../spec/4b-typing-relation.watsup:51.1-53.20
relation Sub_expl_canon: typ_a, typ_b

1. Case analysis on (Type_alpha: typ_a ~~ typ_b holds)

  1. Case true

    1. The relation holds

  2. Case false

    1. If ((Sub_expl_canon_neq: typ_a <: typ_b holds)), then

      1. The relation holds

    1. Else Phantom#619 (~(Type_alpha: typ_a ~~ typ_b holds)) /\ (~(Sub_expl_canon_neq: typ_a <: typ_b holds))

;; ../../../../spec/4b-typing-relation.watsup:54.1-56.20
relation Sub_expl_canon_neq: typ''''', typ''''''

1. If ((typ''''' = ((FBitT 1) as typ))), then

  1. If ((typ'''''' = ((BoolT) as typ))), then

    1. The relation holds

  1. Else Phantom#620 ((typ''''' = ((FBitT 1) as typ))) /\ (~(typ'''''' = ((BoolT) as typ)))

1. Else Phantom#621 (~(typ''''' = ((FBitT 1) as typ)))

2. If ((typ''''' = ((BoolT) as typ))), then

  1. If ((typ'''''' = ((FBitT 1) as typ))), then

    1. The relation holds

  1. Else Phantom#622 ((typ''''' = ((BoolT) as typ))) /\ (~(typ'''''' = ((FBitT 1) as typ)))

2. Else Phantom#623 (~(typ''''' = ((BoolT) as typ)))

3. If ((typ''''' = ((IntT) as typ))), then

  1. If ((typ'''''' = ((BoolT) as typ))), then

    1. The relation holds

  1. Else Phantom#624 ((typ''''' = ((IntT) as typ))) /\ (~(typ'''''' = ((BoolT) as typ)))

  2. If ((typ'''''' has type numtyp)), then

    1. (Let numtyp be (typ'''''' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT width) be numtyp)

        2. The relation holds

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT width) be numtyp)

        2. The relation holds

    2. Else Phantom#625 ((typ''''' = ((IntT) as typ))) /\ ((typ'''''' has type numtyp)) /\ (~(numtyp matches pattern `FBitT%`)) /\ (~(numtyp matches pattern `FIntT%`))

  2. Else Phantom#626 ((typ''''' = ((IntT) as typ))) /\ (~(typ'''''' has type numtyp))

3. Else Phantom#627 (~(typ''''' = ((IntT) as typ)))

4. Case analysis on typ'''''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ''''' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT width_a) be numtyp)

        2. If ((typ'''''' has type numtyp)), then

          1. (Let numtyp' be (typ'''''' as numtyp))

          2. Case analysis on numtyp'

            1. Case (% matches pattern `FBitT%`)

              1. (Let (FBitT width_b) be numtyp')

              2. The relation holds

            2. Case (% matches pattern `FIntT%`)

              1. (Let (FIntT width_b) be numtyp')

              2. The relation holds

          2. Else Phantom#628 ((typ''''' has type numtyp)) /\ ((numtyp matches pattern `FIntT%`)) /\ ((typ'''''' has type numtyp)) /\ (~(numtyp' matches pattern `FBitT%`)) /\ (~(numtyp' matches pattern `FIntT%`))

        2. Else Phantom#629 ((typ''''' has type numtyp)) /\ ((numtyp matches pattern `FIntT%`)) /\ (~(typ'''''' has type numtyp))

        3. (Let (FIntT width) be numtyp)

        4. If ((typ'''''' = ((IntT) as typ))), then

          1. The relation holds

        4. Else Phantom#630 ((typ''''' has type numtyp)) /\ ((numtyp matches pattern `FIntT%`)) /\ (~(typ'''''' = ((IntT) as typ)))

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT width_a) be numtyp)

        2. If ((typ'''''' has type numtyp)), then

          1. (Let numtyp' be (typ'''''' as numtyp))

          2. Case analysis on numtyp'

            1. Case (% matches pattern `FIntT%`)

              1. (Let (FIntT width_b) be numtyp')

              2. The relation holds

            2. Case (% matches pattern `FBitT%`)

              1. (Let (FBitT width_b) be numtyp')

              2. The relation holds

          2. Else Phantom#631 ((typ''''' has type numtyp)) /\ ((numtyp matches pattern `FBitT%`)) /\ ((typ'''''' has type numtyp)) /\ (~(numtyp' matches pattern `FIntT%`)) /\ (~(numtyp' matches pattern `FBitT%`))

        2. Else Phantom#632 ((typ''''' has type numtyp)) /\ ((numtyp matches pattern `FBitT%`)) /\ (~(typ'''''' has type numtyp))

        3. (Let (FBitT width) be numtyp)

        4. If ((typ'''''' = ((IntT) as typ))), then

          1. The relation holds

        4. Else Phantom#633 ((typ''''' has type numtyp)) /\ ((numtyp matches pattern `FBitT%`)) /\ (~(typ'''''' = ((IntT) as typ)))

    2. Else Phantom#634 ((typ''''' has type numtyp)) /\ (~(numtyp matches pattern `FIntT%`)) /\ (~(numtyp matches pattern `FBitT%`))

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ_a) be datatyp)

        2. If ((Sub_impl: typ_a << typ'''''' holds)), then

          1. The relation holds

        2. Else Phantom#635 ((typ''''' has type datatyp)) /\ ((datatyp matches pattern `NewT%%`)) /\ (~(Sub_impl: typ_a << typ'''''' holds))

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ''''' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. If ((Sub_impl: typ''''' << typ'''''' holds)), then

          1. The relation holds

        2. Else Phantom#636 ((typ''''' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ (~(Sub_impl: typ''''' << typ'''''' holds))

    2. Else Phantom#637 ((typ''''' has type datatyp)) /\ (~(datatyp matches pattern `NewT%%`)) /\ (~(datatyp matches pattern `SEnumT%%%`))

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ''''' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ'''''*{typ''''' <- typ'''''*}) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `ListT%`)

              1. (Let (ListT typ'''''') be datatyp)

              2. If ((Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*}, then

                1. The relation holds

              2. Else Phantom#638 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `ListT%`)) /\ (exists ~(Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*}

            2. Case (% matches pattern `TupleT%`)

              1. (Let (TupleT typ''''''*{typ'''''' <- typ''''''*}) be datatyp)

              2. If ((Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*, typ'''''' <- typ''''''*}, then

                1. The relation holds

              2. Else Phantom#639 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ (exists ~(Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*, typ'''''' <- typ''''''*}

            3. Case (% matches pattern `StackT%%`)

              1. (Let (StackT typ'''''' i_size) be datatyp)

              2. If (((|typ'''''*{typ''''' <- typ'''''*}| as int) <= i_size)), then

                1. If ((Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*}, then

                  1. The relation holds

                1. Else Phantom#640 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (((|typ'''''*{typ''''' <- typ'''''*}| as int) <= i_size)) /\ (exists ~(Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*}

              2. Else Phantom#641 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~((|typ'''''*{typ''''' <- typ'''''*}| as int) <= i_size))

            4. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (_member, typ'''''')*{_member <- _member*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ((Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*, typ'''''' <- typ''''''*}, then

                1. The relation holds

              2. Else Phantom#642 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (exists ~(Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*, typ'''''' <- typ''''''*}

            5. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (_member, typ'''''')*{_member <- _member*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ((Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*, typ'''''' <- typ''''''*}, then

                1. The relation holds

              2. Else Phantom#643 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (exists ~(Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*, typ'''''' <- typ''''''*}

          2. Else Phantom#644 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `ListT%`)) /\ (~(datatyp matches pattern `TupleT%`)) /\ (~(datatyp matches pattern `StackT%%`)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

        2. Else Phantom#645 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ (~(typ'''''' has type datatyp))

      2. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member_a, typ''''')*{member_a <- member_a*, typ''''' <- typ'''''*}) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (member_b, typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))), then

                1. (Let typ''?{typ'' <- typ''?} be $find_map<member, typ>(({ (member_a -> typ''''')*{member_a <- member_a*, typ''''' <- typ'''''*} }), member_a))*{member_a <- member_a*, typ''? <- typ''?*}

                2. If ((typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}, then

                  1. (Let ?(typ_a') be typ''?{typ'' <- typ''?})*{typ''? <- typ''?*, typ_a' <- typ_a'*}

                  2. (Let typ'''?{typ''' <- typ'''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ'''? <- typ'''?*}

                  3. If ((typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}, then

                    1. (Let ?(typ_b') be typ'''?{typ''' <- typ'''?})*{typ'''? <- typ'''?*, typ_b' <- typ_b'*}

                    2. If ((Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}, then

                      1. The relation holds

                    2. Else Phantom#646 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (exists ~(Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}

                  3. Else Phantom#647 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (exists ~(typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}

                2. Else Phantom#648 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (exists ~(typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}

              2. Else Phantom#649 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~$eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} })))

            2. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (member_b, typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))), then

                1. (Let typ''?{typ'' <- typ''?} be $find_map<member, typ>(({ (member_a -> typ''''')*{member_a <- member_a*, typ''''' <- typ'''''*} }), member_a))*{member_a <- member_a*, typ''? <- typ''?*}

                2. If ((typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}, then

                  1. (Let ?(typ_a') be typ''?{typ'' <- typ''?})*{typ''? <- typ''?*, typ_a' <- typ_a'*}

                  2. (Let typ'''?{typ''' <- typ'''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ'''? <- typ'''?*}

                  3. If ((typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}, then

                    1. (Let ?(typ_b') be typ'''?{typ''' <- typ'''?})*{typ'''? <- typ'''?*, typ_b' <- typ_b'*}

                    2. If ((Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}, then

                      1. The relation holds

                    2. Else Phantom#650 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (exists ~(Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}

                  3. Else Phantom#651 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (exists ~(typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}

                2. Else Phantom#652 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (exists ~(typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}

              2. Else Phantom#653 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~$eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} })))

          2. Else Phantom#654 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

        2. Else Phantom#655 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ (~(typ'''''' has type datatyp))

      3. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ'''''*{typ''''' <- typ'''''*}) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `TupleT%`)

              1. (Let (TupleT typ''''''*{typ'''''' <- typ''''''*}) be datatyp)

              2. If ((|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|)), then

                1. (Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) be $partition_<typ>(typ''''''*{typ'''''' <- typ''''''*}, |typ'''''*{typ''''' <- typ'''''*}|))

                2. If ((Sub_expl: typ''''' <: typ_c holds))*{typ''''' <- typ'''''*, typ_c <- typ_c*}, then

                  1. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then

                    1. The relation holds

                  1. Else Phantom#656 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ ((|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (forall (Sub_expl: typ''''' <: typ_c holds))*{typ''''' <- typ'''''*, typ_c <- typ_c*} /\ (exists ~$is_deftable(typ_d))*{typ_d <- typ_d*}

                2. Else Phantom#657 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ ((|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (exists ~(Sub_expl: typ''''' <: typ_c holds))*{typ''''' <- typ'''''*, typ_c <- typ_c*}

              2. Else Phantom#658 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ (~(|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|))

            2. Case (% matches pattern `StackT%%`)

              1. (Let (StackT typ'''''' i_size) be datatyp)

              2. If (((|typ'''''*{typ''''' <- typ'''''*}| as int) < i_size)), then

                1. If ((Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*}, then

                  1. If ($is_deftable(typ'''''')), then

                    1. The relation holds

                  1. Else Phantom#659 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (((|typ'''''*{typ''''' <- typ'''''*}| as int) < i_size)) /\ (forall (Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*} /\ (~$is_deftable(typ''''''))

                1. Else Phantom#660 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (((|typ'''''*{typ''''' <- typ'''''*}| as int) < i_size)) /\ (exists ~(Sub_expl: typ''''' <: typ'''''' holds))*{typ''''' <- typ'''''*}

              2. Else Phantom#661 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~((|typ'''''*{typ''''' <- typ'''''*}| as int) < i_size))

            3. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (_member, typ'''''')*{_member <- _member*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ((|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|)), then

                1. (Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) be $partition_<typ>(typ''''''*{typ'''''' <- typ''''''*}, |typ'''''*{typ''''' <- typ'''''*}|))

                2. If ((Sub_expl: typ''''' <: typ_c holds))*{typ''''' <- typ'''''*, typ_c <- typ_c*}, then

                  1. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then

                    1. The relation holds

                  1. Else Phantom#662 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ((|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (forall (Sub_expl: typ''''' <: typ_c holds))*{typ''''' <- typ'''''*, typ_c <- typ_c*} /\ (exists ~$is_deftable(typ_d))*{typ_d <- typ_d*}

                2. Else Phantom#663 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ((|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (exists ~(Sub_expl: typ''''' <: typ_c holds))*{typ''''' <- typ'''''*, typ_c <- typ_c*}

              2. Else Phantom#664 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~(|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|))

            4. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (_member, typ'''''')*{_member <- _member*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ((|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|)), then

                1. (Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) be $partition_<typ>(typ''''''*{typ'''''' <- typ''''''*}, |typ'''''*{typ''''' <- typ'''''*}|))

                2. If ((Sub_expl: typ''''' <: typ_c holds))*{typ''''' <- typ'''''*, typ_c <- typ_c*}, then

                  1. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then

                    1. The relation holds

                  1. Else Phantom#665 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ((|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (forall (Sub_expl: typ''''' <: typ_c holds))*{typ''''' <- typ'''''*, typ_c <- typ_c*} /\ (exists ~$is_deftable(typ_d))*{typ_d <- typ_d*}

                2. Else Phantom#666 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ((|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (exists ~(Sub_expl: typ''''' <: typ_c holds))*{typ''''' <- typ'''''*, typ_c <- typ_c*}

              2. Else Phantom#667 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~(|typ'''''*{typ''''' <- typ'''''*}| < |typ''''''*{typ'''''' <- typ''''''*}|))

          2. Else Phantom#668 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `TupleT%`)) /\ (~(datatyp matches pattern `StackT%%`)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

        2. Else Phantom#669 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ (~(typ'''''' has type datatyp))

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member_a, typ''''')*{member_a <- member_a*, typ''''' <- typ'''''*}) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (member_b, typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))), then

                1. (Let ({ member_c*{member_c <- member_c*} }) be $diff_set<member>(({ member_b*{member_b <- member_b*} }), ({ member_a*{member_a <- member_a*} })))

                2. (Let typ''?{typ'' <- typ''?} be $find_map<member, typ>(({ (member_a -> typ''''')*{member_a <- member_a*, typ''''' <- typ'''''*} }), member_a))*{member_a <- member_a*, typ''? <- typ''?*}

                3. If ((typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}, then

                  1. (Let ?(typ_a') be typ''?{typ'' <- typ''?})*{typ''? <- typ''?*, typ_a' <- typ_a'*}

                  2. (Let typ'''?{typ''' <- typ'''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ'''? <- typ'''?*}

                  3. If ((typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}, then

                    1. (Let ?(typ_b') be typ'''?{typ''' <- typ'''?})*{typ'''? <- typ'''?*, typ_b' <- typ_b'*}

                    2. If ((Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}, then

                      1. (Let typ''''?{typ'''' <- typ''''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ''''? <- typ''''?*}

                      2. If ((typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*}, then

                        1. (Let ?(typ_c') be typ''''?{typ'''' <- typ''''?})*{typ''''? <- typ''''?*, typ_c' <- typ_c'*}

                        2. If ($is_deftable(typ_c'))*{typ_c' <- typ_c'*}, then

                          1. The relation holds

                        2. Else Phantom#670 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (forall (Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*} /\ (forall (typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*} /\ (exists ~$is_deftable(typ_c'))*{typ_c' <- typ_c'*}

                      2. Else Phantom#671 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (forall (Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*} /\ (exists ~(typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*}

                    2. Else Phantom#672 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (exists ~(Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}

                  3. Else Phantom#673 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (exists ~(typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}

                3. Else Phantom#674 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (exists ~(typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}

              2. Else Phantom#675 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~$sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} })))

            2. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (member_b, typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))), then

                1. (Let ({ member_c*{member_c <- member_c*} }) be $diff_set<member>(({ member_b*{member_b <- member_b*} }), ({ member_a*{member_a <- member_a*} })))

                2. (Let typ''?{typ'' <- typ''?} be $find_map<member, typ>(({ (member_a -> typ''''')*{member_a <- member_a*, typ''''' <- typ'''''*} }), member_a))*{member_a <- member_a*, typ''? <- typ''?*}

                3. If ((typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}, then

                  1. (Let ?(typ_a') be typ''?{typ'' <- typ''?})*{typ''? <- typ''?*, typ_a' <- typ_a'*}

                  2. (Let typ'''?{typ''' <- typ'''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ'''? <- typ'''?*}

                  3. If ((typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}, then

                    1. (Let ?(typ_b') be typ'''?{typ''' <- typ'''?})*{typ'''? <- typ'''?*, typ_b' <- typ_b'*}

                    2. If ((Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}, then

                      1. (Let typ''''?{typ'''' <- typ''''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ''''? <- typ''''?*}

                      2. If ((typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*}, then

                        1. (Let ?(typ_c') be typ''''?{typ'''' <- typ''''?})*{typ''''? <- typ''''?*, typ_c' <- typ_c'*}

                        2. If ($is_deftable(typ_c'))*{typ_c' <- typ_c'*}, then

                          1. The relation holds

                        2. Else Phantom#676 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (forall (Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*} /\ (forall (typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*} /\ (exists ~$is_deftable(typ_c'))*{typ_c' <- typ_c'*}

                      2. Else Phantom#677 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (forall (Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*} /\ (exists ~(typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*}

                    2. Else Phantom#678 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (exists ~(Sub_expl: typ_a' <: typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}

                  3. Else Phantom#679 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (exists ~(typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}

                3. Else Phantom#680 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (exists ~(typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}

              2. Else Phantom#681 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~$sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} })))

          2. Else Phantom#682 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

        2. Else Phantom#683 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ (~(typ'''''' has type datatyp))

      5. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ''''') be synthtyp)

        2. If ((typ'''''' has type synthtyp)), then

          1. (Let synthtyp' be (typ'''''' as synthtyp))

          2. If ((synthtyp' matches pattern `SetT%`)), then

            1. (Let (SetT typ'''''') be synthtyp')

            2. If ((Sub_expl: typ''''' <: typ'''''' holds)), then

              1. The relation holds

            2. Else Phantom#684 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ ((typ'''''' has type synthtyp)) /\ ((synthtyp' matches pattern `SetT%`)) /\ (~(Sub_expl: typ''''' <: typ'''''' holds))

          2. Else Phantom#685 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ ((typ'''''' has type synthtyp)) /\ (~(synthtyp' matches pattern `SetT%`))

        2. Else Phantom#686 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ (~(typ'''''' has type synthtyp))

    2. Else Phantom#687 ((typ''''' has type synthtyp)) /\ (~(synthtyp matches pattern `SeqT%`)) /\ (~(synthtyp matches pattern `RecordT%`)) /\ (~(synthtyp matches pattern `SeqDefaultT%`)) /\ (~(synthtyp matches pattern `RecordDefaultT%`)) /\ (~(synthtyp matches pattern `SetT%`))

4. Else Phantom#688 (~(typ''''' has type numtyp)) /\ (~(typ''''' has type datatyp)) /\ (~(typ''''' has type synthtyp))

5. Case analysis on typ''''''

  1. Case (% has type datatyp)

    1. (Let datatyp be (typ'''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'''''') be datatyp)

        2. If ((Sub_impl: typ''''' << typ'''''' holds)), then

          1. The relation holds

        2. Else Phantom#689 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `NewT%%`)) /\ (~(Sub_impl: typ''''' << typ'''''' holds))

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'''''' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

        2. If ((Sub_impl: typ''''' << typ'''''' holds)), then

          1. The relation holds

        2. Else Phantom#690 ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ (~(Sub_impl: typ''''' << typ'''''' holds))

    2. Else Phantom#691 ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `NewT%%`)) /\ (~(datatyp matches pattern `SEnumT%%%`))

  2. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'''''' as synthtyp))

    2. If ((synthtyp matches pattern `SetT%`)), then

      1. (Let (SetT typ'''''') be synthtyp)

      2. If ((Sub_expl: typ''''' <: typ'''''' holds)), then

        1. The relation holds

      2. Else Phantom#692 ((typ'''''' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ (~(Sub_expl: typ''''' <: typ'''''' holds))

    2. Else Phantom#693 ((typ'''''' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

5. Else Phantom#694 (~(typ'''''' has type datatyp)) /\ (~(typ'''''' has type synthtyp))

6. If ((typ''''' = ((DefaultT) as typ))), then

  1. If ($is_deftable(typ'''''')), then

    1. The relation holds

  1. Else Phantom#695 ((typ''''' = ((DefaultT) as typ))) /\ (~$is_deftable(typ''''''))

6. Else Phantom#696 (~(typ''''' = ((DefaultT) as typ)))

7. If ((typ''''' = ((InvalidT) as typ))), then

  1. If ((typ'''''' has type datatyp)), then

    1. (Let datatyp be (typ'''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. The relation holds

      2. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. The relation holds

    2. Else Phantom#697 ((typ''''' = ((InvalidT) as typ))) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `HeaderT%%`)) /\ (~(datatyp matches pattern `UnionT%%`))

  1. Else Phantom#698 ((typ''''' = ((InvalidT) as typ))) /\ (~(typ'''''' has type datatyp))

7. Else Phantom#699 (~(typ''''' = ((InvalidT) as typ)))

;; ../../../../spec/4b-typing-relation.watsup:57.1-59.20
relation Sub_impl: typ_a, typ_b

1. If ((Sub_impl_canon: $canon_typ(typ_a) << $canon_typ(typ_b) holds)), then

  1. The relation holds

1. Else Phantom#700 (~(Sub_impl_canon: $canon_typ(typ_a) << $canon_typ(typ_b) holds))

;; ../../../../spec/4b-typing-relation.watsup:60.1-62.20
relation Sub_impl_canon: typ_a, typ_b

1. Case analysis on (Type_alpha: typ_a ~~ typ_b holds)

  1. Case true

    1. The relation holds

  2. Case false

    1. If ((Sub_impl_canon_neq: typ_a << typ_b holds)), then

      1. The relation holds

    1. Else Phantom#701 (~(Type_alpha: typ_a ~~ typ_b holds)) /\ (~(Sub_impl_canon_neq: typ_a << typ_b holds))

;; ../../../../spec/4b-typing-relation.watsup:63.1-65.20
relation Sub_impl_canon_neq: typ''''', typ''''''

1. If ((typ''''' = ((IntT) as typ))), then

  1. If ((typ'''''' has type numtyp)), then

    1. (Let numtyp be (typ'''''' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. The relation holds

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. The relation holds

    2. Else Phantom#702 ((typ''''' = ((IntT) as typ))) /\ ((typ'''''' has type numtyp)) /\ (~(numtyp matches pattern `FBitT%`)) /\ (~(numtyp matches pattern `FIntT%`))

  1. Else Phantom#703 ((typ''''' = ((IntT) as typ))) /\ (~(typ'''''' has type numtyp))

1. Else Phantom#704 (~(typ''''' = ((IntT) as typ)))

2. Case analysis on typ'''''

  1. Case (% has type datatyp)

    1. (Let datatyp be (typ''''' as datatyp))

    2. If ((datatyp matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _id typ_a _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

      2. If ((Sub_impl: typ_a << typ'''''' holds)), then

        1. The relation holds

      2. Else Phantom#705 ((typ''''' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ (~(Sub_impl: typ_a << typ'''''' holds))

    2. Else Phantom#706 ((typ''''' has type datatyp)) /\ (~(datatyp matches pattern `SEnumT%%%`))

  2. Case (% has type synthtyp)

    1. (Let synthtyp be (typ''''' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ_a*{typ_a <- typ_a*}) be synthtyp)

        2. Case analysis on typ''''''

          1. Case (% has type datatyp)

            1. (Let datatyp be (typ'''''' as datatyp))

            2. Case analysis on datatyp

              1. Case (% matches pattern `ListT%`)

                1. (Let (ListT typ'''''') be datatyp)

                2. If ((Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*}, then

                  1. The relation holds

                2. Else Phantom#707 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `ListT%`)) /\ (exists ~(Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*}

              2. Case (% matches pattern `TupleT%`)

                1. (Let (TupleT typ''''''*{typ'''''' <- typ''''''*}) be datatyp)

                2. If ((Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*, typ'''''' <- typ''''''*}, then

                  1. The relation holds

                2. Else Phantom#708 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ (exists ~(Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*, typ'''''' <- typ''''''*}

              3. Case (% matches pattern `StackT%%`)

                1. (Let (StackT typ'''''' i_size) be datatyp)

                2. If (((|typ_a*{typ_a <- typ_a*}| as int) <= i_size)), then

                  1. If ((Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*}, then

                    1. The relation holds

                  1. Else Phantom#709 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (((|typ_a*{typ_a <- typ_a*}| as int) <= i_size)) /\ (exists ~(Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*}

                2. Else Phantom#710 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~((|typ_a*{typ_a <- typ_a*}| as int) <= i_size))

              4. Case (% matches pattern `StructT%%`)

                1. (Let (StructT _id (_member, typ'''''')*{_member <- _member*, typ'''''' <- typ''''''*}) be datatyp)

                2. If ((Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*, typ'''''' <- typ''''''*}, then

                  1. The relation holds

                2. Else Phantom#711 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (exists ~(Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*, typ'''''' <- typ''''''*}

              5. Case (% matches pattern `HeaderT%%`)

                1. (Let (HeaderT _id (_member, typ'''''')*{_member <- _member*, typ'''''' <- typ''''''*}) be datatyp)

                2. If ((Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*, typ'''''' <- typ''''''*}, then

                  1. The relation holds

                2. Else Phantom#712 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (exists ~(Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*, typ'''''' <- typ''''''*}

            2. Else Phantom#713 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `ListT%`)) /\ (~(datatyp matches pattern `TupleT%`)) /\ (~(datatyp matches pattern `StackT%%`)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

          2. Case (% has type synthtyp)

            1. (Let synthtyp' be (typ'''''' as synthtyp))

            2. If ((synthtyp' matches pattern `SeqT%`)), then

              1. (Let (SeqT typ''''''*{typ'''''' <- typ''''''*}) be synthtyp')

              2. If ((Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*, typ'''''' <- typ''''''*}, then

                1. The relation holds

              2. Else Phantom#714 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type synthtyp)) /\ ((synthtyp' matches pattern `SeqT%`)) /\ (exists ~(Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*, typ'''''' <- typ''''''*}

            2. Else Phantom#715 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ ((typ'''''' has type synthtyp)) /\ (~(synthtyp' matches pattern `SeqT%`))

        2. Else Phantom#716 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqT%`)) /\ (~(typ'''''' has type datatyp)) /\ (~(typ'''''' has type synthtyp))

      2. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member_a, typ_a)*{member_a <- member_a*, typ_a <- typ_a*}) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (member_b, typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))), then

                1. (Let typ''?{typ'' <- typ''?} be $find_map<member, typ>(({ (member_a -> typ_a)*{member_a <- member_a*, typ_a <- typ_a*} }), member_a))*{member_a <- member_a*, typ''? <- typ''?*}

                2. If ((typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}, then

                  1. (Let ?(typ_a') be typ''?{typ'' <- typ''?})*{typ''? <- typ''?*, typ_a' <- typ_a'*}

                  2. (Let typ'''?{typ''' <- typ'''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ'''? <- typ'''?*}

                  3. If ((typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}, then

                    1. (Let ?(typ_b') be typ'''?{typ''' <- typ'''?})*{typ'''? <- typ'''?*, typ_b' <- typ_b'*}

                    2. If ((Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}, then

                      1. The relation holds

                    2. Else Phantom#717 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (exists ~(Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}

                  3. Else Phantom#718 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (exists ~(typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}

                2. Else Phantom#719 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (exists ~(typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}

              2. Else Phantom#720 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~$eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} })))

            2. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (member_b, typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))), then

                1. (Let typ''?{typ'' <- typ''?} be $find_map<member, typ>(({ (member_a -> typ_a)*{member_a <- member_a*, typ_a <- typ_a*} }), member_a))*{member_a <- member_a*, typ''? <- typ''?*}

                2. If ((typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}, then

                  1. (Let ?(typ_a') be typ''?{typ'' <- typ''?})*{typ''? <- typ''?*, typ_a' <- typ_a'*}

                  2. (Let typ'''?{typ''' <- typ'''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ'''? <- typ'''?*}

                  3. If ((typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}, then

                    1. (Let ?(typ_b') be typ'''?{typ''' <- typ'''?})*{typ'''? <- typ'''?*, typ_b' <- typ_b'*}

                    2. If ((Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}, then

                      1. The relation holds

                    2. Else Phantom#721 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (exists ~(Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}

                  3. Else Phantom#722 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (exists ~(typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}

                2. Else Phantom#723 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (exists ~(typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}

              2. Else Phantom#724 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~$eq_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} })))

          2. Else Phantom#725 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

        2. Else Phantom#726 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordT%`)) /\ (~(typ'''''' has type datatyp))

      3. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ_a*{typ_a <- typ_a*}) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `TupleT%`)

              1. (Let (TupleT typ''''''*{typ'''''' <- typ''''''*}) be datatyp)

              2. If ((|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|)), then

                1. (Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) be $partition_<typ>(typ''''''*{typ'''''' <- typ''''''*}, |typ_a*{typ_a <- typ_a*}|))

                2. If ((Sub_impl: typ_a << typ_c holds))*{typ_a <- typ_a*, typ_c <- typ_c*}, then

                  1. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then

                    1. The relation holds

                  1. Else Phantom#727 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ ((|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (forall (Sub_impl: typ_a << typ_c holds))*{typ_a <- typ_a*, typ_c <- typ_c*} /\ (exists ~$is_deftable(typ_d))*{typ_d <- typ_d*}

                2. Else Phantom#728 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ ((|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (exists ~(Sub_impl: typ_a << typ_c holds))*{typ_a <- typ_a*, typ_c <- typ_c*}

              2. Else Phantom#729 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ (~(|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|))

            2. Case (% matches pattern `StackT%%`)

              1. (Let (StackT typ'''''' i_size) be datatyp)

              2. If (((|typ_a*{typ_a <- typ_a*}| as int) < i_size)), then

                1. If ((Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*}, then

                  1. If ($is_deftable(typ'''''')), then

                    1. The relation holds

                  1. Else Phantom#730 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (((|typ_a*{typ_a <- typ_a*}| as int) < i_size)) /\ (forall (Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*} /\ (~$is_deftable(typ''''''))

                1. Else Phantom#731 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (((|typ_a*{typ_a <- typ_a*}| as int) < i_size)) /\ (exists ~(Sub_impl: typ_a << typ'''''' holds))*{typ_a <- typ_a*}

              2. Else Phantom#732 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~((|typ_a*{typ_a <- typ_a*}| as int) < i_size))

            3. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (_member, typ'''''')*{_member <- _member*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ((|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|)), then

                1. (Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) be $partition_<typ>(typ''''''*{typ'''''' <- typ''''''*}, |typ_a*{typ_a <- typ_a*}|))

                2. If ((Sub_impl: typ_a << typ_c holds))*{typ_a <- typ_a*, typ_c <- typ_c*}, then

                  1. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then

                    1. The relation holds

                  1. Else Phantom#733 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ((|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (forall (Sub_impl: typ_a << typ_c holds))*{typ_a <- typ_a*, typ_c <- typ_c*} /\ (exists ~$is_deftable(typ_d))*{typ_d <- typ_d*}

                2. Else Phantom#734 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ((|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (exists ~(Sub_impl: typ_a << typ_c holds))*{typ_a <- typ_a*, typ_c <- typ_c*}

              2. Else Phantom#735 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~(|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|))

            4. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (_member, typ'''''')*{_member <- _member*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ((|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|)), then

                1. (Let (typ_c*{typ_c <- typ_c*}, typ_d*{typ_d <- typ_d*}) be $partition_<typ>(typ''''''*{typ'''''' <- typ''''''*}, |typ_a*{typ_a <- typ_a*}|))

                2. If ((Sub_impl: typ_a << typ_c holds))*{typ_a <- typ_a*, typ_c <- typ_c*}, then

                  1. If ($is_deftable(typ_d))*{typ_d <- typ_d*}, then

                    1. The relation holds

                  1. Else Phantom#736 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ((|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (forall (Sub_impl: typ_a << typ_c holds))*{typ_a <- typ_a*, typ_c <- typ_c*} /\ (exists ~$is_deftable(typ_d))*{typ_d <- typ_d*}

                2. Else Phantom#737 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ((|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|)) /\ (exists ~(Sub_impl: typ_a << typ_c holds))*{typ_a <- typ_a*, typ_c <- typ_c*}

              2. Else Phantom#738 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~(|typ_a*{typ_a <- typ_a*}| < |typ''''''*{typ'''''' <- typ''''''*}|))

          2. Else Phantom#739 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `TupleT%`)) /\ (~(datatyp matches pattern `StackT%%`)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

        2. Else Phantom#740 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `SeqDefaultT%`)) /\ (~(typ'''''' has type datatyp))

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member_a, typ_a)*{member_a <- member_a*, typ_a <- typ_a*}) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (member_b, typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))), then

                1. (Let ({ member_c*{member_c <- member_c*} }) be $diff_set<member>(({ member_b*{member_b <- member_b*} }), ({ member_a*{member_a <- member_a*} })))

                2. (Let typ''?{typ'' <- typ''?} be $find_map<member, typ>(({ (member_a -> typ_a)*{member_a <- member_a*, typ_a <- typ_a*} }), member_a))*{member_a <- member_a*, typ''? <- typ''?*}

                3. If ((typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}, then

                  1. (Let ?(typ_a') be typ''?{typ'' <- typ''?})*{typ''? <- typ''?*, typ_a' <- typ_a'*}

                  2. (Let typ'''?{typ''' <- typ'''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ'''? <- typ'''?*}

                  3. If ((typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}, then

                    1. (Let ?(typ_b') be typ'''?{typ''' <- typ'''?})*{typ'''? <- typ'''?*, typ_b' <- typ_b'*}

                    2. If ((Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}, then

                      1. (Let typ''''?{typ'''' <- typ''''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_c))*{member_c <- member_c*, typ''''? <- typ''''?*}

                      2. If ((typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*}, then

                        1. (Let ?(typ_c') be typ''''?{typ'''' <- typ''''?})*{typ''''? <- typ''''?*, typ_c' <- typ_c'*}

                        2. If ($is_deftable(typ_c'))*{typ_c' <- typ_c'*}, then

                          1. The relation holds

                        2. Else Phantom#741 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (forall (Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*} /\ (forall (typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*} /\ (exists ~$is_deftable(typ_c'))*{typ_c' <- typ_c'*}

                      2. Else Phantom#742 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (forall (Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*} /\ (exists ~(typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*}

                    2. Else Phantom#743 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (exists ~(Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}

                  3. Else Phantom#744 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (exists ~(typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}

                3. Else Phantom#745 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (exists ~(typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}

              2. Else Phantom#746 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~$sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} })))

            2. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT id (member_b, typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*}) be datatyp)

              2. If ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))), then

                1. (Let ({ member_c*{member_c <- member_c*} }) be $diff_set<member>(({ member_b*{member_b <- member_b*} }), ({ member_a*{member_a <- member_a*} })))

                2. (Let typ''?{typ'' <- typ''?} be $find_map<member, typ>(({ (member_a -> typ_a)*{member_a <- member_a*, typ_a <- typ_a*} }), member_a))*{member_a <- member_a*, typ''? <- typ''?*}

                3. If ((typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}, then

                  1. (Let ?(typ_a') be typ''?{typ'' <- typ''?})*{typ''? <- typ''?*, typ_a' <- typ_a'*}

                  2. (Let typ'''?{typ''' <- typ'''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_a))*{member_a <- member_a*, typ'''? <- typ'''?*}

                  3. If ((typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}, then

                    1. (Let ?(typ_b') be typ'''?{typ''' <- typ'''?})*{typ'''? <- typ'''?*, typ_b' <- typ_b'*}

                    2. If ((Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}, then

                      1. (Let typ''''?{typ'''' <- typ''''?} be $find_map<member, typ>(({ (member_b -> typ'''''')*{member_b <- member_b*, typ'''''' <- typ''''''*} }), member_c))*{member_c <- member_c*, typ''''? <- typ''''?*}

                      2. If ((typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*}, then

                        1. (Let ?(typ_c') be typ''''?{typ'''' <- typ''''?})*{typ''''? <- typ''''?*, typ_c' <- typ_c'*}

                        2. If ($is_deftable(typ_c'))*{typ_c' <- typ_c'*}, then

                          1. The relation holds

                        2. Else Phantom#747 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (forall (Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*} /\ (forall (typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*} /\ (exists ~$is_deftable(typ_c'))*{typ_c' <- typ_c'*}

                      2. Else Phantom#748 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (forall (Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*} /\ (exists ~(typ''''?{typ'''' <- typ''''?} matches pattern (_)))*{typ''''? <- typ''''?*}

                    2. Else Phantom#749 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (forall (typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*} /\ (exists ~(Sub_impl: typ_a' << typ_b' holds))*{typ_a' <- typ_a'*, typ_b' <- typ_b'*}

                  3. Else Phantom#750 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (forall (typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*} /\ (exists ~(typ'''?{typ''' <- typ'''?} matches pattern (_)))*{typ'''? <- typ'''?*}

                3. Else Phantom#751 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ ($sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} }))) /\ (exists ~(typ''?{typ'' <- typ''?} matches pattern (_)))*{typ''? <- typ''?*}

              2. Else Phantom#752 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~$sub_set<member>(({ member_a*{member_a <- member_a*} }), ({ member_b*{member_b <- member_b*} })))

          2. Else Phantom#753 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`))

        2. Else Phantom#754 ((typ''''' has type synthtyp)) /\ ((synthtyp matches pattern `RecordDefaultT%`)) /\ (~(typ'''''' has type datatyp))

    2. Else Phantom#755 ((typ''''' has type synthtyp)) /\ (~(synthtyp matches pattern `SeqT%`)) /\ (~(synthtyp matches pattern `RecordT%`)) /\ (~(synthtyp matches pattern `SeqDefaultT%`)) /\ (~(synthtyp matches pattern `RecordDefaultT%`))

2. Else Phantom#756 (~(typ''''' has type datatyp)) /\ (~(typ''''' has type synthtyp))

3. If ((typ''''' = ((DefaultT) as typ))), then

  1. If ($is_deftable(typ'''''')), then

    1. The relation holds

  1. Else Phantom#757 ((typ''''' = ((DefaultT) as typ))) /\ (~$is_deftable(typ''''''))

3. Else Phantom#758 (~(typ''''' = ((DefaultT) as typ)))

4. If ((typ''''' = ((InvalidT) as typ))), then

  1. If ((typ'''''' has type datatyp)), then

    1. (Let datatyp be (typ'''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. The relation holds

      2. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*{_(member, typ) <- _(member, typ)*}) be datatyp)

        2. The relation holds

    2. Else Phantom#759 ((typ''''' = ((InvalidT) as typ))) /\ ((typ'''''' has type datatyp)) /\ (~(datatyp matches pattern `HeaderT%%`)) /\ (~(datatyp matches pattern `UnionT%%`))

  1. Else Phantom#760 ((typ''''' = ((InvalidT) as typ))) /\ (~(typ'''''' has type datatyp))

4. Else Phantom#761 (~(typ''''' = ((InvalidT) as typ)))

;; ../../../../spec/4b-typing-relation.watsup:75.1-77.23
relation Expr_ok: p', C, expr''

1. Case analysis on expr''

  1. Case (% matches pattern `BoolE%`)

    1. (Let (BoolE b) be expr'')

    2. Result in (ValueE (BoolV b) (( ((BoolT) as typ) ; (LCTK) )))

  2. Case (% matches pattern `StrE%`)

    1. (Let (StrE t) be expr'')

    2. Result in (ValueE (StrV t) (( ((StrT) as typ) ; (LCTK) )))

  3. Case (% matches pattern `NumE%`)

    1. (Let (NumE num) be expr'')

    2. Case analysis on num

      1. Case (% matches pattern `INT%`)

        1. (Let (INT i) be num)

        2. Result in (ValueE (IntV i) (( ((IntT) as typ) ; (LCTK) )))

      2. Case (% matches pattern `FINT%%`)

        1. (Let (FINT w i) be num)

        2. (Let bs be $to_bitstr((w as int), i))

        3. Result in (ValueE (FIntV w bs) (( ((FIntT w) as typ) ; (LCTK) )))

      3. Case (% matches pattern `FBIT%%`)

        1. (Let (FBIT w i) be num)

        2. (Let bs be $to_bitstr((w as int), i))

        3. Result in (ValueE (FBitV w bs) (( ((FBitT w) as typ) ; (LCTK) )))

  4. Case (% matches pattern `NameE%`)

    1. (Let (NameE name) be expr'')

    2. (Let styp?{styp <- styp?} be $find_styp(p', C, name))

    3. If ((styp?{styp <- styp?} matches pattern (_))), then

      1. (Let ?((typ _dir ctk _val?{_val <- _val?})) be styp?{styp <- styp?})

      2. Result in (NameE name (( typ ; ctk )))

    3. Else Phantom#762 ((expr'' matches pattern `NameE%`)) /\ (~(styp?{styp <- styp?} matches pattern (_)))

  5. Case (% matches pattern `SeqE%`)

    1. (Let (SeqE expr''*{expr'' <- expr''*}) be expr'')

    2. (Expr_ok: p' C |- expr'' : exprIL)*{expr'' <- expr''*, exprIL <- exprIL*}

    3. (Let (( typ ; ctk )) be $annot(exprIL))*{ctk <- ctk*, exprIL <- exprIL*, typ <- typ*}

    4. (Let ctk_e be $joins_ctk(ctk*{ctk <- ctk*}))

    5. Result in (SeqE exprIL*{exprIL <- exprIL*} (( ((SeqT typ*{typ <- typ*}) as typ) ; ctk_e )))

  6. Case (% matches pattern `SeqDefaultE%`)

    1. (Let (SeqDefaultE expr''*{expr'' <- expr''*}) be expr'')

    2. (Expr_ok: p' C |- expr'' : exprIL)*{expr'' <- expr''*, exprIL <- exprIL*}

    3. (Let (( typ ; ctk )) be $annot(exprIL))*{ctk <- ctk*, exprIL <- exprIL*, typ <- typ*}

    4. (Let ctk_e be $joins_ctk(ctk*{ctk <- ctk*}))

    5. Result in (SeqDefaultE exprIL*{exprIL <- exprIL*} (( ((SeqDefaultT typ*{typ <- typ*}) as typ) ; ctk_e )))

  7. Case (% matches pattern `RecordE%`)

    1. (Let (RecordE (member, expr'')*{expr'' <- expr''*, member <- member*}) be expr'')

    2. (Expr_ok: p' C |- expr'' : exprIL)*{expr'' <- expr''*, exprIL <- exprIL*}

    3. (Let (( typ ; ctk )) be $annot(exprIL))*{ctk <- ctk*, exprIL <- exprIL*, typ <- typ*}

    4. (Let ctk_e be $joins_ctk(ctk*{ctk <- ctk*}))

    5. Result in (RecordE (member, exprIL)*{exprIL <- exprIL*, member <- member*} (( ((RecordT (member, typ)*{member <- member*, typ <- typ*}) as typ) ; ctk_e )))

  8. Case (% matches pattern `RecordDefaultE%`)

    1. (Let (RecordDefaultE (member, expr'')*{expr'' <- expr''*, member <- member*}) be expr'')

    2. (Expr_ok: p' C |- expr'' : exprIL)*{expr'' <- expr''*, exprIL <- exprIL*}

    3. (Let (( typ ; ctk )) be $annot(exprIL))*{ctk <- ctk*, exprIL <- exprIL*, typ <- typ*}

    4. (Let ctk_e be $joins_ctk(ctk*{ctk <- ctk*}))

    5. Result in (RecordE (member, exprIL)*{exprIL <- exprIL*, member <- member*} (( ((RecordDefaultT (member, typ)*{member <- member*, typ <- typ*}) as typ) ; ctk_e )))

  9. Case (% matches pattern `DefaultE`)

    1. Result in (DefaultE (( ((DefaultT) as typ) ; (LCTK) )))

  10. Case (% matches pattern `InvalidE`)

    1. Result in (ValueE (InvalidV) (( ((InvalidT) as typ) ; (LCTK) )))

  11. Case (% matches pattern `UnE%%`)

    1. (Let (UnE unop expr'') be expr'')

    2. Case analysis on unop

      1. Case (% matches pattern `BNOT`)

        1. (Expr_ok: p' C |- expr'' : exprIL)

        2. (Let exprIL_e be $reduce_senum_unary(exprIL, $compatible_bnot))

        3. (Let (( typ_e ; ctk_e )) be $annot(exprIL_e))

        4. Result in (UnE (BNOT) exprIL_e (( typ_e ; ctk_e )))

      2. Case (% matches pattern `LNOT`)

        1. (Expr_ok: p' C |- expr'' : exprIL)

        2. (Let exprIL_e be $reduce_senum_unary(exprIL, $compatible_lnot))

        3. (Let (( typ_e ; ctk_e )) be $annot(exprIL_e))

        4. Result in (UnE (LNOT) exprIL_e (( typ_e ; ctk_e )))

      3. Case (% matches pattern `UPLUS`)

        1. (Expr_ok: p' C |- expr'' : exprIL)

        2. (Let exprIL_e be $reduce_senum_unary(exprIL, $compatible_uplus))

        3. (Let (( typ_e ; ctk_e )) be $annot(exprIL_e))

        4. Result in (UnE (UPLUS) exprIL_e (( typ_e ; ctk_e )))

      4. Case (% matches pattern `UMINUS`)

        1. (Expr_ok: p' C |- expr'' : exprIL)

        2. (Let exprIL_e be $reduce_senum_unary(exprIL, $compatible_uminus))

        3. (Let (( typ_e ; ctk_e )) be $annot(exprIL_e))

        4. Result in (UnE (UMINUS) exprIL_e (( typ_e ; ctk_e )))

  12. Case (% matches pattern `BinE%%%`)

    1. (Let (BinE binop expr_l expr_r) be expr'')

    2. If (binop is in [(PLUS), (MINUS), (MUL)]), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r))

      4. (Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_plusminusmult))

      5. (Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l''))

      6. (Let (( _typ ; ctk_r'' )) be $annot(exprIL_r''))

      7. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

      8. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

    2. Else Phantom#763 ((expr'' matches pattern `BinE%%%`)) /\ (~binop is in [(PLUS), (MINUS), (MUL)])

    3. If (binop is in [(SPLUS), (SMINUS)]), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r))

      4. (Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_satplusminus))

      5. (Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l''))

      6. (Let (( _typ ; ctk_r'' )) be $annot(exprIL_r''))

      7. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

      8. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

    3. Else Phantom#764 ((expr'' matches pattern `BinE%%%`)) /\ (~binop is in [(SPLUS), (SMINUS)])

    4. If (binop is in [(DIV), (MOD)]), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r))

      4. (Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_divmod))

      5. (Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l''))

      6. (Let (( _typ ; ctk' )) be $annot(exprIL_r''))

      7. If ((ctk' matches pattern `LCTK`)), then

        1. (Eval_static: p' C |- exprIL_r'' ~> val_r)

        2. (Let int be $get_num(val_r))

        3. If ((int has type nat)), then

          1. (Let n_r be (int as nat))

          2. If ((n_r > 0)), then

            1. (Let ctk be $join_ctk(ctk_l'', (LCTK)))

            2. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

          2. Else Phantom#765 ((expr'' matches pattern `BinE%%%`)) /\ (binop is in [(DIV), (MOD)]) /\ ((ctk' matches pattern `LCTK`)) /\ ((int has type nat)) /\ (~(n_r > 0))

        3. Else Phantom#766 ((expr'' matches pattern `BinE%%%`)) /\ (binop is in [(DIV), (MOD)]) /\ ((ctk' matches pattern `LCTK`)) /\ (~(int has type nat))

      7. Else Phantom#767 ((expr'' matches pattern `BinE%%%`)) /\ (binop is in [(DIV), (MOD)]) /\ (~(ctk' matches pattern `LCTK`))

      8. (Let (( _typ ; ctk_r'' )) be $annot(exprIL_r''))

      9. If (~(ctk_r'' matches pattern `LCTK`)), then

        1. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

        2. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

      9. Else Phantom#768 ((expr'' matches pattern `BinE%%%`)) /\ (binop is in [(DIV), (MOD)]) /\ (~~(ctk_r'' matches pattern `LCTK`))

    4. Else Phantom#769 ((expr'' matches pattern `BinE%%%`)) /\ (~binop is in [(DIV), (MOD)])

    5. If (binop is in [(SHL), (SHR)]), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL_l', exprIL_r') be $reduce_senums_binary(exprIL_l, exprIL_r, $compatible_shift))

      4. (Let (( typ_l' ; ctk_l' )) be $annot(exprIL_l'))

      5. (Let (( typ_r' ; ctk_r' )) be $annot(exprIL_r'))

      6. If ((($is_fintt(typ_r') \/ $is_intt(typ_r')) => (ctk_r' = (LCTK)))), then

        1. (Let ctk be $join_ctk(ctk_l', ctk_r'))

        2. Result in (BinE binop exprIL_l' exprIL_r' (( typ_l' ; ctk )))

      6. Else Phantom#770 ((expr'' matches pattern `BinE%%%`)) /\ (binop is in [(SHL), (SHR)]) /\ (~(($is_fintt(typ_r') \/ $is_intt(typ_r')) => (ctk_r' = (LCTK))))

    5. Else Phantom#771 ((expr'' matches pattern `BinE%%%`)) /\ (~binop is in [(SHL), (SHR)])

    6. If (binop is in [(EQ), (NE)]), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r))

      4. (Let (( typ' ; ctk_l' )) be $annot(exprIL_l'))

      5. (Let (( _typ ; ctk_r' )) be $annot(exprIL_r'))

      6. If ($is_equalable(typ')), then

        1. (Let ctk be $join_ctk(ctk_l', ctk_r'))

        2. Result in (BinE binop exprIL_l' exprIL_r' (( ((BoolT) as typ) ; ctk )))

      6. Else Phantom#772 ((expr'' matches pattern `BinE%%%`)) /\ (binop is in [(EQ), (NE)]) /\ (~$is_equalable(typ'))

    6. Else Phantom#773 ((expr'' matches pattern `BinE%%%`)) /\ (~binop is in [(EQ), (NE)])

    7. If (binop is in [(LE), (GE), (LT), (GT)]), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r))

      4. (Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_compare))

      5. (Let (( _typ ; ctk_l'' )) be $annot(exprIL_l''))

      6. (Let (( _typ' ; ctk_r'' )) be $annot(exprIL_r''))

      7. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

      8. Result in (BinE binop exprIL_l'' exprIL_r'' (( ((BoolT) as typ) ; ctk )))

    7. Else Phantom#774 ((expr'' matches pattern `BinE%%%`)) /\ (~binop is in [(LE), (GE), (LT), (GT)])

    8. If (binop is in [(BAND), (BXOR), (BOR)]), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r))

      4. (Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_bitwise))

      5. (Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l''))

      6. (Let (( _typ ; ctk_r'' )) be $annot(exprIL_r''))

      7. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

      8. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

    8. Else Phantom#775 ((expr'' matches pattern `BinE%%%`)) /\ (~binop is in [(BAND), (BXOR), (BOR)])

    9. If ((binop matches pattern `CONCAT`)), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL_l', exprIL_r') be $reduce_senums_binary(exprIL_l, exprIL_r, $compatible_concat))

      4. (Let (( typ_l' ; ctk_l' )) be $annot(exprIL_l'))

      5. (Let (( typ_r' ; ctk_r' )) be $annot(exprIL_r'))

      6. (Let w be ($get_width(typ_l') + $get_width(typ_r')))

      7. If ($is_fintt(typ_l')), then

        1. (Let typ'' be ((FIntT w) as typ))

        2. (Let ctk be $join_ctk(ctk_l', ctk_r'))

        3. Result in (BinE (CONCAT) exprIL_l' exprIL_r' (( typ'' ; ctk )))

      7. Else Phantom#776 ((expr'' matches pattern `BinE%%%`)) /\ ((binop matches pattern `CONCAT`)) /\ (~$is_fintt(typ_l'))

      8. If ($is_fbitt(typ_l')), then

        1. (Let typ'' be ((FBitT w) as typ))

        2. (Let ctk be $join_ctk(ctk_l', ctk_r'))

        3. Result in (BinE (CONCAT) exprIL_l' exprIL_r' (( typ'' ; ctk )))

      8. Else Phantom#777 ((expr'' matches pattern `BinE%%%`)) /\ ((binop matches pattern `CONCAT`)) /\ (~$is_fbitt(typ_l'))

    9. Else Phantom#778 ((expr'' matches pattern `BinE%%%`)) /\ (~(binop matches pattern `CONCAT`))

    10. If (binop is in [(LAND), (LOR)]), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r))

      4. (Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_logical))

      5. (Let (( _typ ; ctk_l'' )) be $annot(exprIL_l''))

      6. (Let (( _typ' ; ctk_r'' )) be $annot(exprIL_r''))

      7. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

      8. Result in (BinE binop exprIL_l exprIL_r (( ((BoolT) as typ) ; ctk )))

    10. Else Phantom#779 ((expr'' matches pattern `BinE%%%`)) /\ (~binop is in [(LAND), (LOR)])

  13. Case (% matches pattern `TernE%%%`)

    1. (Let (TernE expr_c expr_t expr_f) be expr'')

    2. (Expr_ok: p' C |- expr_c : exprIL_c)

    3. (Let (( typ ; ctk_c )) be $annot(exprIL_c))

    4. If ((typ = ((BoolT) as typ))), then

      1. (Expr_ok: p' C |- expr_t : exprIL_t)

      2. (Expr_ok: p' C |- expr_f : exprIL_f)

      3. (Let (exprIL_t', exprIL_f') be $coerce_binary(exprIL_t, exprIL_f))

      4. (Let (( typ' ; ctk_t )) be $annot(exprIL_t'))

      5. (Let (( _typ ; ctk_f )) be $annot(exprIL_f'))

      6. If (($is_intt(typ') => ((ctk_c = (CTK)) \/ (ctk_c = (LCTK))))), then

        1. (Let ctk be $joins_ctk([ctk_c, ctk_t, ctk_f]))

        2. Result in (TernE exprIL_c exprIL_t' exprIL_f' (( typ' ; ctk )))

      6. Else Phantom#780 ((expr'' matches pattern `TernE%%%`)) /\ ((typ = ((BoolT) as typ))) /\ (~($is_intt(typ') => ((ctk_c = (CTK)) \/ (ctk_c = (LCTK)))))

    4. Else Phantom#781 ((expr'' matches pattern `TernE%%%`)) /\ (~(typ = ((BoolT) as typ)))

  14. Case (% matches pattern `CastE%%`)

    1. (Let (CastE type expr_b) be expr'')

    2. (Type_ok: p' C |- type : typ tid*{tid <- tid*})

    3. If ((tid*{tid <- tid*} matches pattern [])), then

      1. If ((Type_wf: $bound_tids(p', C) |- typ holds)), then

        1. (Expr_ok: p' C |- expr_b : exprIL_b)

        2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

        3. If ((Sub_expl: typ_b <: typ holds)), then

          1. Result in (CastE typ exprIL_b (( typ ; ctk_b )))

        3. Else Phantom#782 ((expr'' matches pattern `CastE%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((Type_wf: $bound_tids(p', C) |- typ holds)) /\ (~(Sub_expl: typ_b <: typ holds))

      1. Else Phantom#783 ((expr'' matches pattern `CastE%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(Type_wf: $bound_tids(p', C) |- typ holds))

    3. Else Phantom#784 ((expr'' matches pattern `CastE%%`)) /\ (~(tid*{tid <- tid*} matches pattern []))

  15. Case (% matches pattern `MaskE%%`)

    1. (Let (MaskE expr_b expr_m) be expr'')

    2. (Expr_ok: p' C |- expr_b : exprIL_b)

    3. (Expr_ok: p' C |- expr_m : exprIL_m)

    4. (Let (exprIL_b', exprIL_m') be $coerce_binary(exprIL_b, exprIL_m))

    5. (Let (exprIL_b'', exprIL_m'') be $reduce_senums_binary(exprIL_b', exprIL_m', $compatible_mask))

    6. (Let (( typ'' ; _ctk )) be $annot(exprIL_b''))

    7. Result in (MaskE exprIL_b'' exprIL_m'' (( ((SetT typ'') as typ) ; (DYN) )))

  16. Case (% matches pattern `RangeE%%`)

    1. (Let (RangeE expr_lb expr_ub) be expr'')

    2. (Expr_ok: p' C |- expr_lb : exprIL_lb)

    3. (Expr_ok: p' C |- expr_ub : exprIL_ub)

    4. (Let (exprIL_ub', exprIL_lb') be $coerce_binary(exprIL_lb, exprIL_ub))

    5. (Let (exprIL_lb'', exprIL_ub'') be $reduce_senums_binary(exprIL_lb', exprIL_ub', $compatible_range))

    6. (Let (( typ'' ; _ctk )) be $annot(exprIL_lb''))

    7. Result in (RangeE exprIL_lb'' exprIL_ub'' (( ((SetT typ'') as typ) ; (DYN) )))

  17. Case (% matches pattern `ArrAccE%%`)

    1. (Let (ArrAccE expr_b expr_i) be expr'')

    2. (Expr_ok: p' C |- expr_b : exprIL_b)

    3. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

    4. (Expr_ok: p' C |- expr_i : exprIL_i)

    5. (Let (( typ_i ; ctk )) be $annot(exprIL_i))

    6. If ((ctk matches pattern `LCTK`)), then

      1. (Let exprIL_i' be $reduce_senum_unary(exprIL_i, $compatible_arrayindex))

      2. (Let typ' be $canon_typ(typ_b))

      3. If ((typ' has type datatyp)), then

        1. (Let datatyp be (typ' as datatyp))

        2. If ((datatyp matches pattern `TupleT%`)), then

          1. (Let (TupleT typ_b'*{typ_b' <- typ_b'*}) be datatyp)

          2. (Eval_static: p' C |- exprIL_i' ~> val_i)

          3. (Let int be $get_num(val_i))

          4. If ((int has type nat)), then

            1. (Let n be (int as nat))

            2. (Let typ be typ_b'*{typ_b' <- typ_b'*}[n])

            3. Result in (ArrAccE exprIL_b exprIL_i' (( typ ; (DYN) )))

          4. Else Phantom#785 ((expr'' matches pattern `ArrAccE%%`)) /\ ((ctk matches pattern `LCTK`)) /\ ((typ' has type datatyp)) /\ ((datatyp matches pattern `TupleT%`)) /\ (~(int has type nat))

        2. Else Phantom#786 ((expr'' matches pattern `ArrAccE%%`)) /\ ((ctk matches pattern `LCTK`)) /\ ((typ' has type datatyp)) /\ (~(datatyp matches pattern `TupleT%`))

      3. Else Phantom#787 ((expr'' matches pattern `ArrAccE%%`)) /\ ((ctk matches pattern `LCTK`)) /\ (~(typ' has type datatyp))

    6. Else Phantom#788 ((expr'' matches pattern `ArrAccE%%`)) /\ (~(ctk matches pattern `LCTK`))

    7. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

    8. If ((ctk matches pattern `LCTK`)), then

      1. (Let exprIL_i' be $reduce_senum_unary(exprIL_i, $compatible_arrayindex))

      2. (Let typ be $canon_typ(typ_b))

      3. If ((typ has type datatyp)), then

        1. (Let datatyp be (typ as datatyp))

        2. If ((datatyp matches pattern `StackT%%`)), then

          1. (Let (StackT typ_b' i_s) be datatyp)

          2. (Eval_static: p' C |- exprIL_i' ~> val_i)

          3. (Let i be $get_num(val_i))

          4. If ((((0 as int) <= i) /\ (i <= i_s))), then

            1. Result in (ArrAccE exprIL_b exprIL_i' (( typ_b' ; (DYN) )))

          4. Else Phantom#789 ((expr'' matches pattern `ArrAccE%%`)) /\ ((ctk matches pattern `LCTK`)) /\ ((typ has type datatyp)) /\ ((datatyp matches pattern `StackT%%`)) /\ (~(((0 as int) <= i) /\ (i <= i_s)))

        2. Else Phantom#790 ((expr'' matches pattern `ArrAccE%%`)) /\ ((ctk matches pattern `LCTK`)) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `StackT%%`))

      3. Else Phantom#791 ((expr'' matches pattern `ArrAccE%%`)) /\ ((ctk matches pattern `LCTK`)) /\ (~(typ has type datatyp))

    8. Else Phantom#792 ((expr'' matches pattern `ArrAccE%%`)) /\ (~(ctk matches pattern `LCTK`))

    9. (Let (( typ_i ; ctk_i )) be $annot(exprIL_i))

    10. If (~(ctk_i matches pattern `LCTK`)), then

      1. (Let exprIL_i' be $reduce_senum_unary(exprIL_i, $compatible_arrayindex))

      2. (Let typ be $canon_typ(typ_b))

      3. If ((typ has type datatyp)), then

        1. (Let datatyp be (typ as datatyp))

        2. If ((datatyp matches pattern `StackT%%`)), then

          1. (Let (StackT typ_b' _int) be datatyp)

          2. Result in (ArrAccE exprIL_b exprIL_i' (( typ_b' ; (DYN) )))

        2. Else Phantom#793 ((expr'' matches pattern `ArrAccE%%`)) /\ (~(ctk_i matches pattern `LCTK`)) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `StackT%%`))

      3. Else Phantom#794 ((expr'' matches pattern `ArrAccE%%`)) /\ (~(ctk_i matches pattern `LCTK`)) /\ (~(typ has type datatyp))

    10. Else Phantom#795 ((expr'' matches pattern `ArrAccE%%`)) /\ (~~(ctk_i matches pattern `LCTK`))

  18. Case (% matches pattern `BitAccE%%%`)

    1. (Let (BitAccE expr_b expr_l expr_h) be expr'')

    2. (Expr_ok: p' C |- expr_b : exprIL_b)

    3. (Let exprIL_b' be $reduce_senum_unary(exprIL_b, $compatible_bitstringbase))

    4. (Let (( typ_b' ; ctk_b' )) be $annot(exprIL_b'))

    5. (Expr_ok: p' C |- expr_l : exprIL_l)

    6. (Let (( typ_l ; ctk )) be $annot(exprIL_l))

    7. If ((ctk matches pattern `LCTK`)), then

      1. (Let exprIL_l' be $reduce_senum_unary(exprIL_l, $compatible_bitstringindex))

      2. (Eval_static: p' C |- exprIL_l' ~> val_l)

      3. (Let int be $get_num(val_l))

      4. If ((int has type nat)), then

        1. (Let n_l be (int as nat))

        2. (Let exprIL_l'' be (ValueE val_l (( typ_l ; (LCTK) ))))

        3. (Expr_ok: p' C |- expr_h : exprIL_h)

        4. (Let (( typ_h ; ctk' )) be $annot(exprIL_h))

        5. If ((ctk' matches pattern `LCTK`)), then

          1. (Let exprIL_h' be $reduce_senum_unary(exprIL_h, $compatible_bitstringindex))

          2. (Eval_static: p' C |- exprIL_h' ~> val_h)

          3. (Let int' be $get_num(val_h))

          4. If ((int' has type nat)), then

            1. (Let n_h be (int' as nat))

            2. (Let exprIL_h'' be (ValueE val_h (( typ_h ; (LCTK) ))))

            3. If ($is_valid_bitstring_slice(typ_b', n_l, n_h)), then

              1. (Let typ be ((FBitT ((n_h - n_l) + 1)) as typ))

              2. Result in (BitAccE exprIL_b' exprIL_l'' exprIL_h'' (( typ ; ctk_b' )))

            3. Else Phantom#796 ((expr'' matches pattern `BitAccE%%%`)) /\ ((ctk matches pattern `LCTK`)) /\ ((int has type nat)) /\ ((ctk' matches pattern `LCTK`)) /\ ((int' has type nat)) /\ (~$is_valid_bitstring_slice(typ_b', n_l, n_h))

          4. Else Phantom#797 ((expr'' matches pattern `BitAccE%%%`)) /\ ((ctk matches pattern `LCTK`)) /\ ((int has type nat)) /\ ((ctk' matches pattern `LCTK`)) /\ (~(int' has type nat))

        5. Else Phantom#798 ((expr'' matches pattern `BitAccE%%%`)) /\ ((ctk matches pattern `LCTK`)) /\ ((int has type nat)) /\ (~(ctk' matches pattern `LCTK`))

      4. Else Phantom#799 ((expr'' matches pattern `BitAccE%%%`)) /\ ((ctk matches pattern `LCTK`)) /\ (~(int has type nat))

    7. Else Phantom#800 ((expr'' matches pattern `BitAccE%%%`)) /\ (~(ctk matches pattern `LCTK`))

  19. Case (% matches pattern `ErrAccE%`)

    1. (Let (ErrAccE member) be expr'')

    2. (Let id be $concat_text(["error.", member]))

    3. If ((?((ErrV member)) = $find_val(p', C, (TOP id)))), then

      1. Result in (ValueE (ErrV member) (( ((ErrT) as typ) ; (LCTK) )))

    3. Else Phantom#801 ((expr'' matches pattern `ErrAccE%`)) /\ (~(?((ErrV member)) = $find_val(p', C, (TOP id))))

  20. Case (% matches pattern `TypeAccE%%`)

    1. (Let (TypeAccE name member) be expr'')

    2. (Let typdef'?{typdef' <- typdef'?} be $find_typdef(p', C, name))

    3. If ((typdef'?{typdef' <- typdef'?} matches pattern (_))), then

      1. (Let ?(typdef) be typdef'?{typdef' <- typdef'?})

      2. If ((typdef has type monotypdef)), then

        1. (Let (MonoD typ) be (typdef as monotypdef))

        2. (Let typ' be $canon_typ(typ))

        3. If ((typ' has type datatyp)), then

          1. (Let datatyp be (typ' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `EnumT%%`)

              1. (Let (EnumT id_t member_t*{member_t <- member_t*}) be datatyp)

              2. If (member is in member_t*{member_t <- member_t*}), then

                1. Result in (ValueE (EnumFieldV id_t member) (( typ ; (LCTK) )))

              2. Else Phantom#802 ((expr'' matches pattern `TypeAccE%%`)) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type monotypdef)) /\ ((typ' has type datatyp)) /\ ((datatyp matches pattern `EnumT%%`)) /\ (~member is in member_t*{member_t <- member_t*})

            2. Case (% matches pattern `SEnumT%%%`)

              1. (Let (SEnumT id_t typ_t (member_t, val_t)*{member_t <- member_t*, val_t <- val_t*}) be datatyp)

              2. (Let val'?{val' <- val'?} be $assoc_<member, val>(member, (member_t, val_t)*{member_t <- member_t*, val_t <- val_t*}))

              3. If ((val'?{val' <- val'?} matches pattern (_))), then

                1. (Let ?(val) be val'?{val' <- val'?})

                2. Result in (ValueE (SEnumFieldV id_t member val) (( typ ; (LCTK) )))

              3. Else Phantom#803 ((expr'' matches pattern `TypeAccE%%`)) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type monotypdef)) /\ ((typ' has type datatyp)) /\ ((datatyp matches pattern `SEnumT%%%`)) /\ (~(val'?{val' <- val'?} matches pattern (_)))

          2. Else Phantom#804 ((expr'' matches pattern `TypeAccE%%`)) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type monotypdef)) /\ ((typ' has type datatyp)) /\ (~(datatyp matches pattern `EnumT%%`)) /\ (~(datatyp matches pattern `SEnumT%%%`))

        3. Else Phantom#805 ((expr'' matches pattern `TypeAccE%%`)) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type monotypdef)) /\ (~(typ' has type datatyp))

      2. Else Phantom#806 ((expr'' matches pattern `TypeAccE%%`)) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ (~(typdef has type monotypdef))

    3. Else Phantom#807 ((expr'' matches pattern `TypeAccE%%`)) /\ (~(typdef'?{typdef' <- typdef'?} matches pattern (_)))

  21. Case (% matches pattern `ExprAccE%%`)

    1. (Let (ExprAccE expr_b text) be expr'')

    2. Case analysis on text

      1. Case (% = "size")

        1. (Expr_ok: p' C |- expr_b : exprIL_b)

        2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

        3. (Let typ be $canon_typ(typ_b))

        4. If ((typ has type datatyp)), then

          1. (Let datatyp be (typ as datatyp))

          2. If ((datatyp matches pattern `StackT%%`)), then

            1. (Let (StackT typ_s int_s) be datatyp)

            2. Result in (ExprAccE exprIL_b "size" (( ((FBitT 32) as typ) ; (LCTK) )))

          2. Else Phantom#808 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "size")) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `StackT%%`))

        4. Else Phantom#809 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "size")) /\ (~(typ has type datatyp))

      2. Case (% = "lastIndex")

        1. If ((((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))), then

          1. (Expr_ok: p' C |- expr_b : exprIL_b)

          2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

          3. (Let typ be $canon_typ(typ_b))

          4. If ((typ has type datatyp)), then

            1. (Let datatyp be (typ as datatyp))

            2. If ((datatyp matches pattern `StackT%%`)), then

              1. (Let (StackT typ_s int_s) be datatyp)

              2. Result in (ExprAccE exprIL_b "lastIndex" (( ((FBitT 32) as typ) ; (DYN) )))

            2. Else Phantom#810 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "lastIndex")) /\ ((((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `StackT%%`))

          4. Else Phantom#811 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "lastIndex")) /\ ((((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))) /\ (~(typ has type datatyp))

        1. Else Phantom#812 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "lastIndex")) /\ (~(((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE)))))

      3. Case (% = "last")

        1. If ((((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))), then

          1. (Expr_ok: p' C |- expr_b : exprIL_b)

          2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

          3. (Let typ be $canon_typ(typ_b))

          4. If ((typ has type datatyp)), then

            1. (Let datatyp be (typ as datatyp))

            2. If ((datatyp matches pattern `StackT%%`)), then

              1. (Let (StackT typ_s int_s) be datatyp)

              2. Result in (ExprAccE exprIL_b "last" (( typ_s ; (DYN) )))

            2. Else Phantom#813 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "last")) /\ ((((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `StackT%%`))

          4. Else Phantom#814 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "last")) /\ ((((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))) /\ (~(typ has type datatyp))

        1. Else Phantom#815 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "last")) /\ (~(((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE)))))

      4. Case (% = "next")

        1. (Expr_ok: p' C |- expr_b : exprIL_b)

        2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

        3. (Let typ be $canon_typ(typ_b))

        4. If ((typ has type datatyp)), then

          1. (Let datatyp be (typ as datatyp))

          2. If ((datatyp matches pattern `StackT%%`)), then

            1. (Let (StackT typ_s int_s) be datatyp)

            2. Result in (ExprAccE exprIL_b "next" (( typ_s ; (DYN) )))

          2. Else Phantom#816 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "next")) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `StackT%%`))

        4. Else Phantom#817 ((expr'' matches pattern `ExprAccE%%`)) /\ ((text = "next")) /\ (~(typ has type datatyp))

    2. Else Phantom#818 ((expr'' matches pattern `ExprAccE%%`)) /\ (~(text = "size")) /\ (~(text = "lastIndex")) /\ (~(text = "last")) /\ (~(text = "next"))

    3. (Let (ExprAccE expr_b member) be expr'')

    4. (Expr_ok: p' C |- expr_b : exprIL_b)

    5. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

    6. (Let typ' be $canon_typ(typ_b))

    7. Case analysis on typ'

      1. Case (% has type datatyp)

        1. (Let datatyp be (typ' as datatyp))

        2. Case analysis on datatyp

          1. Case (% matches pattern `StructT%%`)

            1. (Let (StructT id_s (member_s, typ_s)*{member_s <- member_s*, typ_s <- typ_s*}) be datatyp)

            2. (Let typ''?{typ'' <- typ''?} be $assoc_<member, typ>(member, (member_s, typ_s)*{member_s <- member_s*, typ_s <- typ_s*}))

            3. If ((typ''?{typ'' <- typ''?} matches pattern (_))), then

              1. (Let ?(typ) be typ''?{typ'' <- typ''?})

              2. Result in (ExprAccE exprIL_b member (( typ ; (DYN) )))

            3. Else Phantom#819 ((expr'' matches pattern `ExprAccE%%`)) /\ ((typ' has type datatyp)) /\ ((datatyp matches pattern `StructT%%`)) /\ (~(typ''?{typ'' <- typ''?} matches pattern (_)))

          2. Case (% matches pattern `HeaderT%%`)

            1. (Let (HeaderT id_h (member_h, typ_h)*{member_h <- member_h*, typ_h <- typ_h*}) be datatyp)

            2. (Let typ''?{typ'' <- typ''?} be $assoc_<member, typ>(member, (member_h, typ_h)*{member_h <- member_h*, typ_h <- typ_h*}))

            3. If ((typ''?{typ'' <- typ''?} matches pattern (_))), then

              1. (Let ?(typ) be typ''?{typ'' <- typ''?})

              2. Result in (ExprAccE exprIL_b member (( typ ; (DYN) )))

            3. Else Phantom#820 ((expr'' matches pattern `ExprAccE%%`)) /\ ((typ' has type datatyp)) /\ ((datatyp matches pattern `HeaderT%%`)) /\ (~(typ''?{typ'' <- typ''?} matches pattern (_)))

          3. Case (% matches pattern `UnionT%%`)

            1. (Let (UnionT id_u (member_u, typ_u)*{member_u <- member_u*, typ_u <- typ_u*}) be datatyp)

            2. (Let typ''?{typ'' <- typ''?} be $assoc_<member, typ>(member, (member_u, typ_u)*{member_u <- member_u*, typ_u <- typ_u*}))

            3. If ((typ''?{typ'' <- typ''?} matches pattern (_))), then

              1. (Let ?(typ) be typ''?{typ'' <- typ''?})

              2. Result in (ExprAccE exprIL_b member (( typ ; (DYN) )))

            3. Else Phantom#821 ((expr'' matches pattern `ExprAccE%%`)) /\ ((typ' has type datatyp)) /\ ((datatyp matches pattern `UnionT%%`)) /\ (~(typ''?{typ'' <- typ''?} matches pattern (_)))

        2. Else Phantom#822 ((expr'' matches pattern `ExprAccE%%`)) /\ ((typ' has type datatyp)) /\ (~(datatyp matches pattern `StructT%%`)) /\ (~(datatyp matches pattern `HeaderT%%`)) /\ (~(datatyp matches pattern `UnionT%%`))

      2. Case (% has type synthtyp)

        1. (Let synthtyp be (typ' as synthtyp))

        2. If ((synthtyp matches pattern `TableStructT%%`)), then

          1. (Let (TableStructT id_t (member_t, typ_t)*{member_t <- member_t*, typ_t <- typ_t*}) be synthtyp)

          2. (Let typ''?{typ'' <- typ''?} be $assoc_<member, typ>(member, (member_t, typ_t)*{member_t <- member_t*, typ_t <- typ_t*}))

          3. If ((typ''?{typ'' <- typ''?} matches pattern (_))), then

            1. (Let ?(typ) be typ''?{typ'' <- typ''?})

            2. Result in (ExprAccE exprIL_b member (( typ ; (DYN) )))

          3. Else Phantom#823 ((expr'' matches pattern `ExprAccE%%`)) /\ ((typ' has type synthtyp)) /\ ((synthtyp matches pattern `TableStructT%%`)) /\ (~(typ''?{typ'' <- typ''?} matches pattern (_)))

        2. Else Phantom#824 ((expr'' matches pattern `ExprAccE%%`)) /\ ((typ' has type synthtyp)) /\ (~(synthtyp matches pattern `TableStructT%%`))

    7. Else Phantom#825 ((expr'' matches pattern `ExprAccE%%`)) /\ (~(typ' has type datatyp)) /\ (~(typ' has type synthtyp))

  22. Case (% matches pattern `CallFuncE%%%`)

    1. (Let (CallFuncE name targ*{targ <- targ*} arg*{arg <- arg*}) be expr'')

    2. (Type_ok: p' C |- targ : targIL tid_fresh_a*{tid_fresh_a <- tid_fresh_a*})*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}

    3. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**}))

    4. (FuncType_ok: p' C |- name targIL*{targIL <- targIL*} arg*{arg <- arg*} : ft tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} id_deft*{id_deft <- id_deft*})

    5. (Let tid_fresh'*{tid_fresh' <- tid_fresh'*} be $concat_<tid>(tid_fresh*{tid_fresh <- tid_fresh*} :: [tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}]))

    6. (Call_ok: p' C tid_fresh'*{tid_fresh' <- tid_fresh'*} |- ft targIL*{targIL <- targIL*} arg*{arg <- arg*} id_deft*{id_deft <- id_deft*} : typ targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

    7. If ((typ =/= ((VoidT) as typ))), then

      1. Result in (CallFuncE name targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*} (( typ ; (DYN) )))

    7. Else Phantom#826 ((expr'' matches pattern `CallFuncE%%%`)) /\ (~(typ =/= ((VoidT) as typ)))

  23. Case (% matches pattern `CallMethodE%%%%`)

    1. (Let (CallMethodE expr_b member targ*{targ <- targ*} arg*{arg <- arg*}) be expr'')

    2. If ((targ*{targ <- targ*} matches pattern [])), then

      1. If ((arg*{arg <- arg*} matches pattern [])), then

        1. If (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

          1. (MethodType_ok: p' C |- expr_b member [] [] : ft exprIL_b tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} id_deft*{id_deft <- id_deft*})

          2. (Call_ok: p' C [] |- ft [] [] [] : typ targIL*{targIL <- targIL*} argIL*{argIL <- argIL*})

          3. If ((typ = ((IntT) as typ))), then

            1. If ((targIL*{targIL <- targIL*} matches pattern [])), then

              1. If ((argIL*{argIL <- argIL*} matches pattern [])), then

                1. Result in (CallMethodE exprIL_b member [] [] (( ((IntT) as typ) ; (LCTK) )))

              1. Else Phantom#827 ((expr'' matches pattern `CallMethodE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]) /\ ((typ = ((IntT) as typ))) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(argIL*{argIL <- argIL*} matches pattern []))

            1. Else Phantom#828 ((expr'' matches pattern `CallMethodE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]) /\ ((typ = ((IntT) as typ))) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

          3. Else Phantom#829 ((expr'' matches pattern `CallMethodE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]) /\ (~(typ = ((IntT) as typ)))

        1. Else Phantom#830 ((expr'' matches pattern `CallMethodE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ (~member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])

      1. Else Phantom#831 ((expr'' matches pattern `CallMethodE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ (~(arg*{arg <- arg*} matches pattern []))

    2. Else Phantom#832 ((expr'' matches pattern `CallMethodE%%%%`)) /\ (~(targ*{targ <- targ*} matches pattern []))

    3. If (~member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. (Type_ok: p' C |- targ : targIL tid_fresh_a*{tid_fresh_a <- tid_fresh_a*})*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}

      2. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**}))

      3. (MethodType_ok: p' C |- expr_b member targIL*{targIL <- targIL*} arg*{arg <- arg*} : ft exprIL_b tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} id_deft*{id_deft <- id_deft*})

      4. (Let tid_fresh'*{tid_fresh' <- tid_fresh'*} be $concat_<tid>([tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}]))

      5. (Call_ok: p' C tid_fresh'*{tid_fresh' <- tid_fresh'*} |- ft targIL*{targIL <- targIL*} arg*{arg <- arg*} id_deft*{id_deft <- id_deft*} : typ targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

      6. If ((typ =/= ((VoidT) as typ))), then

        1. Result in (CallMethodE exprIL_b member targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*} (( typ ; (DYN) )))

      6. Else Phantom#833 ((expr'' matches pattern `CallMethodE%%%%`)) /\ (~member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]) /\ (~(typ =/= ((VoidT) as typ)))

    3. Else Phantom#834 ((expr'' matches pattern `CallMethodE%%%%`)) /\ (~~member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])

  24. Case (% matches pattern `CallTypeE%%%%`)

    1. (Let (CallTypeE name member targ*{targ <- targ*} arg*{arg <- arg*}) be expr'')

    2. If ((targ*{targ <- targ*} matches pattern [])), then

      1. If ((arg*{arg <- arg*} matches pattern [])), then

        1. (Let typdef'?{typdef' <- typdef'?} be $find_typdef(p', C, name))

        2. If ((typdef'?{typdef' <- typdef'?} matches pattern (_))), then

          1. (Let ?(typdef) be typdef'?{typdef' <- typdef'?})

          2. If (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

            1. (Let ft be (BuiltinMethodT [] ((IntT) as typ)))

            2. (Call_ok: p' C [] |- ft [] [] [] : typ targIL*{targIL <- targIL*} argIL*{argIL <- argIL*})

            3. If ((typ = ((IntT) as typ))), then

              1. If ((targIL*{targIL <- targIL*} matches pattern [])), then

                1. If ((argIL*{argIL <- argIL*} matches pattern [])), then

                  1. Result in (CallTypeE name member [] [] (( ((IntT) as typ) ; (LCTK) )))

                1. Else Phantom#835 ((expr'' matches pattern `CallTypeE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]) /\ ((typ = ((IntT) as typ))) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(argIL*{argIL <- argIL*} matches pattern []))

              1. Else Phantom#836 ((expr'' matches pattern `CallTypeE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]) /\ ((typ = ((IntT) as typ))) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

            3. Else Phantom#837 ((expr'' matches pattern `CallTypeE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]) /\ (~(typ = ((IntT) as typ)))

          2. Else Phantom#838 ((expr'' matches pattern `CallTypeE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ (~member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])

        2. Else Phantom#839 ((expr'' matches pattern `CallTypeE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ (~(typdef'?{typdef' <- typdef'?} matches pattern (_)))

      1. Else Phantom#840 ((expr'' matches pattern `CallTypeE%%%%`)) /\ ((targ*{targ <- targ*} matches pattern [])) /\ (~(arg*{arg <- arg*} matches pattern []))

    2. Else Phantom#841 ((expr'' matches pattern `CallTypeE%%%%`)) /\ (~(targ*{targ <- targ*} matches pattern []))

  25. Case (% matches pattern `InstE%%%`)

    1. (Let (InstE name targ*{targ <- targ*} arg*{arg <- arg*}) be expr'')

    2. (Type_ok: p' C |- targ : targIL tid_fresh_a*{tid_fresh_a <- tid_fresh_a*})*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}

    3. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**}))

    4. (ConsType_ok: p' C |- name targIL*{targIL <- targIL*} arg*{arg <- arg*} : ct tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} id_deft*{id_deft <- id_deft*})

    5. (Let tid_fresh'*{tid_fresh' <- tid_fresh'*} be $concat_<tid>([tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}]))

    6. (Inst_ok: p' C tid_fresh'*{tid_fresh' <- tid_fresh'*} |- ct targIL*{targIL <- targIL*} arg*{arg <- arg*} id_deft*{id_deft <- id_deft*} : typ targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

    7. If ($not_abstract_extern_object(typ)), then

      1. Result in (InstE name targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*} (( typ ; (CTK) )))

    7. Else Phantom#842 ((expr'' matches pattern `InstE%%%`)) /\ (~$not_abstract_extern_object(typ))

1. Else Phantom#843 (~(expr'' matches pattern `BoolE%`)) /\ (~(expr'' matches pattern `StrE%`)) /\ (~(expr'' matches pattern `NumE%`)) /\ (~(expr'' matches pattern `NameE%`)) /\ (~(expr'' matches pattern `SeqE%`)) /\ (~(expr'' matches pattern `SeqDefaultE%`)) /\ (~(expr'' matches pattern `RecordE%`)) /\ (~(expr'' matches pattern `RecordDefaultE%`)) /\ (~(expr'' matches pattern `DefaultE`)) /\ (~(expr'' matches pattern `InvalidE`)) /\ (~(expr'' matches pattern `UnE%%`)) /\ (~(expr'' matches pattern `BinE%%%`)) /\ (~(expr'' matches pattern `TernE%%%`)) /\ (~(expr'' matches pattern `CastE%%`)) /\ (~(expr'' matches pattern `MaskE%%`)) /\ (~(expr'' matches pattern `RangeE%%`)) /\ (~(expr'' matches pattern `ArrAccE%%`)) /\ (~(expr'' matches pattern `BitAccE%%%`)) /\ (~(expr'' matches pattern `ErrAccE%`)) /\ (~(expr'' matches pattern `TypeAccE%%`)) /\ (~(expr'' matches pattern `ExprAccE%%`)) /\ (~(expr'' matches pattern `CallFuncE%%%`)) /\ (~(expr'' matches pattern `CallMethodE%%%%`)) /\ (~(expr'' matches pattern `CallTypeE%%%%`)) /\ (~(expr'' matches pattern `InstE%%%`))

2. If ((p' matches pattern `LOCAL`)), then

  1. If ((expr'' matches pattern `SelectE%%`)), then

    1. (Let (SelectE expr_k*{expr_k <- expr_k*} selectcase*{selectcase <- selectcase*}) be expr'')

    2. If ((C.LOCAL.KIND matches pattern `PARSERSTATE`)), then

      1. (Expr_ok: (LOCAL) C |- expr_k : exprIL_k)*{exprIL_k <- exprIL_k*, expr_k <- expr_k*}

      2. (Let (( typ_k ; ctk_k )) be $annot(exprIL_k))*{ctk_k <- ctk_k*, exprIL_k <- exprIL_k*, typ_k <- typ_k*}

      3. If ((Type_wf: $bound_tids((LOCAL), C) |- ((SetT typ_k) as typ) holds))*{typ_k <- typ_k*}, then

        1. (Select_case_ok: (LOCAL) C typ_k*{typ_k <- typ_k*} |- selectcase : selectcaseIL)*{selectcase <- selectcase*, selectcaseIL <- selectcaseIL*}

        2. Result in (SelectE exprIL_k*{exprIL_k <- exprIL_k*} selectcaseIL*{selectcaseIL <- selectcaseIL*} (( ((StateT) as typ) ; (DYN) )))

      3. Else Phantom#844 ((p' matches pattern `LOCAL`)) /\ ((expr'' matches pattern `SelectE%%`)) /\ ((C.LOCAL.KIND matches pattern `PARSERSTATE`)) /\ (exists ~(Type_wf: $bound_tids((LOCAL), C) |- ((SetT typ_k) as typ) holds))*{typ_k <- typ_k*}

    2. Else Phantom#845 ((p' matches pattern `LOCAL`)) /\ ((expr'' matches pattern `SelectE%%`)) /\ (~(C.LOCAL.KIND matches pattern `PARSERSTATE`))

  1. Else Phantom#846 ((p' matches pattern `LOCAL`)) /\ (~(expr'' matches pattern `SelectE%%`))

2. Else Phantom#847 (~(p' matches pattern `LOCAL`))

;; ../../../../spec/4b-typing-relation.watsup:81.1-83.23
relation Arg_ok: p, C, arg

1. Case analysis on arg

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA expr) be arg)

    2. (Expr_ok: p C |- expr : exprIL)

    3. (Let (( typ ; _ctk )) be $annot(exprIL))

    4. Result in (ExprA exprIL), typ

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA id expr'?{expr' <- expr'?}) be arg)

    2. If ((expr'?{expr' <- expr'?} matches pattern (_))), then

      1. (Let ?(expr) be expr'?{expr' <- expr'?})

      2. (Expr_ok: p C |- expr : exprIL)

      3. (Let (( typ ; _ctk )) be $annot(exprIL))

      4. Result in (NameA id ?(exprIL)), typ

    2. Else Phantom#848 ((arg matches pattern `NameA%%`)) /\ (~(expr'?{expr' <- expr'?} matches pattern (_)))

    3. (Let (NameA id expr?{expr <- expr?}) be arg)

    4. If ((expr?{expr <- expr?} matches pattern ())), then

      1. Result in (NameA id ?()), ((AnyT) as typ)

    4. Else Phantom#849 ((arg matches pattern `NameA%%`)) /\ (~(expr?{expr <- expr?} matches pattern ()))

  3. Case (% matches pattern `AnyA`)

    1. Result in (AnyA), ((AnyT) as typ)

;; ../../../../spec/4b-typing-relation.watsup:86.1-88.23
relation Lval_ok: p, C, exprIL

1. Case analysis on exprIL

  1. Case (% matches pattern `NameE%%`)

    1. (Let (NameE name _annotIL) be exprIL)

    2. (Let styp?{styp <- styp?} be $find_styp(p, C, name))

    3. If ((styp?{styp <- styp?} matches pattern (_))), then

      1. (Let ?((typ dir _ctk _val?{_val <- _val?})) be styp?{styp <- styp?})

      2. If (((dir = (OUT)) \/ (dir = (INOUT)))), then

        1. If ($is_assignable(typ)), then

          1. The relation holds

        1. Else Phantom#850 ((exprIL matches pattern `NameE%%`)) /\ ((styp?{styp <- styp?} matches pattern (_))) /\ (((dir = (OUT)) \/ (dir = (INOUT)))) /\ (~$is_assignable(typ))

      2. Else Phantom#851 ((exprIL matches pattern `NameE%%`)) /\ ((styp?{styp <- styp?} matches pattern (_))) /\ (~((dir = (OUT)) \/ (dir = (INOUT))))

    3. Else Phantom#852 ((exprIL matches pattern `NameE%%`)) /\ (~(styp?{styp <- styp?} matches pattern (_)))

  2. Case (% matches pattern `ArrAccE%%%`)

    1. (Let (ArrAccE exprIL_b exprIL_i _annotIL) be exprIL)

    2. If ((Lval_ok: p C |- exprIL_b holds)), then

      1. The relation holds

    2. Else Phantom#853 ((exprIL matches pattern `ArrAccE%%%`)) /\ (~(Lval_ok: p C |- exprIL_b holds))

  3. Case (% matches pattern `BitAccE%%%%`)

    1. (Let (BitAccE exprIL_b exprIL_l exprIL_h _annotIL) be exprIL)

    2. If ((Lval_ok: p C |- exprIL_b holds)), then

      1. The relation holds

    2. Else Phantom#854 ((exprIL matches pattern `BitAccE%%%%`)) /\ (~(Lval_ok: p C |- exprIL_b holds))

  4. Case (% matches pattern `ExprAccE%%%`)

    1. (Let (ExprAccE exprIL_b member _annotIL) be exprIL)

    2. If ((Lval_ok: p C |- exprIL_b holds)), then

      1. The relation holds

    2. Else Phantom#855 ((exprIL matches pattern `ExprAccE%%%`)) /\ (~(Lval_ok: p C |- exprIL_b holds))

1. Else Phantom#856 (~(exprIL matches pattern `NameE%%`)) /\ (~(exprIL matches pattern `ArrAccE%%%`)) /\ (~(exprIL matches pattern `BitAccE%%%%`)) /\ (~(exprIL matches pattern `ExprAccE%%%`))

;; ../../../../spec/4b-typing-relation.watsup:93.18-93.31
syntax blkctxt = 
   | `INIT`()
   | `NOINIT`()

;; ../../../../spec/4b-typing-relation.watsup:94.1-96.29
relation Block_ok: cursor, C, f, blkctxt, (BlockB stmt*{stmt <- stmt*})

1. If ((cursor matches pattern `LOCAL`)), then

  1. Case analysis on blkctxt

    1. Case (% matches pattern `INIT`)

      1. (Stmts_ok: (LOCAL) C f |- stmt*{stmt <- stmt*} : C' f' stmtIL*{stmtIL <- stmtIL*})

      2. Result in C', f', (BlockB stmtIL*{stmtIL <- stmtIL*})

    2. Case (% matches pattern `NOINIT`)

      1. (Let C' be $enter(C))

      2. (Stmts_ok: (LOCAL) C' f |- stmt*{stmt <- stmt*} : C'' f' stmtIL*{stmtIL <- stmtIL*})

      3. (Let C''' be $exit(C''))

      4. Result in C''', f', (BlockB stmtIL*{stmtIL <- stmtIL*})

1. Else Phantom#857 (~(cursor matches pattern `LOCAL`))

;; ../../../../spec/4b-typing-relation.watsup:97.1-99.26
relation Stmt_ok: p', C, f, stmt

1. Case analysis on stmt

  1. Case (% matches pattern `EmptyS`)

    1. Result in C, f, (EmptyS)

  2. Case (% matches pattern `AssignS%%`)

    1. (Let (AssignS expr_l expr_r) be stmt)

    2. (Expr_ok: p' C |- expr_l : exprIL_l)

    3. (Let (( typ_l ; ctk )) be $annot(exprIL_l))

    4. If ((ctk matches pattern `DYN`)), then

      1. If ((Lval_ok: p' C |- exprIL_l holds)), then

        1. (Expr_ok: p' C |- expr_r : exprIL_r)

        2. (Let (( typ_r ; _ctk )) be $annot(exprIL_r))

        3. (Let exprIL_r' be $coerce_assign(exprIL_r, typ_l))

        4. Result in C, f, (AssignS exprIL_l exprIL_r')

      1. Else Phantom#858 ((stmt matches pattern `AssignS%%`)) /\ ((ctk matches pattern `DYN`)) /\ (~(Lval_ok: p' C |- exprIL_l holds))

    4. Else Phantom#859 ((stmt matches pattern `AssignS%%`)) /\ (~(ctk matches pattern `DYN`))

  3. Case (% matches pattern `IfS%%%`)

    1. (Let (IfS expr_c stmt_t stmt_f) be stmt)

    2. (Expr_ok: p' C |- expr_c : exprIL_c)

    3. (Let (( typ ; _ctk )) be $annot(exprIL_c))

    4. If ((typ = ((BoolT) as typ))), then

      1. (Stmt_ok: p' C f |- stmt_t : C_t f_t stmtIL_t)

      2. (Stmt_ok: p' C f |- stmt_f : C_f f_f stmtIL_f)

      3. (Let f' be $join_flow(f_t, f_f))

      4. Result in C, f', (IfS exprIL_c stmtIL_t stmtIL_f)

    4. Else Phantom#860 ((stmt matches pattern `IfS%%%`)) /\ (~(typ = ((BoolT) as typ)))

  4. Case (% matches pattern `ExitS`)

    1. Result in C, f, (ExitS)

  5. Case (% matches pattern `CallFuncS%%%`)

    1. (Let (CallFuncS name targ*{targ <- targ*} arg*{arg <- arg*}) be stmt)

    2. If (((name = (CURRENT "verify")) => (((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE)))))), then

      1. (Type_ok: p' C |- targ : targIL tid_fresh_a*{tid_fresh_a <- tid_fresh_a*})*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}

      2. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**}))

      3. (FuncType_ok: p' C |- name targIL*{targIL <- targIL*} arg*{arg <- arg*} : ft tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} id_deft*{id_deft <- id_deft*})

      4. (Let tid_fresh'*{tid_fresh' <- tid_fresh'*} be $concat_<tid>([tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}]))

      5. (Call_ok: p' C tid_fresh'*{tid_fresh' <- tid_fresh'*} |- ft targIL*{targIL <- targIL*} arg*{arg <- arg*} id_deft*{id_deft <- id_deft*} : typ targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

      6. Result in C, f, (CallFuncS name targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

    2. Else Phantom#861 ((stmt matches pattern `CallFuncS%%%`)) /\ (~((name = (CURRENT "verify")) => (((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))))

  6. Case (% matches pattern `CallMethodS%%%%`)

    1. (Let (CallMethodS expr_b member targ*{targ <- targ*} arg*{arg <- arg*}) be stmt)

    2. (Arg_ok: p' C |- arg : argIL typ_arg)*{arg <- arg*, argIL <- argIL*, typ_arg <- typ_arg*}

    3. (Type_ok: p' C |- targ : targIL tid_fresh_a*{tid_fresh_a <- tid_fresh_a*})*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}

    4. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**}))

    5. (MethodType_ok: p' C |- expr_b member targIL*{targIL <- targIL*} arg*{arg <- arg*} : ft exprIL_b tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} id_deft*{id_deft <- id_deft*})

    6. (Let tid_fresh'*{tid_fresh' <- tid_fresh'*} be $concat_<tid>([tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*}]))

    7. (Call_ok: p' C tid_fresh'*{tid_fresh' <- tid_fresh'*} |- ft targIL*{targIL <- targIL*} arg*{arg <- arg*} id_deft*{id_deft <- id_deft*} : typ targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

    8. Result in C, f, (CallMethodS exprIL_b member targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

  7. Case (% matches pattern `CallInstS%%%`)

    1. (Let (CallInstS name targ*{targ <- targ*} arg*{arg <- arg*}) be stmt)

    2. (ConsType_ok: p' C |- name [] [] : ct tid*{tid <- tid*} id'*{id' <- id'*})

    3. If ((tid*{tid <- tid*} matches pattern [])), then

      1. If ((id'*{id' <- id'*} matches pattern [])), then

        1. (Inst_ok: p' C [] |- ct [] [] [] : typ targIL*{targIL <- targIL*} argIL*{argIL <- argIL*})

        2. If ((targIL*{targIL <- targIL*} matches pattern [])), then

          1. If ((argIL*{argIL <- argIL*} matches pattern [])), then

            1. (Let typ' be $canon_typ(typ))

            2. If (($is_parsert(typ') \/ $is_controlt(typ'))), then

              1. (Let id be $id_of_name(name))

              2. (Let C' be $add_styp(p', C, id, (typ (NO) (CTK) ?())))

              3. (Stmt_ok: p' C' f |- (CallMethodS (NameE (CURRENT id)) "apply" targ*{targ <- targ*} arg*{arg <- arg*}) : C'' f' stmtIL)

              4. (Let stmtIL' be stmtIL)

              5. If ((stmtIL' matches pattern `CallMethodS%%%%`)), then

                1. (Let (CallMethodS exprIL text targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*}) be stmtIL')

                2. If ((exprIL matches pattern `NameE%%`)), then

                  1. (Let (NameE name' _annotIL) be exprIL)

                  2. If ((name' = (CURRENT id))), then

                    1. If ((text = "apply")), then

                      1. Result in C, f, (CallInstS typ name targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

                    1. Else Phantom#862 ((stmt matches pattern `CallInstS%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((id'*{id' <- id'*} matches pattern [])) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((argIL*{argIL <- argIL*} matches pattern [])) /\ (($is_parsert(typ') \/ $is_controlt(typ'))) /\ ((stmtIL' matches pattern `CallMethodS%%%%`)) /\ ((exprIL matches pattern `NameE%%`)) /\ ((name' = (CURRENT id))) /\ (~(text = "apply"))

                  2. Else Phantom#863 ((stmt matches pattern `CallInstS%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((id'*{id' <- id'*} matches pattern [])) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((argIL*{argIL <- argIL*} matches pattern [])) /\ (($is_parsert(typ') \/ $is_controlt(typ'))) /\ ((stmtIL' matches pattern `CallMethodS%%%%`)) /\ ((exprIL matches pattern `NameE%%`)) /\ (~(name' = (CURRENT id)))

                2. Else Phantom#864 ((stmt matches pattern `CallInstS%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((id'*{id' <- id'*} matches pattern [])) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((argIL*{argIL <- argIL*} matches pattern [])) /\ (($is_parsert(typ') \/ $is_controlt(typ'))) /\ ((stmtIL' matches pattern `CallMethodS%%%%`)) /\ (~(exprIL matches pattern `NameE%%`))

              5. Else Phantom#865 ((stmt matches pattern `CallInstS%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((id'*{id' <- id'*} matches pattern [])) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((argIL*{argIL <- argIL*} matches pattern [])) /\ (($is_parsert(typ') \/ $is_controlt(typ'))) /\ (~(stmtIL' matches pattern `CallMethodS%%%%`))

            2. Else Phantom#866 ((stmt matches pattern `CallInstS%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((id'*{id' <- id'*} matches pattern [])) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((argIL*{argIL <- argIL*} matches pattern [])) /\ (~($is_parsert(typ') \/ $is_controlt(typ')))

          1. Else Phantom#867 ((stmt matches pattern `CallInstS%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((id'*{id' <- id'*} matches pattern [])) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(argIL*{argIL <- argIL*} matches pattern []))

        2. Else Phantom#868 ((stmt matches pattern `CallInstS%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((id'*{id' <- id'*} matches pattern [])) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

      1. Else Phantom#869 ((stmt matches pattern `CallInstS%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(id'*{id' <- id'*} matches pattern []))

    3. Else Phantom#870 ((stmt matches pattern `CallInstS%%%`)) /\ (~(tid*{tid <- tid*} matches pattern []))

  8. Case (% matches pattern `TransS%`)

    1. (Let (TransS expr) be stmt)

    2. (Expr_ok: p' C |- expr : exprIL)

    3. (Let (( typ ; _ctk )) be $annot(exprIL))

    4. If ((typ = ((StateT) as typ))), then

      1. Result in C, f, (TransS exprIL)

    4. Else Phantom#871 ((stmt matches pattern `TransS%`)) /\ (~(typ = ((StateT) as typ)))

  9. Case (% matches pattern `DeclS%`)

    1. (Let (DeclS decl) be stmt)

    2. (Decl_ok: p' C |- decl : C' declIL)

    3. Result in C', f, (DeclS declIL)

1. Else Phantom#872 (~(stmt matches pattern `EmptyS`)) /\ (~(stmt matches pattern `AssignS%%`)) /\ (~(stmt matches pattern `IfS%%%`)) /\ (~(stmt matches pattern `ExitS`)) /\ (~(stmt matches pattern `CallFuncS%%%`)) /\ (~(stmt matches pattern `CallMethodS%%%%`)) /\ (~(stmt matches pattern `CallInstS%%%`)) /\ (~(stmt matches pattern `TransS%`)) /\ (~(stmt matches pattern `DeclS%`))

2. If ((p' matches pattern `LOCAL`)), then

  1. Case analysis on stmt

    1. Case (% matches pattern `SwitchS%%`)

      1. (Let (SwitchS expr switchcase*{switchcase <- switchcase*}) be stmt)

      2. If ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)), then

        1. (Expr_ok: (LOCAL) C |- expr : exprIL)

        2. (Let (( typ ; _ctk )) be $annot(exprIL))

        3. If ((typ has type synthtyp)), then

          1. (Let synthtyp be (typ as synthtyp))

          2. If ((synthtyp matches pattern `TableEnumT%%`)), then

            1. (Let (TableEnumT id _member*{_member <- _member*}) be synthtyp)

            2. (Let id_t be $strip_prefix($strip_suffix(id, ")"), "action_list("))

            3. (Switch_tbl_cases_ok: (LOCAL) C f id_t |- switchcase*{switchcase <- switchcase*} : f' switchcaseIL*{switchcaseIL <- switchcaseIL*} switchlabel*{switchlabel <- switchlabel*})

            4. If ($distinct_<switchlabel>(switchlabel*{switchlabel <- switchlabel*})), then

              1. Result in C, f', (SwitchS exprIL switchcaseIL*{switchcaseIL <- switchcaseIL*})

            4. Else Phantom#873 ((p' matches pattern `LOCAL`)) /\ ((stmt matches pattern `SwitchS%%`)) /\ ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)) /\ ((typ has type synthtyp)) /\ ((synthtyp matches pattern `TableEnumT%%`)) /\ (~$distinct_<switchlabel>(switchlabel*{switchlabel <- switchlabel*}))

          2. Else Phantom#874 ((p' matches pattern `LOCAL`)) /\ ((stmt matches pattern `SwitchS%%`)) /\ ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)) /\ ((typ has type synthtyp)) /\ (~(synthtyp matches pattern `TableEnumT%%`))

        3. Else Phantom#875 ((p' matches pattern `LOCAL`)) /\ ((stmt matches pattern `SwitchS%%`)) /\ ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)) /\ (~(typ has type synthtyp))

        4. (Let typ' be $canon_typ(typ))

        5. If ((((($is_errt(typ') \/ $is_fintt(typ')) \/ $is_fbitt(typ')) \/ $is_enumt(typ')) \/ $is_senumt(typ'))), then

          1. (Switch_gen_cases_ok: (LOCAL) C f typ |- switchcase*{switchcase <- switchcase*} : f' switchcaseIL*{switchcaseIL <- switchcaseIL*} switchlabel*{switchlabel <- switchlabel*})

          2. If ($distinct_<switchlabel>(switchlabel*{switchlabel <- switchlabel*})), then

            1. Result in C, f', (SwitchS exprIL switchcaseIL*{switchcaseIL <- switchcaseIL*})

          2. Else Phantom#876 ((p' matches pattern `LOCAL`)) /\ ((stmt matches pattern `SwitchS%%`)) /\ ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)) /\ ((((($is_errt(typ') \/ $is_fintt(typ')) \/ $is_fbitt(typ')) \/ $is_enumt(typ')) \/ $is_senumt(typ'))) /\ (~$distinct_<switchlabel>(switchlabel*{switchlabel <- switchlabel*}))

        5. Else Phantom#877 ((p' matches pattern `LOCAL`)) /\ ((stmt matches pattern `SwitchS%%`)) /\ ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)) /\ (~(((($is_errt(typ') \/ $is_fintt(typ')) \/ $is_fbitt(typ')) \/ $is_enumt(typ')) \/ $is_senumt(typ')))

      2. Else Phantom#878 ((p' matches pattern `LOCAL`)) /\ ((stmt matches pattern `SwitchS%%`)) /\ (~(C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`))

    2. Case (% matches pattern `BlockS%`)

      1. (Let (BlockS block) be stmt)

      2. (Block_ok: (LOCAL) C f (NOINIT) |- block : C' f' blockIL)

      3. Result in C', f', (BlockS blockIL)

    3. Case (% matches pattern `RetS%`)

      1. (Let (RetS expr'?{expr' <- expr'?}) be stmt)

      2. If ((expr'?{expr' <- expr'?} matches pattern (_))), then

        1. (Let ?(expr) be expr'?{expr' <- expr'?})

        2. (Expr_ok: (LOCAL) C |- expr : exprIL)

        3. (Let typ_r be $get_typ_ret_lkind(C.LOCAL.KIND))

        4. (Let exprIL' be $coerce_assign(exprIL, typ_r))

        5. Result in C, (RET), (RetS ?(exprIL'))

      2. Else Phantom#879 ((p' matches pattern `LOCAL`)) /\ ((stmt matches pattern `RetS%`)) /\ (~(expr'?{expr' <- expr'?} matches pattern (_)))

  1. Else Phantom#880 ((p' matches pattern `LOCAL`)) /\ (~(stmt matches pattern `SwitchS%%`)) /\ (~(stmt matches pattern `BlockS%`)) /\ (~(stmt matches pattern `RetS%`))

  2. If ((stmt = (RetS ?()))), then

    1. If ((((VoidT) as typ) = $get_typ_ret_lkind(C.LOCAL.KIND))), then

      1. Result in C, (RET), (RetS ?())

    1. Else Phantom#881 ((p' matches pattern `LOCAL`)) /\ ((stmt = (RetS ?()))) /\ (~(((VoidT) as typ) = $get_typ_ret_lkind(C.LOCAL.KIND)))

  2. Else Phantom#882 ((p' matches pattern `LOCAL`)) /\ (~(stmt = (RetS ?())))

2. Else Phantom#883 (~(p' matches pattern `LOCAL`))

;; ../../../../spec/4b-typing-relation.watsup:100.1-102.26
relation Stmts_ok: p, C, f, stmt*{stmt <- stmt*}

1. Case analysis on stmt*{stmt <- stmt*}

  1. Case (% matches pattern [])

    1. Result in C, f, []

  2. Case (% matches pattern _ :: _)

    1. (Let stmt_h :: stmt_t*{stmt_t <- stmt_t*} be stmt*{stmt <- stmt*})

    2. (Stmt_ok: p C f |- stmt_h : C' f' stmtIL_h)

    3. (Stmts_ok: p C' f' |- stmt_t*{stmt_t <- stmt_t*} : C'' f'' stmtIL_t*{stmtIL_t <- stmtIL_t*})

    4. Result in C'', f'', stmtIL_h :: stmtIL_t*{stmtIL_t <- stmtIL_t*}

;; ../../../../spec/4b-typing-relation.watsup:107.1-109.23
relation Param_ok: p, C, (id dir type expr''?{expr'' <- expr''?})

1. (Let expr' be expr'')?{expr'' <- expr''?, expr' <- expr'?}

2. If ((expr'?{expr' <- expr'?} matches pattern (_))), then

  1. (Let ?(expr) be expr'?{expr' <- expr'?})

  2. (Type_ok: p C |- type : typ_p tid_fresh*{tid_fresh <- tid_fresh*})

  3. (Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh*{tid_fresh <- tid_fresh*} })))

  4. If ((Type_wf: tidset |- typ_p holds)), then

    1. (Expr_ok: p C |- expr : exprIL_e)

    2. (Let (( typ_e ; ctk )) be $annot(exprIL_e))

    3. If ((ctk matches pattern `LCTK`)), then

      1. If ((Sub_impl: typ_e << typ_p holds)), then

        1. (Eval_static: p C |- exprIL_e ~> val)

        2. Result in (id dir typ_p ?(val)), tid_fresh*{tid_fresh <- tid_fresh*}

      1. Else Phantom#884 ((expr'?{expr' <- expr'?} matches pattern (_))) /\ ((Type_wf: tidset |- typ_p holds)) /\ ((ctk matches pattern `LCTK`)) /\ (~(Sub_impl: typ_e << typ_p holds))

    3. Else Phantom#885 ((expr'?{expr' <- expr'?} matches pattern (_))) /\ ((Type_wf: tidset |- typ_p holds)) /\ (~(ctk matches pattern `LCTK`))

  4. Else Phantom#886 ((expr'?{expr' <- expr'?} matches pattern (_))) /\ (~(Type_wf: tidset |- typ_p holds))

2. Else Phantom#887 (~(expr'?{expr' <- expr'?} matches pattern (_)))

3. (Let expr be expr'')?{expr'' <- expr''?, expr <- expr?}

4. If ((expr?{expr <- expr?} matches pattern ())), then

  1. (Type_ok: p C |- type : typ_p tid_fresh*{tid_fresh <- tid_fresh*})

  2. (Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh*{tid_fresh <- tid_fresh*} })))

  3. If ((Type_wf: tidset |- typ_p holds)), then

    1. Result in (id dir typ_p ?()), tid_fresh*{tid_fresh <- tid_fresh*}

  3. Else Phantom#888 ((expr?{expr <- expr?} matches pattern ())) /\ (~(Type_wf: tidset |- typ_p holds))

4. Else Phantom#889 (~(expr?{expr <- expr?} matches pattern ()))

;; ../../../../spec/4b-typing-relation.watsup:110.1-112.23
relation CParam_ok: p, C, (id dir type expr''?{expr'' <- expr''?})

1. (Let expr' be expr'')?{expr'' <- expr''?, expr' <- expr'?}

2. If ((expr'?{expr' <- expr'?} matches pattern (_))), then

  1. (Let ?(expr) be expr'?{expr' <- expr'?})

  2. (Type_ok: p C |- type : typ_p tid_fresh*{tid_fresh <- tid_fresh*})

  3. (Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh*{tid_fresh <- tid_fresh*} })))

  4. If ((Type_wf: tidset |- typ_p holds)), then

    1. (Expr_ok: p C |- expr : exprIL_e)

    2. (Let (( typ_e ; ctk )) be $annot(exprIL_e))

    3. If ((ctk matches pattern `LCTK`)), then

      1. If ((Sub_impl: typ_e << typ_p holds)), then

        1. (Eval_static: p C |- exprIL_e ~> val)

        2. Result in (id dir typ_p ?(val)), tid_fresh*{tid_fresh <- tid_fresh*}

      1. Else Phantom#890 ((expr'?{expr' <- expr'?} matches pattern (_))) /\ ((Type_wf: tidset |- typ_p holds)) /\ ((ctk matches pattern `LCTK`)) /\ (~(Sub_impl: typ_e << typ_p holds))

    3. Else Phantom#891 ((expr'?{expr' <- expr'?} matches pattern (_))) /\ ((Type_wf: tidset |- typ_p holds)) /\ (~(ctk matches pattern `LCTK`))

  4. Else Phantom#892 ((expr'?{expr' <- expr'?} matches pattern (_))) /\ (~(Type_wf: tidset |- typ_p holds))

2. Else Phantom#893 (~(expr'?{expr' <- expr'?} matches pattern (_)))

3. (Let expr be expr'')?{expr'' <- expr''?, expr <- expr?}

4. If ((expr?{expr <- expr?} matches pattern ())), then

  1. (Type_ok: p C |- type : typ_p tid_fresh*{tid_fresh <- tid_fresh*})

  2. (Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh*{tid_fresh <- tid_fresh*} })))

  3. If ((Type_wf: tidset |- typ_p holds)), then

    1. Result in (id dir typ_p ?()), tid_fresh*{tid_fresh <- tid_fresh*}

  3. Else Phantom#894 ((expr?{expr <- expr?} matches pattern ())) /\ (~(Type_wf: tidset |- typ_p holds))

4. Else Phantom#895 (~(expr?{expr <- expr?} matches pattern ()))

;; ../../../../spec/4b-typing-relation.watsup:116.1-118.23
relation Decl_ok: p', C'''', decl''

1. Case analysis on decl''

  1. Case (% matches pattern `ConstD%%%`)

    1. (Let (ConstD id type expr) be decl'')

    2. (Type_ok: p' C'''' |- type : typ_c tid*{tid <- tid*})

    3. If ((tid*{tid <- tid*} matches pattern [])), then

      1. If ((Type_wf: $bound_tids(p', C'''') |- typ_c holds)), then

        1. (Expr_ok: p' C'''' |- expr : exprIL)

        2. (Let (( _typ ; ctk )) be $annot(exprIL))

        3. If ((ctk matches pattern `LCTK`)), then

          1. (Let exprIL' be $coerce_assign(exprIL, typ_c))

          2. (Eval_static: p' C'''' |- exprIL' ~> val)

          3. (Let C' be $add_styp(p', C'''', id, (typ_c (NO) (LCTK) ?(val))))

          4. Result in C', (ConstD id typ_c val)

        3. Else Phantom#896 ((decl'' matches pattern `ConstD%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((Type_wf: $bound_tids(p', C'''') |- typ_c holds)) /\ (~(ctk matches pattern `LCTK`))

      1. Else Phantom#897 ((decl'' matches pattern `ConstD%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(Type_wf: $bound_tids(p', C'''') |- typ_c holds))

    3. Else Phantom#898 ((decl'' matches pattern `ConstD%%%`)) /\ (~(tid*{tid <- tid*} matches pattern []))

  2. Case (% matches pattern `VarD%%%`)

    1. (Let (VarD id type expr?{expr <- expr?}) be decl'')

    2. If ((expr?{expr <- expr?} matches pattern ())), then

      1. (Type_ok: p' C'''' |- type : typ tid*{tid <- tid*})

      2. If ((tid*{tid <- tid*} matches pattern [])), then

        1. If ((Type_wf: $bound_tids(p', C'''') |- typ holds)), then

          1. If ($is_assignable(typ)), then

            1. (Let C' be $add_styp(p', C'''', id, (typ (INOUT) (DYN) ?())))

            2. Result in C', (VarD id typ ?())

          1. Else Phantom#899 ((decl'' matches pattern `VarD%%%`)) /\ ((expr?{expr <- expr?} matches pattern ())) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((Type_wf: $bound_tids(p', C'''') |- typ holds)) /\ (~$is_assignable(typ))

        1. Else Phantom#900 ((decl'' matches pattern `VarD%%%`)) /\ ((expr?{expr <- expr?} matches pattern ())) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(Type_wf: $bound_tids(p', C'''') |- typ holds))

      2. Else Phantom#901 ((decl'' matches pattern `VarD%%%`)) /\ ((expr?{expr <- expr?} matches pattern ())) /\ (~(tid*{tid <- tid*} matches pattern []))

    2. Else Phantom#902 ((decl'' matches pattern `VarD%%%`)) /\ (~(expr?{expr <- expr?} matches pattern ()))

    3. (Let (VarD id type expr'?{expr' <- expr'?}) be decl'')

    4. If ((expr'?{expr' <- expr'?} matches pattern (_))), then

      1. (Let ?(expr) be expr'?{expr' <- expr'?})

      2. (Type_ok: p' C'''' |- type : typ tid*{tid <- tid*})

      3. If ((tid*{tid <- tid*} matches pattern [])), then

        1. If ((Type_wf: $bound_tids(p', C'''') |- typ holds)), then

          1. If ($is_assignable(typ)), then

            1. (Expr_ok: p' C'''' |- expr : exprIL)

            2. (Let exprIL' be $coerce_assign(exprIL, typ))

            3. (Let C' be $add_styp(p', C'''', id, (typ (INOUT) (DYN) ?())))

            4. Result in C', (VarD id typ ?(exprIL'))

          1. Else Phantom#903 ((decl'' matches pattern `VarD%%%`)) /\ ((expr'?{expr' <- expr'?} matches pattern (_))) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((Type_wf: $bound_tids(p', C'''') |- typ holds)) /\ (~$is_assignable(typ))

        1. Else Phantom#904 ((decl'' matches pattern `VarD%%%`)) /\ ((expr'?{expr' <- expr'?} matches pattern (_))) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(Type_wf: $bound_tids(p', C'''') |- typ holds))

      3. Else Phantom#905 ((decl'' matches pattern `VarD%%%`)) /\ ((expr'?{expr' <- expr'?} matches pattern (_))) /\ (~(tid*{tid <- tid*} matches pattern []))

    4. Else Phantom#906 ((decl'' matches pattern `VarD%%%`)) /\ (~(expr'?{expr' <- expr'?} matches pattern (_)))

  3. Case (% matches pattern `InstD%%%%%`)

    1. (Let (InstD id name_inst targ*{targ <- targ*} arg*{arg <- arg*} decl''*{decl'' <- decl''*}) be decl'')

    2. If ((|decl''*{decl'' <- decl''*}| > 0)), then

      1. (Type_ok: p' C'''' |- targ : targIL tid_fresh_a*{tid_fresh_a <- tid_fresh_a*})*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}

      2. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**}))

      3. (ConsType_ok: p' C'''' |- name_inst targIL*{targIL <- targIL*} arg*{arg <- arg*} : ct tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} id_deft*{id_deft <- id_deft*})

      4. (Inst_ok: p' C'''' tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} |- ct targIL*{targIL <- targIL*} arg*{arg <- arg*} id_deft*{id_deft <- id_deft*} : typ targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

      5. (Let typ''' be typ)

      6. If ((typ''' has type abstyp)), then

        1. (Let abstyp be (typ''' as abstyp))

        2. If ((abstyp matches pattern `SpecT%%`)), then

          1. (Let (SpecT (PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ'') typ_a*{typ_a <- typ_a*}) be abstyp)

          2. If ((typ'' has type objtyp)), then

            1. (Let objtyp be (typ'' as objtyp))

            2. If ((objtyp matches pattern `ExternT%%`)), then

              1. (Let (ExternT id_ext fdenv_ext) be objtyp)

              2. (Let C' be $add_styp((LOCAL), C'''', "this", (typ (NO) (CTK) ?())))

              3. (Inst_init_decls_ok: C' $empty_frame $empty_fdenv |- decl''*{decl'' <- decl''*} : frame_abs fdenv_abs declIL*{declIL <- declIL*})

              4. (Let ({ (fid_abs -> fd_abs)*{fd_abs <- fd_abs*, fid_abs <- fid_abs*} }) be fdenv_abs)

              5. (Let tparam'*{tparam' <- tparam'*} be tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})

              6. (Let theta be ({ (tparam' -> typ_a)*{tparam' <- tparam'*, typ_a <- typ_a*} }))

              7. (Let fdenv_ext' be $update_fdenv_extern(fdenv_ext, theta, fid_abs*{fid_abs <- fid_abs*}, fd_abs*{fd_abs <- fd_abs*}))

              8. (Let ({ (fid_ext -> fd_ext)*{fd_ext <- fd_ext*, fid_ext <- fid_ext*} }) be fdenv_ext')

              9. (Let funcdef*{funcdef <- funcdef*} be fd_ext*{fd_ext <- fd_ext*})

              10. If ((funcdef has type polyfuncdef))*{funcdef <- funcdef*}, then

                1. (Let (PolyFD _(tparam*, tparam*) -> ft) be (funcdef as polyfuncdef))*{_(tparam*, tparam*) <- _(tparam*, tparam*)*, ft <- ft*, funcdef <- funcdef*}

                2. If (~$is_externabstractmethodt(ft))*{ft <- ft*}, then

                  1. (Let typ' be ((SpecT (PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> ((ExternT id_ext fdenv_ext') as typ)) typ_a*{typ_a <- typ_a*}) as typ))

                  2. (Let C'' be $add_styp(p', C'''', id, (typ' (NO) (CTK) ?())))

                  3. Result in C'', (InstD id typ name_inst targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*} declIL*{declIL <- declIL*})

                2. Else Phantom#907 ((decl'' matches pattern `InstD%%%%%`)) /\ ((|decl''*{decl'' <- decl''*}| > 0)) /\ ((typ''' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ (forall (funcdef has type polyfuncdef))*{funcdef <- funcdef*} /\ (exists ~~$is_externabstractmethodt(ft))*{ft <- ft*}

              10. Else Phantom#908 ((decl'' matches pattern `InstD%%%%%`)) /\ ((|decl''*{decl'' <- decl''*}| > 0)) /\ ((typ''' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ ((typ'' has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ (exists ~(funcdef has type polyfuncdef))*{funcdef <- funcdef*}

            2. Else Phantom#909 ((decl'' matches pattern `InstD%%%%%`)) /\ ((|decl''*{decl'' <- decl''*}| > 0)) /\ ((typ''' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ ((typ'' has type objtyp)) /\ (~(objtyp matches pattern `ExternT%%`))

          2. Else Phantom#910 ((decl'' matches pattern `InstD%%%%%`)) /\ ((|decl''*{decl'' <- decl''*}| > 0)) /\ ((typ''' has type abstyp)) /\ ((abstyp matches pattern `SpecT%%`)) /\ (~(typ'' has type objtyp))

        2. Else Phantom#911 ((decl'' matches pattern `InstD%%%%%`)) /\ ((|decl''*{decl'' <- decl''*}| > 0)) /\ ((typ''' has type abstyp)) /\ (~(abstyp matches pattern `SpecT%%`))

      6. Else Phantom#912 ((decl'' matches pattern `InstD%%%%%`)) /\ ((|decl''*{decl'' <- decl''*}| > 0)) /\ (~(typ''' has type abstyp))

    2. Else Phantom#913 ((decl'' matches pattern `InstD%%%%%`)) /\ (~(|decl''*{decl'' <- decl''*}| > 0))

    3. If ((decl''*{decl'' <- decl''*} matches pattern [])), then

      1. (Type_ok: p' C'''' |- targ : targIL tid_fresh_a*{tid_fresh_a <- tid_fresh_a*})*{targ <- targ*, targIL <- targIL*, tid_fresh_a* <- tid_fresh_a**}

      2. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $concat_<tid>(tid_fresh_a*{tid_fresh_a <- tid_fresh_a*}*{tid_fresh_a* <- tid_fresh_a**}))

      3. (ConsType_ok: p' C'''' |- name_inst targIL*{targIL <- targIL*} arg*{arg <- arg*} : ct tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} id_deft*{id_deft <- id_deft*})

      4. (Inst_ok: p' C'''' tid_fresh*{tid_fresh <- tid_fresh*} ++ tid_fresh_inserted*{tid_fresh_inserted <- tid_fresh_inserted*} |- ct targIL*{targIL <- targIL*} arg*{arg <- arg*} id_deft*{id_deft <- id_deft*} : typ targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*})

      5. (Let C' be $add_styp(p', C'''', id, (typ (NO) (CTK) ?())))

      6. Result in C', (InstD id typ name_inst targIL'*{targIL' <- targIL'*} argIL'*{argIL' <- argIL'*} [])

    3. Else Phantom#914 ((decl'' matches pattern `InstD%%%%%`)) /\ (~(decl''*{decl'' <- decl''*} matches pattern []))

  4. Case (% matches pattern `ActionD%%%`)

    1. (Let (ActionD id param*{param <- param*} block) be decl'')

    2. If (((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (CONTROL))))), then

      1. (Let fid be $to_fid(id, param*{param <- param*}))

      2. (Let C_1 be $set_localkind(C'''', (ACTION)))

      3. (Param_ok: (LOCAL) C_1 |- param : paramIL tid*{tid <- tid*})*{param <- param*, paramIL <- paramIL*, tid* <- tid**}

      4. If ((tid*{tid <- tid*} matches pattern []))*{tid* <- tid**}, then

        1. (Let C_2 be $add_params((LOCAL), C_1, (paramIL*{paramIL <- paramIL*} as paramtyp*)))

        2. (Block_ok: (LOCAL) C_2 (CONT) (INIT) |- block : _context _flow blockIL)

        3. (Let fd be ((MonoFD (ActionT (paramIL*{paramIL <- paramIL*} as paramtyp*))) as funcdef))

        4. If ((FuncDef_wf: $bound_tids(p', C'''') |- fd holds)), then

          1. (Let C_4 be $add_funcdef_non_overload(p', C'''', fid, fd))

          2. Result in C_4, (ActionD id paramIL*{paramIL <- paramIL*} blockIL)

        4. Else Phantom#915 ((decl'' matches pattern `ActionD%%%`)) /\ (((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (CONTROL))))) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (~(FuncDef_wf: $bound_tids(p', C'''') |- fd holds))

      4. Else Phantom#916 ((decl'' matches pattern `ActionD%%%`)) /\ (((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (CONTROL))))) /\ (exists ~(tid*{tid <- tid*} matches pattern []))*{tid* <- tid**}

    2. Else Phantom#917 ((decl'' matches pattern `ActionD%%%`)) /\ (~((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (CONTROL)))))

  5. Case (% matches pattern `ValueSetD%%%`)

    1. (Let (ValueSetD id type expr) be decl'')

    2. If (((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (PARSER))))), then

      1. (Type_ok: p' C'''' |- type : typ_s tid*{tid <- tid*})

      2. If ((tid*{tid <- tid*} matches pattern [])), then

        1. If ((Type_wf: $bound_tids(p', C'''') |- ((SetT typ_s) as typ) holds)), then

          1. (Expr_ok: p' C'''' |- expr : exprIL)

          2. (Let (( typ ; ctk )) be $annot(exprIL))

          3. If (((ctk = (CTK)) \/ (ctk = (LCTK)))), then

            1. (Let C' be $add_styp(p', C'''', id, (((SetT typ_s) as typ) (NO) (CTK) ?())))

            2. Result in C', (ValueSetD id typ exprIL)

          3. Else Phantom#918 ((decl'' matches pattern `ValueSetD%%%`)) /\ (((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (PARSER))))) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((Type_wf: $bound_tids(p', C'''') |- ((SetT typ_s) as typ) holds)) /\ (~((ctk = (CTK)) \/ (ctk = (LCTK))))

        1. Else Phantom#919 ((decl'' matches pattern `ValueSetD%%%`)) /\ (((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (PARSER))))) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(Type_wf: $bound_tids(p', C'''') |- ((SetT typ_s) as typ) holds))

      2. Else Phantom#920 ((decl'' matches pattern `ValueSetD%%%`)) /\ (((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (PARSER))))) /\ (~(tid*{tid <- tid*} matches pattern []))

    2. Else Phantom#921 ((decl'' matches pattern `ValueSetD%%%`)) /\ (~((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (PARSER)))))

1. Else Phantom#922 (~(decl'' matches pattern `ConstD%%%`)) /\ (~(decl'' matches pattern `VarD%%%`)) /\ (~(decl'' matches pattern `InstD%%%%%`)) /\ (~(decl'' matches pattern `ActionD%%%`)) /\ (~(decl'' matches pattern `ValueSetD%%%`))

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. Case analysis on decl''

      1. Case (% matches pattern `ErrD%`)

        1. (Let (ErrD member*{member <- member*}) be decl'')

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. (Let id_e be $concat_text(["error.", member]))*{id_e <- id_e*, member <- member*}

          2. (Let val_e be (ErrV member))*{member <- member*, val_e <- val_e*}

          3. (Let styp_e be (((ErrT) as typ) (NO) (LCTK) ?(val_e)))*{styp_e <- styp_e*, val_e <- val_e*}

          4. (Let C' be $add_styps((GLOBAL), C'''', id_e*{id_e <- id_e*}, styp_e*{styp_e <- styp_e*}))

          5. Result in C', (ErrD member*{member <- member*})

        2. Else Phantom#923 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ErrD%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      2. Case (% matches pattern `MatchKindD%`)

        1. (Let (MatchKindD member*{member <- member*}) be decl'')

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. (Let id_m be member)*{id_m <- id_m*, member <- member*}

          2. (Let val_m be (MatchKindV member))*{member <- member*, val_m <- val_m*}

          3. (Let styp_m be (((MatchKindT) as typ) (NO) (LCTK) ?(val_m)))*{styp_m <- styp_m*, val_m <- val_m*}

          4. (Let C' be $add_styps((GLOBAL), C'''', id_m*{id_m <- id_m*}, styp_m*{styp_m <- styp_m*}))

          5. Result in C', (MatchKindD member*{member <- member*})

        2. Else Phantom#924 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `MatchKindD%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      3. Case (% matches pattern `StructD%%%`)

        1. (Let (StructD id tparam*{tparam <- tparam*} (member_f, type_f)*{member_f <- member_f*, type_f <- type_f*}) be decl'')

        2. (Let C' be $add_tparams((BLOCK), C'''', tparam*{tparam <- tparam*}))

        3. (Type_ok: (BLOCK) C' |- type_f : typ_f tid_fresh_f*{tid_fresh_f <- tid_fresh_f*})*{tid_fresh_f* <- tid_fresh_f**, typ_f <- typ_f*, type_f <- type_f*}

        4. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_f*{tid_fresh_f <- tid_fresh_f*}*{tid_fresh_f* <- tid_fresh_f**}))

        5. (Let typ_s be ((StructT id (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*}) as typ))

        6. (Let td be ((PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ_s) as typdef))

        7. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C'', (StructD id tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*})

        7. Else Phantom#925 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `StructD%%%`)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

      4. Case (% matches pattern `HeaderD%%%`)

        1. (Let (HeaderD id tparam*{tparam <- tparam*} (member_f, type_f)*{member_f <- member_f*, type_f <- type_f*}) be decl'')

        2. (Let C' be $add_tparams((BLOCK), C'''', tparam*{tparam <- tparam*}))

        3. (Type_ok: (BLOCK) C' |- type_f : typ_f tid_fresh_f*{tid_fresh_f <- tid_fresh_f*})*{tid_fresh_f* <- tid_fresh_f**, typ_f <- typ_f*, type_f <- type_f*}

        4. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_f*{tid_fresh_f <- tid_fresh_f*}*{tid_fresh_f* <- tid_fresh_f**}))

        5. (Let typ_s be ((HeaderT id (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*}) as typ))

        6. (Let td be ((PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ_s) as typdef))

        7. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C'', (HeaderD id tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*})

        7. Else Phantom#926 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `HeaderD%%%`)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

      5. Case (% matches pattern `UnionD%%%`)

        1. (Let (UnionD id tparam*{tparam <- tparam*} (member_f, type_f)*{member_f <- member_f*, type_f <- type_f*}) be decl'')

        2. (Let C' be $add_tparams((BLOCK), C'''', tparam*{tparam <- tparam*}))

        3. (Type_ok: (BLOCK) C' |- type_f : typ_f tid_fresh_f*{tid_fresh_f <- tid_fresh_f*})*{tid_fresh_f* <- tid_fresh_f**, typ_f <- typ_f*, type_f <- type_f*}

        4. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_f*{tid_fresh_f <- tid_fresh_f*}*{tid_fresh_f* <- tid_fresh_f**}))

        5. (Let typ_s be ((UnionT id (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*}) as typ))

        6. (Let td be ((PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> typ_s) as typdef))

        7. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C'', (UnionD id tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} (member_f, typ_f)*{member_f <- member_f*, typ_f <- typ_f*})

        7. Else Phantom#927 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `UnionD%%%`)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

      6. Case (% matches pattern `EnumD%%`)

        1. (Let (EnumD id member*{member <- member*}) be decl'')

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. (Let id_e be $concat_text([id, ".", member]))*{id_e <- id_e*, member <- member*}

          2. (Let val_e be (EnumFieldV id member))*{member <- member*, val_e <- val_e*}

          3. (Let typ_e be ((EnumT id member*{member <- member*}) as typ))

          4. (Let styp_e be (typ_e (NO) (LCTK) ?(val_e)))*{styp_e <- styp_e*, val_e <- val_e*}

          5. (Let C' be $add_styps((GLOBAL), C'''', id_e*{id_e <- id_e*}, styp_e*{styp_e <- styp_e*}))

          6. (Let td be ((MonoD typ_e) as typdef))

          7. (Let tidset be $bound_tids((GLOBAL), C''''))

          8. If ((TypeDef_wf: tidset |- td holds)), then

            1. (Let C'' be $add_typdef((GLOBAL), C', id, td))

            2. Result in C'', (EnumD id member*{member <- member*})

          8. Else Phantom#928 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `EnumD%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (~(TypeDef_wf: tidset |- td holds))

        2. Else Phantom#929 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `EnumD%%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      7. Case (% matches pattern `SEnumD%%%`)

        1. (Let (SEnumD id type (member, expr)*{expr <- expr*, member <- member*}) be decl'')

        2. If ($distinct_<member>(member*{member <- member*})), then

          1. (Type_ok: (GLOBAL) C'''' |- type : typ tid*{tid <- tid*})

          2. If ((tid*{tid <- tid*} matches pattern [])), then

            1. If ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)), then

              1. (SEnum_fields_ok: C'''' id typ [] |- (member, expr)*{expr <- expr*, member <- member*} : C_1 (member', val_s)*{member' <- member'*, val_s <- val_s*})

              2. If ((member' = member))*{member <- member*, member' <- member'*}, then

                1. (Let id_s be $concat_text([id, ".", member]))*{id_s <- id_s*, member <- member*}

                2. (Let typ_s be ((SEnumT id typ (member, val_s)*{member <- member*, val_s <- val_s*}) as typ))

                3. (Let styp_s be (typ_s (NO) (LCTK) ?(val_s)))*{styp_s <- styp_s*, val_s <- val_s*}

                4. (Let C_2 be $add_styps((GLOBAL), C_1, id_s*{id_s <- id_s*}, styp_s*{styp_s <- styp_s*}))

                5. (Let td be ((MonoD typ_s) as typdef))

                6. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                  1. (Let C_3 be $add_typdef((GLOBAL), C_2, id, td))

                  2. Result in C_3, (SEnumD id typ (member, val_s)*{member <- member*, val_s <- val_s*})

                6. Else Phantom#930 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `SEnumD%%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)) /\ (forall (member' = member))*{member <- member*, member' <- member'*} /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

              2. Else Phantom#931 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `SEnumD%%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)) /\ (exists ~(member' = member))*{member <- member*, member' <- member'*}

            1. Else Phantom#932 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `SEnumD%%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds))

          2. Else Phantom#933 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `SEnumD%%%`)) /\ ($distinct_<member>(member*{member <- member*})) /\ (~(tid*{tid <- tid*} matches pattern []))

        2. Else Phantom#934 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `SEnumD%%%`)) /\ (~$distinct_<member>(member*{member <- member*}))

      8. Case (% matches pattern `NewTypeD%%`)

        1. (Let (NewTypeD id typedef) be decl'')

        2. Case analysis on typedef

          1. Case (% matches pattern `TypeD%`)

            1. (Let (TypeD type) be typedef)

            2. (Type_ok: (GLOBAL) C'''' |- type : typ tid*{tid <- tid*})

            3. If ((tid*{tid <- tid*} matches pattern [])), then

              1. If ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)), then

                1. (Let typ_n be ((NewT id typ) as typ))

                2. (Let td be ((MonoD typ_n) as typdef))

                3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                  1. (Let C' be $add_typdef((GLOBAL), C'''', id, td))

                  2. Result in C', (NewTypeD id (TypeD typ))

                3. Else Phantom#935 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `NewTypeD%%`)) /\ ((typedef matches pattern `TypeD%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

              1. Else Phantom#936 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `NewTypeD%%`)) /\ ((typedef matches pattern `TypeD%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds))

            3. Else Phantom#937 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `NewTypeD%%`)) /\ ((typedef matches pattern `TypeD%`)) /\ (~(tid*{tid <- tid*} matches pattern []))

          2. Case (% matches pattern `DeclD%`)

            1. (Let (DeclD decl'') be typedef)

            2. (Decl_ok: (GLOBAL) C'''' |- decl'' : C' declIL)

            3. (Let ({ tid*{tid <- tid*} }) be $diff_set<tid>($dom_map<tid, typdef>(C'.GLOBAL.TDENV), $dom_map<tid, typdef>(C''''.GLOBAL.TDENV)))

            4. If ((tid*{tid <- tid*} matches pattern [ _/1 ])), then

              1. (Let [tid_n] be tid*{tid <- tid*})

              2. (Let typdef'?{typdef' <- typdef'?} be $find_typdef((GLOBAL), C', (CURRENT tid_n)))

              3. If ((typdef'?{typdef' <- typdef'?} matches pattern (_))), then

                1. (Let ?(typdef) be typdef'?{typdef' <- typdef'?})

                2. Case analysis on typdef

                  1. Case (% has type monotypdef)

                    1. (Let (MonoD typ_n) be (typdef as monotypdef))

                    2. (Let td be ((MonoD ((NewT id typ_n) as typ)) as typdef))

                    3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                      1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

                      2. Result in C'', (NewTypeD id (DeclD declIL))

                    3. Else Phantom#938 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `NewTypeD%%`)) /\ ((typedef matches pattern `DeclD%`)) /\ ((tid*{tid <- tid*} matches pattern [ _/1 ])) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type monotypdef)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

                  2. Case (% has type polytypdef)

                    1. (Let ptd be (typdef as polytypdef))

                    2. (Let td be ((MonoD ((NewT id ((SpecT ptd []) as typ)) as typ)) as typdef))

                    3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                      1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

                      2. Result in C'', (NewTypeD id (DeclD declIL))

                    3. Else Phantom#939 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `NewTypeD%%`)) /\ ((typedef matches pattern `DeclD%`)) /\ ((tid*{tid <- tid*} matches pattern [ _/1 ])) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type polytypdef)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

              3. Else Phantom#940 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `NewTypeD%%`)) /\ ((typedef matches pattern `DeclD%`)) /\ ((tid*{tid <- tid*} matches pattern [ _/1 ])) /\ (~(typdef'?{typdef' <- typdef'?} matches pattern (_)))

            4. Else Phantom#941 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `NewTypeD%%`)) /\ ((typedef matches pattern `DeclD%`)) /\ (~(tid*{tid <- tid*} matches pattern [ _/1 ]))

      9. Case (% matches pattern `TypeDefD%%`)

        1. (Let (TypeDefD id typedef) be decl'')

        2. Case analysis on typedef

          1. Case (% matches pattern `TypeD%`)

            1. (Let (TypeD type) be typedef)

            2. (Type_ok: (GLOBAL) C'''' |- type : typ tid*{tid <- tid*})

            3. If ((tid*{tid <- tid*} matches pattern [])), then

              1. If ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)), then

                1. (Let typ_d be ((DefT typ) as typ))

                2. (Let td be ((MonoD typ_d) as typdef))

                3. (Let tidset be $bound_tids((GLOBAL), C''''))

                4. If ((TypeDef_wf: tidset |- td holds)), then

                  1. (Let C' be $add_typdef((GLOBAL), C'''', id, td))

                  2. Result in C', (TypeDefD id (TypeD typ))

                4. Else Phantom#942 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `TypeDefD%%`)) /\ ((typedef matches pattern `TypeD%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)) /\ (~(TypeDef_wf: tidset |- td holds))

              1. Else Phantom#943 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `TypeDefD%%`)) /\ ((typedef matches pattern `TypeD%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds))

            3. Else Phantom#944 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `TypeDefD%%`)) /\ ((typedef matches pattern `TypeD%`)) /\ (~(tid*{tid <- tid*} matches pattern []))

          2. Case (% matches pattern `DeclD%`)

            1. (Let (DeclD decl'') be typedef)

            2. (Decl_ok: (GLOBAL) C'''' |- decl'' : C' declIL)

            3. (Let ({ tid*{tid <- tid*} }) be $diff_set<tid>($dom_map<tid, typdef>(C'.GLOBAL.TDENV), $dom_map<tid, typdef>(C''''.GLOBAL.TDENV)))

            4. If ((tid*{tid <- tid*} matches pattern [ _/1 ])), then

              1. (Let [tid_d] be tid*{tid <- tid*})

              2. (Let typdef'?{typdef' <- typdef'?} be $find_typdef((GLOBAL), C', (CURRENT tid_d)))

              3. If ((typdef'?{typdef' <- typdef'?} matches pattern (_))), then

                1. (Let ?(typdef) be typdef'?{typdef' <- typdef'?})

                2. Case analysis on typdef

                  1. Case (% has type monotypdef)

                    1. (Let (MonoD typ_d) be (typdef as monotypdef))

                    2. (Let td be ((MonoD ((DefT typ_d) as typ)) as typdef))

                    3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                      1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

                      2. Result in C'', (TypeDefD id (DeclD declIL))

                    3. Else Phantom#945 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `TypeDefD%%`)) /\ ((typedef matches pattern `DeclD%`)) /\ ((tid*{tid <- tid*} matches pattern [ _/1 ])) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type monotypdef)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

                  2. Case (% has type polytypdef)

                    1. (Let ptd be (typdef as polytypdef))

                    2. (Let td be ((MonoD ((DefT ((SpecT ptd []) as typ)) as typ)) as typdef))

                    3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                      1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

                      2. Result in C'', (TypeDefD id (DeclD declIL))

                    3. Else Phantom#946 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `TypeDefD%%`)) /\ ((typedef matches pattern `DeclD%`)) /\ ((tid*{tid <- tid*} matches pattern [ _/1 ])) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type polytypdef)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

              3. Else Phantom#947 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `TypeDefD%%`)) /\ ((typedef matches pattern `DeclD%`)) /\ ((tid*{tid <- tid*} matches pattern [ _/1 ])) /\ (~(typdef'?{typdef' <- typdef'?} matches pattern (_)))

            4. Else Phantom#948 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `TypeDefD%%`)) /\ ((typedef matches pattern `DeclD%`)) /\ (~(tid*{tid <- tid*} matches pattern [ _/1 ]))

      10. Case (% matches pattern `FuncD%%%%%`)

        1. (Let (FuncD id type_r tparam*{tparam <- tparam*} param*{param <- param*} block) be decl'')

        2. (Let fid be $to_fid(id, param*{param <- param*}))

        3. (Let C_1 be $add_typdefs((LOCAL), C'''', tparam*{tparam <- tparam*}, ((MonoD ((VarT tparam) as typ)) as typdef)*{tparam <- tparam*}))

        4. (Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*{tid <- tid*})

        5. If ((tid*{tid <- tid*} matches pattern [])), then

          1. (Let C_2 be $set_localkind(C_1, (FUNC typ_r)))

          2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*{tid_fresh_p <- tid_fresh_p*})*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}

          3. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**}))

          4. (Let C_3 be $add_params((LOCAL), C_2, (paramIL*{paramIL <- paramIL*} as paramtyp*)))

          5. (Block_ok: (LOCAL) C_3 (CONT) (INIT) |- block : C_4 f blockIL)

          6. If (((f = (RET)) \/ ((f = (CONT)) /\ (typ_r = ((VoidT) as typ))))), then

            1. (Let fd be ((PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> (FuncT (paramIL*{paramIL <- paramIL*} as paramtyp*) typ_r)) as funcdef))

            2. If ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- fd holds)), then

              1. (Let C_5 be $add_funcdef((GLOBAL), C'''', fid, fd))

              2. Result in C_5, (FuncD id typ_r tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} paramIL*{paramIL <- paramIL*} blockIL)

            2. Else Phantom#949 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `FuncD%%%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (((f = (RET)) \/ ((f = (CONT)) /\ (typ_r = ((VoidT) as typ))))) /\ (~(FuncDef_wf: $bound_tids((GLOBAL), C'''') |- fd holds))

          6. Else Phantom#950 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `FuncD%%%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~((f = (RET)) \/ ((f = (CONT)) /\ (typ_r = ((VoidT) as typ)))))

        5. Else Phantom#951 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `FuncD%%%%%`)) /\ (~(tid*{tid <- tid*} matches pattern []))

      11. Case (% matches pattern `ExternFuncD%%%%`)

        1. (Let (ExternFuncD id type_r tparam*{tparam <- tparam*} param*{param <- param*}) be decl'')

        2. (Let fid be $to_fid(id, param*{param <- param*}))

        3. (Let C_1 be $add_typdefs((LOCAL), C'''', tparam*{tparam <- tparam*}, ((MonoD ((VarT tparam) as typ)) as typdef)*{tparam <- tparam*}))

        4. (Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*{tid <- tid*})

        5. If ((tid*{tid <- tid*} matches pattern [])), then

          1. (Let C_2 be $set_localkind(C_1, (EXTERNFUNC)))

          2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*{tid_fresh_p <- tid_fresh_p*})*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}

          3. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**}))

          4. (Let C_3 be $add_params((LOCAL), C_2, (paramIL*{paramIL <- paramIL*} as paramtyp*)))

          5. (Let fd be ((PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> (ExternFuncT (paramIL*{paramIL <- paramIL*} as paramtyp*) typ_r)) as funcdef))

          6. If ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- fd holds)), then

            1. (Let C_4 be $add_funcdef((GLOBAL), C'''', fid, fd))

            2. Result in C_4, (ExternFuncD id typ_r tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} paramIL*{paramIL <- paramIL*})

          6. Else Phantom#952 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ExternFuncD%%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(FuncDef_wf: $bound_tids((GLOBAL), C'''') |- fd holds))

        5. Else Phantom#953 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ExternFuncD%%%%`)) /\ (~(tid*{tid <- tid*} matches pattern []))

      12. Case (% matches pattern `ExternObjectD%%%`)

        1. (Let (ExternObjectD id tparam*{tparam <- tparam*} method*{method <- method*}) be decl'')

        2. (Let (method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*}) be $split_methods(method*{method <- method*}))

        3. (Let C_1 be $set_blockkind(C'''', (EXTERN)))

        4. (Let C_2 be $add_typdefs((BLOCK), C_1, tparam*{tparam <- tparam*}, ((MonoD ((VarT tparam) as typ)) as typdef)*{tparam <- tparam*}))

        5. (Methods_ok: C_2 id |- method_m*{method_m <- method_m*} : C_3 methodIL_m*{methodIL_m <- methodIL_m*})

        6. (Let td be ((PolyD (tparam*{tparam <- tparam*}, []) -> ((ExternT id C_3.BLOCK.FDENV) as typ)) as typdef))

        7. (Let C_4 be $add_typdef((GLOBAL), C'''', id, td))

        8. (Let C_5 be $set_blockkind(C_4, (EXTERN)))

        9. (Let C_6 be $add_typdefs((BLOCK), C_5, tparam*{tparam <- tparam*}, ((MonoD ((VarT tparam) as typ)) as typdef)*{tparam <- tparam*}))

        10. (Methods_ok: C_6 id |- method_c*{method_c <- method_c*} : C_7 methodIL_c*{methodIL_c <- methodIL_c*})

        11. (Let C_8 be C_4[GLOBAL.CDENV = C_7.GLOBAL.CDENV])

        12. Result in C_8, (ExternObjectD id tparam*{tparam <- tparam*} methodIL_c*{methodIL_c <- methodIL_c*} ++ methodIL_m*{methodIL_m <- methodIL_m*})

      13. Case (% matches pattern `ParserTypeD%%%`)

        1. (Let (ParserTypeD id tparam*{tparam <- tparam*} param*{param <- param*}) be decl'')

        2. (Let C_1 be $set_blockkind(C'''', (PARSER)))

        3. (Let C_2 be $add_typdefs((BLOCK), C_1, tparam*{tparam <- tparam*}, ((MonoD ((VarT tparam) as typ)) as typdef)*{tparam <- tparam*}))

        4. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*{tid_fresh_p <- tid_fresh_p*})*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}

        5. (Let (id_p dir_p typ_p val_p?{val_p <- val_p?}) be paramIL)*{dir_p <- dir_p*, id_p <- id_p*, paramIL <- paramIL*, typ_p <- typ_p*, val_p? <- val_p?*}

        6. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**}))

        7. (Let td be ((PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> ((ParserT (id_p dir_p typ_p val_p?{val_p <- val_p?})*{dir_p <- dir_p*, id_p <- id_p*, typ_p <- typ_p*, val_p? <- val_p?*}) as typ)) as typdef))

        8. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C_3 be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C_3, (ParserTypeD id tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} paramIL*{paramIL <- paramIL*})

        8. Else Phantom#954 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ParserTypeD%%%`)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

      14. Case (% matches pattern `ParserD%%%%%`)

        1. (Let (ParserD id param*{param <- param*} cparam*{cparam <- cparam*} decl''*{decl'' <- decl''*} parserstate*{parserstate <- parserstate*}) be decl'')

        2. (Let cid be $to_fid(id, cparam*{cparam <- cparam*}))

        3. (Let C_1 be $set_blockkind(C'''', (PARSER)))

        4. (Param_ok: (LOCAL) C_1 |- cparam : cparamIL tid*{tid <- tid*})*{cparam <- cparam*, cparamIL <- cparamIL*, tid* <- tid**}

        5. If ((tid*{tid <- tid*} matches pattern []))*{tid* <- tid**}, then

          1. (Let C_2 be $add_params((BLOCK), C_1, (cparamIL*{cparamIL <- cparamIL*} as paramtyp*)))

          2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid'*{tid' <- tid'*})*{param <- param*, paramIL <- paramIL*, tid'* <- tid'**}

          3. If ((tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**}, then

            1. (Let funcdef_apply be ((MonoFD (ParserApplyMethodT (paramIL*{paramIL <- paramIL*} as paramtyp*))) as funcdef))

            2. If ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)), then

              1. (Let C_3 be $add_params((BLOCK), C_2, (paramIL*{paramIL <- paramIL*} as paramtyp*)))

              2. (Decls_ok: (BLOCK) C_3 |- decl''*{decl'' <- decl''*} : C_4 declIL*{declIL <- declIL*})

              3. (Let (statelabel block) be parserstate)*{block <- block*, parserstate <- parserstate*, statelabel <- statelabel*}

              4. If ($distinct_<statelabel>(statelabel*{statelabel <- statelabel*})), then

                1. If ("start" is in statelabel*{statelabel <- statelabel*}), then

                  1. If (~"accept" is in statelabel*{statelabel <- statelabel*}), then

                    1. If (~"reject " is in statelabel*{statelabel <- statelabel*}), then

                      1. (Let statelabel'*{statelabel' <- statelabel'*} be "accept" :: "reject" :: statelabel*{statelabel <- statelabel*})

                      2. (Let C_5 be $set_localkind(C_4, (PARSERSTATE)))

                      3. (Let styp*{styp <- styp*} be $repeat_<styp>((((StateT) as typ) (NO) (DYN) ?()), |statelabel'*{statelabel' <- statelabel'*}|))

                      4. (Let C_6 be $add_styps((BLOCK), C_5, statelabel'*{statelabel' <- statelabel'*}, styp*{styp <- styp*}))

                      5. (ParserState_ok: C_6 |- parserstate : parserstateIL)*{parserstate <- parserstate*, parserstateIL <- parserstateIL*}

                      6. (Let ptd be (PolyD ([], []) -> ((ParserT (paramIL*{paramIL <- paramIL*} as paramtyp*)) as typ)))

                      7. (Let typ be ((SpecT ptd []) as typ))

                      8. (Let cd be (ConsD ([], []) -> (ConsT (cparamIL*{cparamIL <- cparamIL*} as paramtyp*) typ)))

                      9. If ((ConsDef_wf: $bound_tids((GLOBAL), C'''') |- cd holds)), then

                        1. (Let C_8 be $add_consdef((GLOBAL), C'''', cid, cd))

                        2. Result in C_8, (ParserD id paramIL*{paramIL <- paramIL*} cparamIL*{cparamIL <- cparamIL*} declIL*{declIL <- declIL*} parserstateIL*{parserstateIL <- parserstateIL*})

                      9. Else Phantom#955 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ParserD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (forall (tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**} /\ ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)) /\ ($distinct_<statelabel>(statelabel*{statelabel <- statelabel*})) /\ ("start" is in statelabel*{statelabel <- statelabel*}) /\ (~"accept" is in statelabel*{statelabel <- statelabel*}) /\ (~"reject " is in statelabel*{statelabel <- statelabel*}) /\ (~(ConsDef_wf: $bound_tids((GLOBAL), C'''') |- cd holds))

                    1. Else Phantom#956 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ParserD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (forall (tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**} /\ ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)) /\ ($distinct_<statelabel>(statelabel*{statelabel <- statelabel*})) /\ ("start" is in statelabel*{statelabel <- statelabel*}) /\ (~"accept" is in statelabel*{statelabel <- statelabel*}) /\ (~~"reject " is in statelabel*{statelabel <- statelabel*})

                  1. Else Phantom#957 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ParserD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (forall (tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**} /\ ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)) /\ ($distinct_<statelabel>(statelabel*{statelabel <- statelabel*})) /\ ("start" is in statelabel*{statelabel <- statelabel*}) /\ (~~"accept" is in statelabel*{statelabel <- statelabel*})

                1. Else Phantom#958 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ParserD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (forall (tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**} /\ ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)) /\ ($distinct_<statelabel>(statelabel*{statelabel <- statelabel*})) /\ (~"start" is in statelabel*{statelabel <- statelabel*})

              4. Else Phantom#959 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ParserD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (forall (tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**} /\ ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)) /\ (~$distinct_<statelabel>(statelabel*{statelabel <- statelabel*}))

            2. Else Phantom#960 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ParserD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (forall (tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**} /\ (~(FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds))

          3. Else Phantom#961 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ParserD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (exists ~(tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**}

        5. Else Phantom#962 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ParserD%%%%%`)) /\ (exists ~(tid*{tid <- tid*} matches pattern []))*{tid* <- tid**}

      15. Case (% matches pattern `ControlTypeD%%%`)

        1. (Let (ControlTypeD id tparam*{tparam <- tparam*} param*{param <- param*}) be decl'')

        2. (Let C' be $add_typdefs((BLOCK), C'''', tparam*{tparam <- tparam*}, ((MonoD ((VarT tparam) as typ)) as typdef)*{tparam <- tparam*}))

        3. (Let C'' be $set_blockkind(C'''', (CONTROL)))

        4. (Param_ok: (LOCAL) C' |- param : paramIL tid_fresh_p*{tid_fresh_p <- tid_fresh_p*})*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}

        5. (Let (id_p dir_p typ_p val_p?{val_p <- val_p?}) be paramIL)*{dir_p <- dir_p*, id_p <- id_p*, paramIL <- paramIL*, typ_p <- typ_p*, val_p? <- val_p?*}

        6. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**}))

        7. (Let td be ((PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> ((ControlT (id_p dir_p typ_p val_p?{val_p <- val_p?})*{dir_p <- dir_p*, id_p <- id_p*, typ_p <- typ_p*, val_p? <- val_p?*}) as typ)) as typdef))

        8. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C''' be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C''', (ControlTypeD id tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} paramIL*{paramIL <- paramIL*})

        8. Else Phantom#963 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ControlTypeD%%%`)) /\ (~(TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds))

      16. Case (% matches pattern `ControlD%%%%%`)

        1. (Let (ControlD id param*{param <- param*} cparam*{cparam <- cparam*} decl''*{decl'' <- decl''*} block) be decl'')

        2. (Let cid be $to_fid(id, cparam*{cparam <- cparam*}))

        3. (Let C_1 be $set_blockkind(C'''', (CONTROL)))

        4. (Param_ok: (LOCAL) C_1 |- cparam : cparamIL tid*{tid <- tid*})*{cparam <- cparam*, cparamIL <- cparamIL*, tid* <- tid**}

        5. If ((tid*{tid <- tid*} matches pattern []))*{tid* <- tid**}, then

          1. (Let C_2 be $add_params((BLOCK), C_1, (cparamIL*{cparamIL <- cparamIL*} as paramtyp*)))

          2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid'*{tid' <- tid'*})*{param <- param*, paramIL <- paramIL*, tid'* <- tid'**}

          3. If ((tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**}, then

            1. (Let funcdef_apply be ((MonoFD (ControlApplyMethodT (paramIL*{paramIL <- paramIL*} as paramtyp*))) as funcdef))

            2. If ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)), then

              1. (Let C_3 be $add_params((BLOCK), C_2, (paramIL*{paramIL <- paramIL*} as paramtyp*)))

              2. (Decls_ok: (BLOCK) C_3 |- decl''*{decl'' <- decl''*} : C_4 declIL*{declIL <- declIL*})

              3. (Let C_5 be $set_localkind(C_4, (CONTROLAPPLYMETHOD)))

              4. (Block_ok: (LOCAL) C_5 (CONT) (INIT) |- block : C_6 f blockIL)

              5. (Let ptd be (PolyD ([], []) -> ((ControlT (paramIL*{paramIL <- paramIL*} as paramtyp*)) as typ)))

              6. (Let typ be ((SpecT ptd []) as typ))

              7. (Let cd be (ConsD ([], []) -> (ConsT (cparamIL*{cparamIL <- cparamIL*} as paramtyp*) typ)))

              8. If ((ConsDef_wf: $bound_tids((GLOBAL), C'''') |- cd holds)), then

                1. (Let C_7 be $add_consdef((GLOBAL), C'''', cid, cd))

                2. Result in C_7, (ControlD id paramIL*{paramIL <- paramIL*} cparamIL*{cparamIL <- cparamIL*} declIL*{declIL <- declIL*} blockIL)

              8. Else Phantom#964 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ControlD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (forall (tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**} /\ ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)) /\ (~(ConsDef_wf: $bound_tids((GLOBAL), C'''') |- cd holds))

            2. Else Phantom#965 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ControlD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (forall (tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**} /\ (~(FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds))

          3. Else Phantom#966 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ControlD%%%%%`)) /\ (forall (tid*{tid <- tid*} matches pattern []))*{tid* <- tid**} /\ (exists ~(tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**}

        5. Else Phantom#967 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `ControlD%%%%%`)) /\ (exists ~(tid*{tid <- tid*} matches pattern []))*{tid* <- tid**}

      17. Case (% matches pattern `PackageTypeD%%%`)

        1. (Let (PackageTypeD id tparam*{tparam <- tparam*} cparam*{cparam <- cparam*}) be decl'')

        2. (Let cid be $to_fid(id, cparam*{cparam <- cparam*}))

        3. (Let C_1 be $add_typdefs((BLOCK), C'''', tparam*{tparam <- tparam*}, ((MonoD ((VarT tparam) as typ)) as typdef)*{tparam <- tparam*}))

        4. (Let C_2 be $set_blockkind(C_1, (PACKAGE)))

        5. (CParam_ok: (BLOCK) C_2 |- cparam : cparamIL tid_fresh_c*{tid_fresh_c <- tid_fresh_c*})*{cparam <- cparam*, cparamIL <- cparamIL*, tid_fresh_c* <- tid_fresh_c**}

        6. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_c*{tid_fresh_c <- tid_fresh_c*}*{tid_fresh_c* <- tid_fresh_c**}))

        7. (Let (_idIL _dirIL typ_c _val?{_val <- _val?}) be cparamIL)*{_dirIL <- _dirIL*, _idIL <- _idIL*, _val? <- _val?*, cparamIL <- cparamIL*, typ_c <- typ_c*}

        8. (Let ptd be (PolyD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> ((PackageT typ_c*{typ_c <- typ_c*}) as typ)))

        9. If ((TypeDef_wf: $bound_tids((BLOCK), C_2) |- (ptd as typdef) holds)), then

          1. (Let tparam'*{tparam' <- tparam'*} be tparam*{tparam <- tparam*} ++ tparam_hidden*{tparam_hidden <- tparam_hidden*})

          2. (Let typ be ((SpecT ptd ((VarT tparam') as typ)*{tparam' <- tparam'*}) as typ))

          3. (Let cd be (ConsD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> (ConsT (cparamIL*{cparamIL <- cparamIL*} as paramtyp*) typ)))

          4. If ((ConsDef_wf: $bound_tids((BLOCK), C_2) |- cd holds)), then

            1. (Let C_3 be $add_typdef((GLOBAL), C'''', id, (ptd as typdef)))

            2. (Let C_4 be $add_consdef((GLOBAL), C_3, cid, cd))

            3. Result in C_4, (PackageTypeD id tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} cparamIL*{cparamIL <- cparamIL*})

          4. Else Phantom#968 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `PackageTypeD%%%`)) /\ ((TypeDef_wf: $bound_tids((BLOCK), C_2) |- (ptd as typdef) holds)) /\ (~(ConsDef_wf: $bound_tids((BLOCK), C_2) |- cd holds))

        9. Else Phantom#969 ((p' matches pattern `GLOBAL`)) /\ ((decl'' matches pattern `PackageTypeD%%%`)) /\ (~(TypeDef_wf: $bound_tids((BLOCK), C_2) |- (ptd as typdef) holds))

    1. Else Phantom#970 ((p' matches pattern `GLOBAL`)) /\ (~(decl'' matches pattern `ErrD%`)) /\ (~(decl'' matches pattern `MatchKindD%`)) /\ (~(decl'' matches pattern `StructD%%%`)) /\ (~(decl'' matches pattern `HeaderD%%%`)) /\ (~(decl'' matches pattern `UnionD%%%`)) /\ (~(decl'' matches pattern `EnumD%%`)) /\ (~(decl'' matches pattern `SEnumD%%%`)) /\ (~(decl'' matches pattern `NewTypeD%%`)) /\ (~(decl'' matches pattern `TypeDefD%%`)) /\ (~(decl'' matches pattern `FuncD%%%%%`)) /\ (~(decl'' matches pattern `ExternFuncD%%%%`)) /\ (~(decl'' matches pattern `ExternObjectD%%%`)) /\ (~(decl'' matches pattern `ParserTypeD%%%`)) /\ (~(decl'' matches pattern `ParserD%%%%%`)) /\ (~(decl'' matches pattern `ControlTypeD%%%`)) /\ (~(decl'' matches pattern `ControlD%%%%%`)) /\ (~(decl'' matches pattern `PackageTypeD%%%`))

  2. Case (% matches pattern `BLOCK`)

    1. If ((decl'' matches pattern `TableD%%`)), then

      1. (Let (TableD id tbl) be decl'')

      2. If ((C''''.BLOCK.KIND matches pattern `CONTROL`)), then

        1. If ((|$keys_of_table(tbl)| <= 1)), then

          1. If ((|$actions_of_table(tbl)| = 1)), then

            1. (Let C_1 be $set_localkind(C'''', (TABLEAPPLYMETHOD)))

            2. (Table_props_ok: (LOCAL) C_1 $empty_tblctx |- tbl : tblctx' tblIL)

            3. (Table_type_decl_ok: (BLOCK) C_1 tblctx' |- id : C_2 typ_tbl)

            4. (Let typ be ((TableT id typ_tbl) as typ))

            5. If ((Type_wf: $bound_tids((BLOCK), C_2) |- typ holds)), then

              1. (Let C_3 be $add_styp((BLOCK), C_2, id, (typ (NO) (DYN) ?())))

              2. Result in C_3, (TableD id typ tblIL)

            5. Else Phantom#971 ((p' matches pattern `BLOCK`)) /\ ((decl'' matches pattern `TableD%%`)) /\ ((C''''.BLOCK.KIND matches pattern `CONTROL`)) /\ ((|$keys_of_table(tbl)| <= 1)) /\ ((|$actions_of_table(tbl)| = 1)) /\ (~(Type_wf: $bound_tids((BLOCK), C_2) |- typ holds))

          1. Else Phantom#972 ((p' matches pattern `BLOCK`)) /\ ((decl'' matches pattern `TableD%%`)) /\ ((C''''.BLOCK.KIND matches pattern `CONTROL`)) /\ ((|$keys_of_table(tbl)| <= 1)) /\ (~(|$actions_of_table(tbl)| = 1))

        1. Else Phantom#973 ((p' matches pattern `BLOCK`)) /\ ((decl'' matches pattern `TableD%%`)) /\ ((C''''.BLOCK.KIND matches pattern `CONTROL`)) /\ (~(|$keys_of_table(tbl)| <= 1))

      2. Else Phantom#974 ((p' matches pattern `BLOCK`)) /\ ((decl'' matches pattern `TableD%%`)) /\ (~(C''''.BLOCK.KIND matches pattern `CONTROL`))

    1. Else Phantom#975 ((p' matches pattern `BLOCK`)) /\ (~(decl'' matches pattern `TableD%%`))

2. Else Phantom#976 (~(p' matches pattern `GLOBAL`)) /\ (~(p' matches pattern `BLOCK`))

;; ../../../../spec/4b-typing-relation.watsup:119.1-121.23
relation Decls_ok: p, C, decl*{decl <- decl*}

1. Case analysis on decl*{decl <- decl*}

  1. Case (% matches pattern [])

    1. Result in C, []

  2. Case (% matches pattern _ :: _)

    1. (Let decl_h :: decl_t*{decl_t <- decl_t*} be decl*{decl <- decl*})

    2. (Decl_ok: p C |- decl_h : C' declIL_h)

    3. (Decls_ok: p C' |- decl_t*{decl_t <- decl_t*} : C'' declIL_t*{declIL_t <- declIL_t*})

    4. Result in C'', declIL_h :: declIL_t*{declIL_t <- declIL_t*}

;; ../../../../spec/4b-typing-relation.watsup:125.1-127.17
relation Prog_ok: decl*{decl <- decl*}

1. (Let C be $empty_context)

2. (Decls_ok: (GLOBAL) C |- decl*{decl <- decl*} : C' declIL*{declIL <- declIL*})

3. Result in C', declIL*{declIL <- declIL*}

;; ../../../../spec/4b-typing-relation.watsup:131.18-131.29
syntax actctxt = 
   | `ACT`()
   | `NOACT`()

;; ../../../../spec/4b-typing-relation.watsup:132.1-134.29
relation Call_convention_ok: p, C, actctxt, (id dir typ_p' val?{val <- val?}), (exprIL, typ_a')

1. Case analysis on dir

  1. Case (% matches pattern `IN`)

    1. (Let exprIL' be $coerce_assign(exprIL, typ_p'))

    2. Result in exprIL'

  2. Case (% matches pattern `OUT`)

    1. If ((Type_alpha: typ_a' ~~ typ_p' holds)), then

      1. If ((Lval_ok: p C |- exprIL holds)), then

        1. Result in exprIL

      1. Else Phantom#977 ((dir matches pattern `OUT`)) /\ ((Type_alpha: typ_a' ~~ typ_p' holds)) /\ (~(Lval_ok: p C |- exprIL holds))

    1. Else Phantom#978 ((dir matches pattern `OUT`)) /\ (~(Type_alpha: typ_a' ~~ typ_p' holds))

  3. Case (% matches pattern `INOUT`)

    1. If ((Type_alpha: typ_a' ~~ typ_p' holds)), then

      1. If ((Lval_ok: p C |- exprIL holds)), then

        1. Result in exprIL

      1. Else Phantom#979 ((dir matches pattern `INOUT`)) /\ ((Type_alpha: typ_a' ~~ typ_p' holds)) /\ (~(Lval_ok: p C |- exprIL holds))

    1. Else Phantom#980 ((dir matches pattern `INOUT`)) /\ (~(Type_alpha: typ_a' ~~ typ_p' holds))

1. Else Phantom#981 (~(dir matches pattern `IN`)) /\ (~(dir matches pattern `OUT`)) /\ (~(dir matches pattern `INOUT`))

2. Case analysis on actctxt

  1. Case (% matches pattern `ACT`)

    1. If ((dir matches pattern `NO`)), then

      1. (Let exprIL' be $coerce_assign(exprIL, typ_p'))

      2. Result in exprIL'

    1. Else Phantom#982 ((actctxt matches pattern `ACT`)) /\ (~(dir matches pattern `NO`))

  2. Case (% matches pattern `NOACT`)

    1. If ((dir matches pattern `NO`)), then

      1. (Let (( _typ ; ctk )) be $annot(exprIL))

      2. If (((ctk = (LCTK)) \/ (ctk = (CTK)))), then

        1. If ((Type_alpha: typ_a' ~~ typ_p' holds)), then

          1. Result in exprIL

        1. Else Phantom#983 ((actctxt matches pattern `NOACT`)) /\ ((dir matches pattern `NO`)) /\ (((ctk = (LCTK)) \/ (ctk = (CTK)))) /\ (~(Type_alpha: typ_a' ~~ typ_p' holds))

      2. Else Phantom#984 ((actctxt matches pattern `NOACT`)) /\ ((dir matches pattern `NO`)) /\ (~((ctk = (LCTK)) \/ (ctk = (CTK))))

    1. Else Phantom#985 ((actctxt matches pattern `NOACT`)) /\ (~(dir matches pattern `NO`))

;; ../../../../spec/4b-typing-relation.watsup:135.1-137.29
relation Call_convention_arg_ok: p, C, actctxt, pt', (argIL, typ')

1. Case analysis on argIL

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA exprIL) be argIL)

    2. (Call_convention_ok: p C actctxt |- pt' ~~ (exprIL, typ') : exprIL')

    3. Result in (ExprA exprIL')

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA id exprIL''?{exprIL'' <- exprIL''?}) be argIL)

    2. If ((exprIL''?{exprIL'' <- exprIL''?} matches pattern (_))), then

      1. (Let ?(exprIL) be exprIL''?{exprIL'' <- exprIL''?})

      2. (Call_convention_ok: p C actctxt |- pt' ~~ (exprIL, typ') : exprIL')

      3. Result in (NameA id ?(exprIL'))

    2. Else Phantom#986 ((argIL matches pattern `NameA%%`)) /\ (~(exprIL''?{exprIL'' <- exprIL''?} matches pattern (_)))

1. Else Phantom#987 (~(argIL matches pattern `ExprA%`)) /\ (~(argIL matches pattern `NameA%%`))

2. (Let (_id dir _typ _val?{_val <- _val?}) be pt')

3. If ((dir matches pattern `OUT`)), then

  1. Case analysis on argIL

    1. Case (% matches pattern `NameA%%`)

      1. (Let (NameA id exprIL?{exprIL <- exprIL?}) be argIL)

      2. If ((exprIL?{exprIL <- exprIL?} matches pattern ())), then

        1. Result in (NameA id ?())

      2. Else Phantom#988 ((dir matches pattern `OUT`)) /\ ((argIL matches pattern `NameA%%`)) /\ (~(exprIL?{exprIL <- exprIL?} matches pattern ()))

    2. Case (% matches pattern `AnyA`)

      1. Result in (AnyA)

  1. Else Phantom#989 ((dir matches pattern `OUT`)) /\ (~(argIL matches pattern `NameA%%`)) /\ (~(argIL matches pattern `AnyA`))

3. Else Phantom#990 (~(dir matches pattern `OUT`))

;; ../../../../spec/4b-typing-relation.watsup:143.1-145.23
relation Call_site_ok: cursor, C, functyp

1. Case analysis on cursor

  1. Case (% matches pattern `BLOCK`)

    1. Case analysis on functyp

      1. Case (% matches pattern `ExternFuncT%%`)

        1. (Let (ExternFuncT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

        2. If (((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL)))), then

          1. The relation holds

        2. Else Phantom#991 ((cursor matches pattern `BLOCK`)) /\ ((functyp matches pattern `ExternFuncT%%`)) /\ (~((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL))))

      2. Case (% matches pattern `BuiltinMethodT%%`)

        1. (Let (BuiltinMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

        2. If (((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL)))), then

          1. The relation holds

        2. Else Phantom#992 ((cursor matches pattern `BLOCK`)) /\ ((functyp matches pattern `BuiltinMethodT%%`)) /\ (~((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL))))

      3. Case (% matches pattern `ExternMethodT%%`)

        1. (Let (ExternMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

        2. If (((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL)))), then

          1. The relation holds

        2. Else Phantom#993 ((cursor matches pattern `BLOCK`)) /\ ((functyp matches pattern `ExternMethodT%%`)) /\ (~((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL))))

      4. Case (% matches pattern `ExternAbstractMethodT%%`)

        1. (Let (ExternAbstractMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

        2. If (((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL)))), then

          1. The relation holds

        2. Else Phantom#994 ((cursor matches pattern `BLOCK`)) /\ ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ (~((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL))))

    1. Else Phantom#995 ((cursor matches pattern `BLOCK`)) /\ (~(functyp matches pattern `ExternFuncT%%`)) /\ (~(functyp matches pattern `BuiltinMethodT%%`)) /\ (~(functyp matches pattern `ExternMethodT%%`)) /\ (~(functyp matches pattern `ExternAbstractMethodT%%`))

  2. Case (% matches pattern `LOCAL`)

    1. Case analysis on functyp

      1. Case (% matches pattern `ActionT%`)

        1. (Let (ActionT _paramtyp*{_paramtyp <- _paramtyp*}) be functyp)

        2. If ((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        2. Else Phantom#996 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `ActionT%`)) /\ (~(((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))))

      2. Case (% matches pattern `FuncT%%`)

        1. (Let (FuncT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. If ((lkind matches pattern `FUNC%`)), then

          1. (Let (FUNC typ) be lkind)

          2. The relation holds

        3. Else Phantom#997 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `FuncT%%`)) /\ (~(lkind matches pattern `FUNC%`))

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#998 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `FuncT%%`)) /\ (~((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))))

      3. Case (% matches pattern `ExternFuncT%%`)

        1. (Let (ExternFuncT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. If ((lkind matches pattern `EXTERNABSTRACTMETHOD%`)), then

          1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

          2. The relation holds

        3. Else Phantom#999 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `ExternFuncT%%`)) /\ (~(lkind matches pattern `EXTERNABSTRACTMETHOD%`))

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#1000 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `ExternFuncT%%`)) /\ (~((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))))

      4. Case (% matches pattern `BuiltinMethodT%%`)

        1. (Let (BuiltinMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. Case analysis on lkind

          1. Case (% matches pattern `FUNC%`)

            1. (Let (FUNC typ) be lkind)

            2. The relation holds

          2. Case (% matches pattern `EXTERNABSTRACTMETHOD%`)

            1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

            2. The relation holds

        3. Else Phantom#1001 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `BuiltinMethodT%%`)) /\ (~(lkind matches pattern `FUNC%`)) /\ (~(lkind matches pattern `EXTERNABSTRACTMETHOD%`))

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#1002 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `BuiltinMethodT%%`)) /\ (~((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))))

      5. Case (% matches pattern `ExternMethodT%%`)

        1. (Let (ExternMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. If ((lkind matches pattern `EXTERNABSTRACTMETHOD%`)), then

          1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

          2. The relation holds

        3. Else Phantom#1003 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `ExternMethodT%%`)) /\ (~(lkind matches pattern `EXTERNABSTRACTMETHOD%`))

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#1004 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `ExternMethodT%%`)) /\ (~((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))))

      6. Case (% matches pattern `ExternAbstractMethodT%%`)

        1. (Let (ExternAbstractMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. If ((lkind matches pattern `EXTERNABSTRACTMETHOD%`)), then

          1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

          2. The relation holds

        3. Else Phantom#1005 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ (~(lkind matches pattern `EXTERNABSTRACTMETHOD%`))

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#1006 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ (~((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))))

      7. Case (% matches pattern `ParserApplyMethodT%`)

        1. (Let (ParserApplyMethodT _paramtyp*{_paramtyp <- _paramtyp*}) be functyp)

        2. If ((C.LOCAL.KIND matches pattern `PARSERSTATE`)), then

          1. The relation holds

        2. Else Phantom#1007 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `ParserApplyMethodT%`)) /\ (~(C.LOCAL.KIND matches pattern `PARSERSTATE`))

      8. Case (% matches pattern `ControlApplyMethodT%`)

        1. (Let (ControlApplyMethodT _paramtyp*{_paramtyp <- _paramtyp*}) be functyp)

        2. If ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)), then

          1. The relation holds

        2. Else Phantom#1008 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `ControlApplyMethodT%`)) /\ (~(C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`))

      9. Case (% matches pattern `TableApplyMethodT%`)

        1. (Let (TableApplyMethodT _typ) be functyp)

        2. If (((C.LOCAL.KIND = (CONTROLAPPLYMETHOD)) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        2. Else Phantom#1009 ((cursor matches pattern `LOCAL`)) /\ ((functyp matches pattern `TableApplyMethodT%`)) /\ (~((C.LOCAL.KIND = (CONTROLAPPLYMETHOD)) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))))

1. Else Phantom#1010 (~(cursor matches pattern `BLOCK`)) /\ (~(cursor matches pattern `LOCAL`))

;; ../../../../spec/4b-typing-relation.watsup:146.1-148.35
relation Call_ok: p, C, tid'*{tid' <- tid'*}, functyp, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft'*{id_deft' <- id_deft'*}

1. (Let tid be tid')*{tid' <- tid'*, tid <- tid*}

2. (Let id_deft be id_deft')*{id_deft' <- id_deft'*, id_deft <- id_deft*}

3. If ((tid*{tid <- tid*} matches pattern [])), then

  1. Case analysis on functyp

    1. Case (% matches pattern `ActionT%`)

      1. (Let (ActionT pt*{pt <- pt*}) be functyp)

      2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

      3. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

      4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

        1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (ActionT pt*{pt <- pt*}) holds)), then

          1. If ((Call_site_ok: p C |- (ActionT pt*{pt <- pt*}) :CALLSITE_OK holds)), then

            1. If (~$is_table_apply_in_action_arg(argIL))*{argIL <- argIL*}, then

              1. (Call_convention_arg_ok: p C (ACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

              2. Result in ((VoidT) as typ), [], argIL*{argIL <- argIL*}

            1. Else Phantom#1011 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ActionT%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ActionT pt*{pt <- pt*}) holds)) /\ ((Call_site_ok: p C |- (ActionT pt*{pt <- pt*}) :CALLSITE_OK holds)) /\ (exists ~~$is_table_apply_in_action_arg(argIL))*{argIL <- argIL*}

          1. Else Phantom#1012 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ActionT%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ActionT pt*{pt <- pt*}) holds)) /\ (~(Call_site_ok: p C |- (ActionT pt*{pt <- pt*}) :CALLSITE_OK holds))

        2. Else Phantom#1013 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ActionT%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (ActionT pt*{pt <- pt*}) holds))

      4. Else Phantom#1014 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ActionT%`)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

    2. Case (% matches pattern `ExternFuncT%%`)

      1. (Let (ExternFuncT pt*{pt <- pt*} typ_r) be functyp)

      2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

      3. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

      4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

        1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt*{pt <- pt*} typ_r) holds)), then

          1. If ((Call_site_ok: p C |- (ExternFuncT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds)), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

            2. Result in typ_r, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}

          1. Else Phantom#1015 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ExternFuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt*{pt <- pt*} typ_r) holds)) /\ (~(Call_site_ok: p C |- (ExternFuncT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds))

        2. Else Phantom#1016 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ExternFuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt*{pt <- pt*} typ_r) holds))

      4. Else Phantom#1017 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ExternFuncT%%`)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

  1. Else Phantom#1018 ((tid*{tid <- tid*} matches pattern [])) /\ (~(functyp matches pattern `ActionT%`)) /\ (~(functyp matches pattern `ExternFuncT%%`))

3. Else Phantom#1019 (~(tid*{tid <- tid*} matches pattern []))

4. (Let tid_fresh be tid')*{tid' <- tid'*, tid_fresh <- tid_fresh*}

5. Case analysis on functyp

  1. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt*{pt <- pt*} typ_r) be functyp)

    2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

    3. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

    4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

      1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

      2. (Let theta be $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*}))

      3. (Let typ?{typ <- typ?} be $find_map<tid, typ>(theta, tid_fresh))*{tid_fresh <- tid_fresh*, typ? <- typ?*}

      4. If ((typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}, then

        1. (Let ?(targIL') be typ?{typ <- typ?})*{targIL' <- targIL'*, typ? <- typ?*}

        2. (Let targIL''*{targIL'' <- targIL''*} be targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*})

        3. (Let functyp' be $subst_functyp(theta, (ExternFuncT pt''*{pt'' <- pt''*} typ_r)))

        4. If ((functyp' matches pattern `ExternFuncT%%`)), then

          1. (Let (ExternFuncT pt'''*{pt''' <- pt'''*} typ_r') be functyp')

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt'''*{pt''' <- pt'''*} typ_r') holds)), then

            1. If ((Call_site_ok: p C |- (ExternFuncT pt'''*{pt''' <- pt'''*} typ_r') :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}

              2. Result in typ_r', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}

            1. Else Phantom#1020 ((functyp matches pattern `ExternFuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((functyp' matches pattern `ExternFuncT%%`)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt'''*{pt''' <- pt'''*} typ_r') holds)) /\ (~(Call_site_ok: p C |- (ExternFuncT pt'''*{pt''' <- pt'''*} typ_r') :CALLSITE_OK holds))

          2. Else Phantom#1021 ((functyp matches pattern `ExternFuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((functyp' matches pattern `ExternFuncT%%`)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt'''*{pt''' <- pt'''*} typ_r') holds))

        4. Else Phantom#1022 ((functyp matches pattern `ExternFuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ (~(functyp' matches pattern `ExternFuncT%%`))

      4. Else Phantom#1023 ((functyp matches pattern `ExternFuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (exists ~(typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}

    4. Else Phantom#1024 ((functyp matches pattern `ExternFuncT%%`)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

  2. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt*{pt <- pt*} typ_r) be functyp)

    2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

    3. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

    4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

      1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

      2. (Let theta be $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*}))

      3. (Let typ?{typ <- typ?} be $find_map<tid, typ>(theta, tid_fresh))*{tid_fresh <- tid_fresh*, typ? <- typ?*}

      4. If ((typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}, then

        1. (Let ?(targIL') be typ?{typ <- typ?})*{targIL' <- targIL'*, typ? <- typ?*}

        2. (Let targIL''*{targIL'' <- targIL''*} be targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*})

        3. (Let functyp' be $subst_functyp(theta, (FuncT pt''*{pt'' <- pt''*} typ_r)))

        4. If ((functyp' matches pattern `FuncT%%`)), then

          1. (Let (FuncT pt'''*{pt''' <- pt'''*} typ_r') be functyp')

          2. If ((FuncType_wf: $bound_tids(p, C) |- (FuncT pt'''*{pt''' <- pt'''*} typ_r') holds)), then

            1. If ((Call_site_ok: p C |- (FuncT pt'''*{pt''' <- pt'''*} typ_r') :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}

              2. Result in typ_r', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}

            1. Else Phantom#1025 ((functyp matches pattern `FuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((functyp' matches pattern `FuncT%%`)) /\ ((FuncType_wf: $bound_tids(p, C) |- (FuncT pt'''*{pt''' <- pt'''*} typ_r') holds)) /\ (~(Call_site_ok: p C |- (FuncT pt'''*{pt''' <- pt'''*} typ_r') :CALLSITE_OK holds))

          2. Else Phantom#1026 ((functyp matches pattern `FuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((functyp' matches pattern `FuncT%%`)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (FuncT pt'''*{pt''' <- pt'''*} typ_r') holds))

        4. Else Phantom#1027 ((functyp matches pattern `FuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ (~(functyp' matches pattern `FuncT%%`))

      4. Else Phantom#1028 ((functyp matches pattern `FuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (exists ~(typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}

    4. Else Phantom#1029 ((functyp matches pattern `FuncT%%`)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

  3. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt*{pt <- pt*} typ_r) be functyp)

    2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

    3. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

    4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

      1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

      2. (Let theta be $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*}))

      3. (Let typ?{typ <- typ?} be $find_map<tid, typ>(theta, tid_fresh))*{tid_fresh <- tid_fresh*, typ? <- typ?*}

      4. If ((typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}, then

        1. (Let ?(targIL') be typ?{typ <- typ?})*{targIL' <- targIL'*, typ? <- typ?*}

        2. (Let targIL''*{targIL'' <- targIL''*} be targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*})

        3. (Let functyp' be $subst_functyp(theta, (ExternMethodT pt''*{pt'' <- pt''*} typ_r)))

        4. If ((functyp' matches pattern `ExternMethodT%%`)), then

          1. (Let (ExternMethodT pt'''*{pt''' <- pt'''*} typ_r') be functyp')

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt'''*{pt''' <- pt'''*} typ_r') holds)), then

            1. If ((Call_site_ok: p C |- (ExternMethodT pt'''*{pt''' <- pt'''*} typ_r') :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}

              2. Result in typ_r', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}

            1. Else Phantom#1030 ((functyp matches pattern `ExternMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((functyp' matches pattern `ExternMethodT%%`)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt'''*{pt''' <- pt'''*} typ_r') holds)) /\ (~(Call_site_ok: p C |- (ExternMethodT pt'''*{pt''' <- pt'''*} typ_r') :CALLSITE_OK holds))

          2. Else Phantom#1031 ((functyp matches pattern `ExternMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((functyp' matches pattern `ExternMethodT%%`)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt'''*{pt''' <- pt'''*} typ_r') holds))

        4. Else Phantom#1032 ((functyp matches pattern `ExternMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ (~(functyp' matches pattern `ExternMethodT%%`))

      4. Else Phantom#1033 ((functyp matches pattern `ExternMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (exists ~(typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}

    4. Else Phantom#1034 ((functyp matches pattern `ExternMethodT%%`)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

  4. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt*{pt <- pt*} typ_r) be functyp)

    2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

    3. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

    4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

      1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

      2. (Let theta be $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*}))

      3. (Let typ?{typ <- typ?} be $find_map<tid, typ>(theta, tid_fresh))*{tid_fresh <- tid_fresh*, typ? <- typ?*}

      4. If ((typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}, then

        1. (Let ?(targIL') be typ?{typ <- typ?})*{targIL' <- targIL'*, typ? <- typ?*}

        2. (Let targIL''*{targIL'' <- targIL''*} be targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*})

        3. (Let functyp' be $subst_functyp(theta, (ExternAbstractMethodT pt''*{pt'' <- pt''*} typ_r)))

        4. If ((functyp' matches pattern `ExternAbstractMethodT%%`)), then

          1. (Let (ExternAbstractMethodT pt'''*{pt''' <- pt'''*} typ_r') be functyp')

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt'''*{pt''' <- pt'''*} typ_r') holds)), then

            1. If ((Call_site_ok: p C |- (ExternAbstractMethodT pt'''*{pt''' <- pt'''*} typ_r') :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}

              2. Result in typ_r', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}

            1. Else Phantom#1035 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((functyp' matches pattern `ExternAbstractMethodT%%`)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt'''*{pt''' <- pt'''*} typ_r') holds)) /\ (~(Call_site_ok: p C |- (ExternAbstractMethodT pt'''*{pt''' <- pt'''*} typ_r') :CALLSITE_OK holds))

          2. Else Phantom#1036 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((functyp' matches pattern `ExternAbstractMethodT%%`)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt'''*{pt''' <- pt'''*} typ_r') holds))

        4. Else Phantom#1037 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ (~(functyp' matches pattern `ExternAbstractMethodT%%`))

      4. Else Phantom#1038 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (exists ~(typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}

    4. Else Phantom#1039 ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

5. Else Phantom#1040 (~(functyp matches pattern `ExternFuncT%%`)) /\ (~(functyp matches pattern `FuncT%%`)) /\ (~(functyp matches pattern `ExternMethodT%%`)) /\ (~(functyp matches pattern `ExternAbstractMethodT%%`))

6. If ((tid*{tid <- tid*} matches pattern [])), then

  1. Case analysis on functyp

    1. Case (% matches pattern `FuncT%%`)

      1. (Let (FuncT pt*{pt <- pt*} typ_r) be functyp)

      2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

      3. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

      4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

        1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (FuncT pt*{pt <- pt*} typ_r) holds)), then

          1. If ((Call_site_ok: p C |- (FuncT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds)), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

            2. Result in typ_r, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}

          1. Else Phantom#1041 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `FuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((FuncType_wf: $bound_tids(p, C) |- (FuncT pt*{pt <- pt*} typ_r) holds)) /\ (~(Call_site_ok: p C |- (FuncT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds))

        2. Else Phantom#1042 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `FuncT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (FuncT pt*{pt <- pt*} typ_r) holds))

      4. Else Phantom#1043 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `FuncT%%`)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

    2. Case (% matches pattern `BuiltinMethodT%%`)

      1. (Let (BuiltinMethodT pt*{pt <- pt*} typ_r) be functyp)

      2. If ((targIL*{targIL <- targIL*} matches pattern [])), then

        1. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

        2. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

        3. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

          1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

          2. If ((FuncType_wf: $bound_tids(p, C) |- (BuiltinMethodT pt*{pt <- pt*} typ_r) holds)), then

            1. If ((Call_site_ok: p C |- (BuiltinMethodT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

              2. Result in typ_r, [], argIL''*{argIL'' <- argIL''*}

            1. Else Phantom#1044 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `BuiltinMethodT%%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((FuncType_wf: $bound_tids(p, C) |- (BuiltinMethodT pt*{pt <- pt*} typ_r) holds)) /\ (~(Call_site_ok: p C |- (BuiltinMethodT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds))

          2. Else Phantom#1045 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `BuiltinMethodT%%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (BuiltinMethodT pt*{pt <- pt*} typ_r) holds))

        3. Else Phantom#1046 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `BuiltinMethodT%%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

      2. Else Phantom#1047 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `BuiltinMethodT%%`)) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

    3. Case (% matches pattern `ExternMethodT%%`)

      1. (Let (ExternMethodT pt*{pt <- pt*} typ_r) be functyp)

      2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

      3. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

      4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

        1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt*{pt <- pt*} typ_r) holds)), then

          1. If ((Call_site_ok: p C |- (ExternMethodT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds)), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

            2. Result in typ_r, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}

          1. Else Phantom#1048 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ExternMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt*{pt <- pt*} typ_r) holds)) /\ (~(Call_site_ok: p C |- (ExternMethodT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds))

        2. Else Phantom#1049 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ExternMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt*{pt <- pt*} typ_r) holds))

      4. Else Phantom#1050 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ExternMethodT%%`)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

    4. Case (% matches pattern `ExternAbstractMethodT%%`)

      1. (Let (ExternAbstractMethodT pt*{pt <- pt*} typ_r) be functyp)

      2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

      3. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

      4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

        1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt*{pt <- pt*} typ_r) holds)), then

          1. If ((Call_site_ok: p C |- (ExternAbstractMethodT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds)), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

            2. Result in typ_r, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}

          1. Else Phantom#1051 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt*{pt <- pt*} typ_r) holds)) /\ (~(Call_site_ok: p C |- (ExternAbstractMethodT pt*{pt <- pt*} typ_r) :CALLSITE_OK holds))

        2. Else Phantom#1052 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt*{pt <- pt*} typ_r) holds))

      4. Else Phantom#1053 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

    5. Case (% matches pattern `ParserApplyMethodT%`)

      1. (Let (ParserApplyMethodT pt*{pt <- pt*}) be functyp)

      2. If ((targIL*{targIL <- targIL*} matches pattern [])), then

        1. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

        2. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

        3. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

          1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ParserApplyMethodT pt*{pt <- pt*}) holds)), then

            1. If ((Call_site_ok: p C |- (ParserApplyMethodT pt*{pt <- pt*}) :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

              2. Result in ((VoidT) as typ), [], argIL''*{argIL'' <- argIL''*}

            1. Else Phantom#1054 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ParserApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ParserApplyMethodT pt*{pt <- pt*}) holds)) /\ (~(Call_site_ok: p C |- (ParserApplyMethodT pt*{pt <- pt*}) :CALLSITE_OK holds))

          2. Else Phantom#1055 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ParserApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (ParserApplyMethodT pt*{pt <- pt*}) holds))

        3. Else Phantom#1056 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ParserApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

      2. Else Phantom#1057 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ParserApplyMethodT%`)) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

    6. Case (% matches pattern `ControlApplyMethodT%`)

      1. (Let (ControlApplyMethodT pt*{pt <- pt*}) be functyp)

      2. If ((targIL*{targIL <- targIL*} matches pattern [])), then

        1. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

        2. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

        3. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

          1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ControlApplyMethodT pt*{pt <- pt*}) holds)), then

            1. If ((Call_site_ok: p C |- (ControlApplyMethodT pt*{pt <- pt*}) :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

              2. Result in ((VoidT) as typ), [], argIL''*{argIL'' <- argIL''*}

            1. Else Phantom#1058 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ControlApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((FuncType_wf: $bound_tids(p, C) |- (ControlApplyMethodT pt*{pt <- pt*}) holds)) /\ (~(Call_site_ok: p C |- (ControlApplyMethodT pt*{pt <- pt*}) :CALLSITE_OK holds))

          2. Else Phantom#1059 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ControlApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(FuncType_wf: $bound_tids(p, C) |- (ControlApplyMethodT pt*{pt <- pt*}) holds))

        3. Else Phantom#1060 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ControlApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

      2. Else Phantom#1061 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `ControlApplyMethodT%`)) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

  1. Else Phantom#1062 ((tid*{tid <- tid*} matches pattern [])) /\ (~(functyp matches pattern `FuncT%%`)) /\ (~(functyp matches pattern `BuiltinMethodT%%`)) /\ (~(functyp matches pattern `ExternMethodT%%`)) /\ (~(functyp matches pattern `ExternAbstractMethodT%%`)) /\ (~(functyp matches pattern `ParserApplyMethodT%`)) /\ (~(functyp matches pattern `ControlApplyMethodT%`))

6. Else Phantom#1063 (~(tid*{tid <- tid*} matches pattern []))

7. (Let id be id_deft')*{id_deft' <- id_deft'*, id <- id*}

8. If ((tid*{tid <- tid*} matches pattern [])), then

  1. If ((functyp matches pattern `TableApplyMethodT%`)), then

    1. (Let (TableApplyMethodT typ_r) be functyp)

    2. If ((targIL*{targIL <- targIL*} matches pattern [])), then

      1. If ((arg*{arg <- arg*} matches pattern [])), then

        1. If ((id*{id <- id*} matches pattern [])), then

          1. If ((FuncType_wf: $bound_tids(p, C) |- (TableApplyMethodT typ_r) holds)), then

            1. If ((Call_site_ok: p C |- (TableApplyMethodT typ_r) :CALLSITE_OK holds)), then

              1. Result in typ_r, [], []

            1. Else Phantom#1064 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `TableApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ ((id*{id <- id*} matches pattern [])) /\ ((FuncType_wf: $bound_tids(p, C) |- (TableApplyMethodT typ_r) holds)) /\ (~(Call_site_ok: p C |- (TableApplyMethodT typ_r) :CALLSITE_OK holds))

          1. Else Phantom#1065 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `TableApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ ((id*{id <- id*} matches pattern [])) /\ (~(FuncType_wf: $bound_tids(p, C) |- (TableApplyMethodT typ_r) holds))

        1. Else Phantom#1066 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `TableApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ (~(id*{id <- id*} matches pattern []))

      1. Else Phantom#1067 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `TableApplyMethodT%`)) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(arg*{arg <- arg*} matches pattern []))

    2. Else Phantom#1068 ((tid*{tid <- tid*} matches pattern [])) /\ ((functyp matches pattern `TableApplyMethodT%`)) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

  1. Else Phantom#1069 ((tid*{tid <- tid*} matches pattern [])) /\ (~(functyp matches pattern `TableApplyMethodT%`))

8. Else Phantom#1070 (~(tid*{tid <- tid*} matches pattern []))

;; ../../../../spec/4b-typing-relation.watsup:153.1-155.29
relation FuncType_ok: p, C, name, targIL*{targIL <- targIL*}, arg*{arg <- arg*}

1. (Let (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} be $find_funcdef(p, C, name, arg*{arg <- arg*}))

2. If (((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_))), then

  1. (Let ?((fid, fd, id_deft*{id_deft <- id_deft*})) be (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?})

  2. (Let (ft, tid_fresh*{tid_fresh <- tid_fresh*}) be $specialize_funcdef(fd, targIL*{targIL <- targIL*}))

  3. Result in ft, tid_fresh*{tid_fresh <- tid_fresh*}, id_deft*{id_deft <- id_deft*}

2. Else Phantom#1071 (~((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_)))

;; ../../../../spec/4b-typing-relation.watsup:156.1-158.32
relation MethodType_ok: p, C, expr_b, member', targIL*{targIL <- targIL*}, arg*{arg <- arg*}

1. If ((targIL*{targIL <- targIL*} matches pattern [])), then

  1. If ((arg*{arg <- arg*} matches pattern [])), then

    1. (Expr_ok: p C |- expr_b : exprIL_b)

    2. If (member' is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. Result in (BuiltinMethodT [] ((IntT) as typ)), exprIL_b, [], []

    2. Else Phantom#1072 ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ (~member' is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])

  1. Else Phantom#1073 ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(arg*{arg <- arg*} matches pattern []))

  2. If (member' is in ["push_front", "pop_front"]), then

    1. (Expr_ok: p C |- expr_b : exprIL_b)

    2. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

    3. (Let typ be $canon_typ(typ_b))

    4. If ((typ has type datatyp)), then

      1. (Let datatyp be (typ as datatyp))

      2. If ((datatyp matches pattern `StackT%%`)), then

        1. (Let (StackT typ_b_in int_b) be datatyp)

        2. (Let pt be ("count" (NO) ((IntT) as typ) ?()))

        3. Result in (BuiltinMethodT [pt] ((IntT) as typ)), exprIL_b, [], []

      2. Else Phantom#1074 ((targIL*{targIL <- targIL*} matches pattern [])) /\ (member' is in ["push_front", "pop_front"]) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `StackT%%`))

    4. Else Phantom#1075 ((targIL*{targIL <- targIL*} matches pattern [])) /\ (member' is in ["push_front", "pop_front"]) /\ (~(typ has type datatyp))

  2. Else Phantom#1076 ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~member' is in ["push_front", "pop_front"])

  3. If (member' is in ["setValid", "setInvalid"]), then

    1. (Expr_ok: p C |- expr_b : exprIL_b)

    2. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

    3. (Let typ be $canon_typ(typ_b))

    4. If ((typ has type datatyp)), then

      1. (Let datatyp be (typ as datatyp))

      2. If ((datatyp matches pattern `HeaderT%%`)), then

        1. (Let (HeaderT id_b (member_b, typ_b_in)*{member_b <- member_b*, typ_b_in <- typ_b_in*}) be datatyp)

        2. Result in (BuiltinMethodT [] ((VoidT) as typ)), exprIL_b, [], []

      2. Else Phantom#1077 ((targIL*{targIL <- targIL*} matches pattern [])) /\ (member' is in ["setValid", "setInvalid"]) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `HeaderT%%`))

    4. Else Phantom#1078 ((targIL*{targIL <- targIL*} matches pattern [])) /\ (member' is in ["setValid", "setInvalid"]) /\ (~(typ has type datatyp))

  3. Else Phantom#1079 ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~member' is in ["setValid", "setInvalid"])

1. Else Phantom#1080 (~(targIL*{targIL <- targIL*} matches pattern []))

2. If ((member' = "isValid")), then

  1. If ((targIL*{targIL <- targIL*} matches pattern [])), then

    1. (Expr_ok: p C |- expr_b : exprIL_b)

    2. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

    3. (Let typ be $canon_typ(typ_b))

    4. If ((typ has type datatyp)), then

      1. (Let datatyp be (typ as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `HeaderT%%`)

          1. (Let (HeaderT id_b (member', typ_b_in)*{member' <- member'*, typ_b_in <- typ_b_in*}) be datatyp)

          2. Result in (BuiltinMethodT [] ((BoolT) as typ)), exprIL_b, [], []

        2. Case (% matches pattern `UnionT%%`)

          1. (Let (UnionT id_b (member', typ_b_in)*{member' <- member'*, typ_b_in <- typ_b_in*}) be datatyp)

          2. Result in (BuiltinMethodT [] ((BoolT) as typ)), exprIL_b, [], []

      2. Else Phantom#1081 ((member' = "isValid")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `HeaderT%%`)) /\ (~(datatyp matches pattern `UnionT%%`))

    4. Else Phantom#1082 ((member' = "isValid")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(typ has type datatyp))

  1. Else Phantom#1083 ((member' = "isValid")) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

2. Else Phantom#1084 (~(member' = "isValid"))

3. (Expr_ok: p C |- expr_b : exprIL_b)

4. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

5. (Let typ be $canon_typ(typ_b))

6. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ExternT%%`)), then

    1. (Let (ExternT id_b fmap_b) be objtyp)

    2. (Let (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} be $find_func<funcdef>(member', $to_fkey(arg*{arg <- arg*}), fmap_b))

    3. If (((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_))), then

      1. (Let ?((fid, fd, id_deft*{id_deft <- id_deft*})) be (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?})

      2. (Let (ft, tid_fresh*{tid_fresh <- tid_fresh*}) be $specialize_funcdef(fd, targIL*{targIL <- targIL*}))

      3. Result in ft, exprIL_b, tid_fresh*{tid_fresh <- tid_fresh*}, id_deft*{id_deft <- id_deft*}

    3. Else Phantom#1085 ((typ has type objtyp)) /\ ((objtyp matches pattern `ExternT%%`)) /\ (~((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_)))

  2. Else Phantom#1086 ((typ has type objtyp)) /\ (~(objtyp matches pattern `ExternT%%`))

6. Else Phantom#1087 (~(typ has type objtyp))

7. If ((member' = "apply")), then

  1. If ((targIL*{targIL <- targIL*} matches pattern [])), then

    1. If ((typ has type objtyp)), then

      1. (Let objtyp be (typ as objtyp))

      2. Case analysis on objtyp

        1. Case (% matches pattern `ParserT%`)

          1. (Let (ParserT pt*{pt <- pt*}) be objtyp)

          2. (Let ft be (ParserApplyMethodT pt*{pt <- pt*}))

          3. (Let fd be ((MonoFD ft) as funcdef))

          4. (Let (id_p _dir _typ val_deft?{val_deft <- val_deft?}) be pt)*{_dir <- _dir*, _typ <- _typ*, id_p <- id_p*, pt <- pt*, val_deft? <- val_deft?*}

          5. (Let b_deft be (val_deft?{val_deft <- val_deft?} =/= ?()))*{b_deft <- b_deft*, val_deft? <- val_deft?*}

          6. (Let fid be ("apply" (id_p, b_deft)*{b_deft <- b_deft*, id_p <- id_p*}))

          7. (Let (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} be $find_func<funcdef>("apply", $to_fkey(arg*{arg <- arg*}), ({ [(fid -> fd)] })))

          8. If (((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_))), then

            1. (Let ?((fid', funcdef, id_deft*{id_deft <- id_deft*})) be (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?})

            2. If ((fid' = fid)), then

              1. If ((funcdef = ((MonoFD ft) as funcdef))), then

                1. Result in ft, exprIL_b, [], id_deft*{id_deft <- id_deft*}

              1. Else Phantom#1088 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((typ has type objtyp)) /\ ((objtyp matches pattern `ParserT%`)) /\ (((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_))) /\ ((fid' = fid)) /\ (~(funcdef = ((MonoFD ft) as funcdef)))

            2. Else Phantom#1089 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((typ has type objtyp)) /\ ((objtyp matches pattern `ParserT%`)) /\ (((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_))) /\ (~(fid' = fid))

          8. Else Phantom#1090 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((typ has type objtyp)) /\ ((objtyp matches pattern `ParserT%`)) /\ (~((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_)))

        2. Case (% matches pattern `ControlT%`)

          1. (Let (ControlT pt*{pt <- pt*}) be objtyp)

          2. (Let ft be (ControlApplyMethodT pt*{pt <- pt*}))

          3. (Let fd be ((MonoFD ft) as funcdef))

          4. (Let (id_p _dir _typ val_deft?{val_deft <- val_deft?}) be pt)*{_dir <- _dir*, _typ <- _typ*, id_p <- id_p*, pt <- pt*, val_deft? <- val_deft?*}

          5. (Let b_deft be (val_deft?{val_deft <- val_deft?} =/= ?()))*{b_deft <- b_deft*, val_deft? <- val_deft?*}

          6. (Let fid be ("apply" (id_p, b_deft)*{b_deft <- b_deft*, id_p <- id_p*}))

          7. (Let (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} be $find_func<funcdef>("apply", $to_fkey(arg*{arg <- arg*}), ({ [(fid -> fd)] })))

          8. If (((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_))), then

            1. (Let ?((fid', funcdef, id_deft*{id_deft <- id_deft*})) be (fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?})

            2. If ((fid' = fid)), then

              1. If ((funcdef = ((MonoFD ft) as funcdef))), then

                1. Result in ft, exprIL_b, [], id_deft*{id_deft <- id_deft*}

              1. Else Phantom#1091 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((typ has type objtyp)) /\ ((objtyp matches pattern `ControlT%`)) /\ (((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_))) /\ ((fid' = fid)) /\ (~(funcdef = ((MonoFD ft) as funcdef)))

            2. Else Phantom#1092 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((typ has type objtyp)) /\ ((objtyp matches pattern `ControlT%`)) /\ (((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_))) /\ (~(fid' = fid))

          8. Else Phantom#1093 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((typ has type objtyp)) /\ ((objtyp matches pattern `ControlT%`)) /\ (~((fid, funcdef, id*)?{(fid, funcdef, id*) <- (fid, funcdef, id*)?} matches pattern (_)))

      2. Else Phantom#1094 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((typ has type objtyp)) /\ (~(objtyp matches pattern `ParserT%`)) /\ (~(objtyp matches pattern `ControlT%`))

    1. Else Phantom#1095 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(typ has type objtyp))

    2. If ((arg*{arg <- arg*} matches pattern [])), then

      1. If ((typ has type objtyp)), then

        1. (Let objtyp be (typ as objtyp))

        2. If ((objtyp matches pattern `TableT%%`)), then

          1. (Let (TableT id typ_t) be objtyp)

          2. (Let functyp be (TableApplyMethodT typ_t))

          3. Result in functyp, exprIL_b, [], []

        2. Else Phantom#1096 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ ((typ has type objtyp)) /\ (~(objtyp matches pattern `TableT%%`))

      1. Else Phantom#1097 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ ((arg*{arg <- arg*} matches pattern [])) /\ (~(typ has type objtyp))

    2. Else Phantom#1098 ((member' = "apply")) /\ ((targIL*{targIL <- targIL*} matches pattern [])) /\ (~(arg*{arg <- arg*} matches pattern []))

  1. Else Phantom#1099 ((member' = "apply")) /\ (~(targIL*{targIL <- targIL*} matches pattern []))

7. Else Phantom#1100 (~(member' = "apply"))

;; ../../../../spec/4b-typing-relation.watsup:163.1-165.29
relation ConsType_ok: p, C, name, targIL*{targIL <- targIL*}, arg*{arg <- arg*}

1. (Let (cid, consdef, id*)?{(cid, consdef, id*) <- (cid, consdef, id*)?} be $find_consdef((GLOBAL), C, name, arg*{arg <- arg*}))

2. If (((cid, consdef, id*)?{(cid, consdef, id*) <- (cid, consdef, id*)?} matches pattern (_))), then

  1. (Let ?((cid, cd, id_deft*{id_deft <- id_deft*})) be (cid, consdef, id*)?{(cid, consdef, id*) <- (cid, consdef, id*)?})

  2. (Let (ct, tid_fresh*{tid_fresh <- tid_fresh*}) be $specialize_consdef(cd, targIL*{targIL <- targIL*}))

  3. Result in ct, tid_fresh*{tid_fresh <- tid_fresh*}, id_deft*{id_deft <- id_deft*}

2. Else Phantom#1101 (~((cid, consdef, id*)?{(cid, consdef, id*) <- (cid, consdef, id*)?} matches pattern (_)))

;; ../../../../spec/4b-typing-relation.watsup:171.1-173.23
relation Inst_site_ok: cursor, C, (ConsT pt*{pt <- pt*} typ_i)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let typ_i' be $canon_typ(typ_i))

    2. If (($is_externt(typ_i') \/ $is_packaget(typ_i'))), then

      1. The relation holds

    2. Else Phantom#1102 ((cursor matches pattern `GLOBAL`)) /\ (~($is_externt(typ_i') \/ $is_packaget(typ_i')))

  2. Case (% matches pattern `BLOCK`)

    1. (Let typ_i' be $canon_typ(typ_i))

    2. Case analysis on C.BLOCK.KIND

      1. Case (% matches pattern `PACKAGE`)

        1. If (((($is_externt(typ_i') \/ $is_parsert(typ_i')) \/ $is_controlt(typ_i')) \/ $is_packaget(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1103 ((cursor matches pattern `BLOCK`)) /\ ((C.BLOCK.KIND matches pattern `PACKAGE`)) /\ (~((($is_externt(typ_i') \/ $is_parsert(typ_i')) \/ $is_controlt(typ_i')) \/ $is_packaget(typ_i')))

      2. Case (% matches pattern `PARSER`)

        1. If (($is_externt(typ_i') \/ $is_parsert(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1104 ((cursor matches pattern `BLOCK`)) /\ ((C.BLOCK.KIND matches pattern `PARSER`)) /\ (~($is_externt(typ_i') \/ $is_parsert(typ_i')))

      3. Case (% matches pattern `CONTROL`)

        1. If ((($is_externt(typ_i') \/ $is_controlt(typ_i')) \/ $is_tablet(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1105 ((cursor matches pattern `BLOCK`)) /\ ((C.BLOCK.KIND matches pattern `CONTROL`)) /\ (~(($is_externt(typ_i') \/ $is_controlt(typ_i')) \/ $is_tablet(typ_i')))

    2. Else Phantom#1106 ((cursor matches pattern `BLOCK`)) /\ (~(C.BLOCK.KIND matches pattern `PACKAGE`)) /\ (~(C.BLOCK.KIND matches pattern `PARSER`)) /\ (~(C.BLOCK.KIND matches pattern `CONTROL`))

  3. Case (% matches pattern `LOCAL`)

    1. (Let typ_i' be $canon_typ(typ_i))

    2. Case analysis on C.LOCAL.KIND

      1. Case (% matches pattern `PARSERSTATE`)

        1. If (($is_externt(typ_i') \/ $is_parsert(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1107 ((cursor matches pattern `LOCAL`)) /\ ((C.LOCAL.KIND matches pattern `PARSERSTATE`)) /\ (~($is_externt(typ_i') \/ $is_parsert(typ_i')))

      2. Case (% matches pattern `CONTROLAPPLYMETHOD`)

        1. If (($is_externt(typ_i') \/ $is_controlt(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1108 ((cursor matches pattern `LOCAL`)) /\ ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)) /\ (~($is_externt(typ_i') \/ $is_controlt(typ_i')))

    2. Else Phantom#1109 ((cursor matches pattern `LOCAL`)) /\ (~(C.LOCAL.KIND matches pattern `PARSERSTATE`)) /\ (~(C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`))

;; ../../../../spec/4b-typing-relation.watsup:174.1-176.35
relation Inst_ok: cursor', C_0', tid'*{tid' <- tid'*}, ct, targIL*{targIL <- targIL*}, arg*{arg <- arg*}, id_deft*{id_deft <- id_deft*}

1. (Let tid be tid')*{tid' <- tid'*, tid <- tid*}

2. If ((cursor' matches pattern `GLOBAL`)), then

  1. If ((tid*{tid <- tid*} matches pattern [])), then

    1. (Let (ConsT pt*{pt <- pt*} typ_i) be ct)

    2. If ($is_packaget($canon_typ(typ_i))), then

      1. (Let C_1 be $set_blockkind(C_0', (PACKAGE)))

      2. (Arg_ok: (BLOCK) C_1 |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

      3. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

      4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

        1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

        2. If ((ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt*{pt <- pt*} typ_i) holds)), then

          1. If ((Inst_site_ok: (GLOBAL) C_0' |- (ConsT pt*{pt <- pt*} typ_i) :INSTSITE_OK holds)), then

            1. (Call_convention_arg_ok: (BLOCK) C_1 (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

            2. Result in typ_i, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}

          1. Else Phantom#1110 ((cursor' matches pattern `GLOBAL`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ($is_packaget($canon_typ(typ_i))) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt*{pt <- pt*} typ_i) holds)) /\ (~(Inst_site_ok: (GLOBAL) C_0' |- (ConsT pt*{pt <- pt*} typ_i) :INSTSITE_OK holds))

        2. Else Phantom#1111 ((cursor' matches pattern `GLOBAL`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ($is_packaget($canon_typ(typ_i))) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt*{pt <- pt*} typ_i) holds))

      4. Else Phantom#1112 ((cursor' matches pattern `GLOBAL`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ ($is_packaget($canon_typ(typ_i))) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

    2. Else Phantom#1113 ((cursor' matches pattern `GLOBAL`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~$is_packaget($canon_typ(typ_i)))

  1. Else Phantom#1114 ((cursor' matches pattern `GLOBAL`)) /\ (~(tid*{tid <- tid*} matches pattern []))

2. Else Phantom#1115 (~(cursor' matches pattern `GLOBAL`))

3. (Let tid_fresh be tid')*{tid' <- tid'*, tid_fresh <- tid_fresh*}

4. If ((cursor' matches pattern `GLOBAL`)), then

  1. (Let (ConsT pt*{pt <- pt*} typ_i) be ct)

  2. If ($is_packaget($canon_typ(typ_i))), then

    1. If ((|tid_fresh*{tid_fresh <- tid_fresh*}| > 0)), then

      1. (Let C_1 be $set_blockkind(C_0', (PACKAGE)))

      2. (Arg_ok: (BLOCK) C_1 |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

      3. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

      4. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

        1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

        2. (Let theta be $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*}))

        3. (Let typ?{typ <- typ?} be $find_map<tid, typ>(theta, tid_fresh))*{tid_fresh <- tid_fresh*, typ? <- typ?*}

        4. If ((typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}, then

          1. (Let ?(targIL') be typ?{typ <- typ?})*{targIL' <- targIL'*, typ? <- typ?*}

          2. (Let targIL''*{targIL'' <- targIL''*} be targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*})

          3. (Let (ConsT pt'''*{pt''' <- pt'''*} typ_i') be $subst_constyp(theta, (ConsT pt''*{pt'' <- pt''*} typ_i)))

          4. If ((ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') holds)), then

            1. If ((Inst_site_ok: (GLOBAL) C_0' |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') :INSTSITE_OK holds)), then

              1. (Call_convention_arg_ok: (BLOCK) C_1 (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}

              2. Result in typ_i', targIL''*{targIL'' <- targIL''*}, argIL''*{argIL'' <- argIL''*}

            1. Else Phantom#1116 ((cursor' matches pattern `GLOBAL`)) /\ ($is_packaget($canon_typ(typ_i))) /\ ((|tid_fresh*{tid_fresh <- tid_fresh*}| > 0)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') holds)) /\ (~(Inst_site_ok: (GLOBAL) C_0' |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') :INSTSITE_OK holds))

          4. Else Phantom#1117 ((cursor' matches pattern `GLOBAL`)) /\ ($is_packaget($canon_typ(typ_i))) /\ ((|tid_fresh*{tid_fresh <- tid_fresh*}| > 0)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ (~(ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') holds))

        4. Else Phantom#1118 ((cursor' matches pattern `GLOBAL`)) /\ ($is_packaget($canon_typ(typ_i))) /\ ((|tid_fresh*{tid_fresh <- tid_fresh*}| > 0)) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (exists ~(typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}

      4. Else Phantom#1119 ((cursor' matches pattern `GLOBAL`)) /\ ($is_packaget($canon_typ(typ_i))) /\ ((|tid_fresh*{tid_fresh <- tid_fresh*}| > 0)) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

    1. Else Phantom#1120 ((cursor' matches pattern `GLOBAL`)) /\ ($is_packaget($canon_typ(typ_i))) /\ (~(|tid_fresh*{tid_fresh <- tid_fresh*}| > 0))

  2. Else Phantom#1121 ((cursor' matches pattern `GLOBAL`)) /\ (~$is_packaget($canon_typ(typ_i)))

4. Else Phantom#1122 (~(cursor' matches pattern `GLOBAL`))

5. If ((tid*{tid <- tid*} matches pattern [])), then

  1. (Let (ConsT pt*{pt <- pt*} typ_i) be ct)

  2. If (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))), then

    1. (Arg_ok: cursor' C_0' |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

    2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

    3. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

      1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

      2. If ((ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt*{pt <- pt*} typ_i) holds)), then

        1. If ((Inst_site_ok: cursor' C_0' |- (ConsT pt*{pt <- pt*} typ_i) :INSTSITE_OK holds)), then

          1. (Call_convention_arg_ok: cursor' C_0' (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt'' <- pt''*, typ_a <- typ_a*}

          2. Result in typ_i, targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}

        1. Else Phantom#1123 ((tid*{tid <- tid*} matches pattern [])) /\ (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ ((ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt*{pt <- pt*} typ_i) holds)) /\ (~(Inst_site_ok: cursor' C_0' |- (ConsT pt*{pt <- pt*} typ_i) :INSTSITE_OK holds))

      2. Else Phantom#1124 ((tid*{tid <- tid*} matches pattern [])) /\ (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (~(ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt*{pt <- pt*} typ_i) holds))

    3. Else Phantom#1125 ((tid*{tid <- tid*} matches pattern [])) /\ (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

  2. Else Phantom#1126 ((tid*{tid <- tid*} matches pattern [])) /\ (~~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i))))

5. Else Phantom#1127 (~(tid*{tid <- tid*} matches pattern []))

6. (Let (ConsT pt*{pt <- pt*} typ_i) be ct)

7. If (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))), then

  1. (Arg_ok: cursor' C_0' |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

  2. (Let pt'*{pt' <- pt'*} be $filter_default_args(pt*{pt <- pt*}, id_deft*{id_deft <- id_deft*}))

  3. If ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)), then

    1. (Let pt''*{pt'' <- pt''*} be $align_params_with_args(pt'*{pt' <- pt'*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}))

    2. (Let theta be $infer_targs(tid_fresh*{tid_fresh <- tid_fresh*}, pt''*{pt'' <- pt''*}, typ_a*{typ_a <- typ_a*}))

    3. (Let typ?{typ <- typ?} be $find_map<tid, typ>(theta, tid_fresh))*{tid_fresh <- tid_fresh*, typ? <- typ?*}

    4. If ((typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}, then

      1. (Let ?(targIL') be typ?{typ <- typ?})*{targIL' <- targIL'*, typ? <- typ?*}

      2. (Let targIL''*{targIL'' <- targIL''*} be targIL*{targIL <- targIL*} ++ targIL'*{targIL' <- targIL'*})

      3. (Let (ConsT pt'''*{pt''' <- pt'''*} typ_i') be $subst_constyp(theta, (ConsT pt''*{pt'' <- pt''*} typ_i)))

      4. If ((ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') holds)), then

        1. If ((Inst_site_ok: cursor' C_0' |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') :INSTSITE_OK holds)), then

          1. (Call_convention_arg_ok: cursor' C_0' (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*{argIL <- argIL*, argIL'' <- argIL''*, pt''' <- pt'''*, typ_a <- typ_a*}

          2. Result in typ_i', targIL*{targIL <- targIL*}, argIL''*{argIL'' <- argIL''*}

        1. Else Phantom#1128 (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ ((ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') holds)) /\ (~(Inst_site_ok: cursor' C_0' |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') :INSTSITE_OK holds))

      4. Else Phantom#1129 (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (forall (typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*} /\ (~(ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt'''*{pt''' <- pt'''*} typ_i') holds))

    4. Else Phantom#1130 (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))) /\ ((|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|)) /\ (exists ~(typ?{typ <- typ?} matches pattern (_)))*{typ? <- typ?*}

  3. Else Phantom#1131 (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))) /\ (~(|pt'*{pt' <- pt'*}| = |argIL*{argIL <- argIL*}|))

7. Else Phantom#1132 (~~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i))))

;; ../../../../spec/4d2-typing-subtyping.watsup:312.1-313.34
def $reduce_senum_unary(exprIL, $check_unary)

1. (Let (( typ ; _ctk )) be $annot(exprIL))

2. If ($check_unary(typ)), then

  1. Return exprIL

2. Else Phantom#1133 (~$check_unary(typ))

3. (Let (( typ ; ctk )) be $annot(exprIL))

4. If (~$check_unary(typ)), then

  1. (Let typ'' be typ)

  2. If ((typ'' has type datatyp)), then

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _id typ' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

      2. (Let exprIL' be (CastE typ' exprIL (( typ' ; ctk ))))

      3. (Let exprIL'' be $reduce_senum_unary(exprIL', $check_unary))

      4. Return exprIL''

    2. Else Phantom#1134 (~$check_unary(typ)) /\ ((typ'' has type datatyp)) /\ (~(datatyp matches pattern `SEnumT%%%`))

  2. Else Phantom#1135 (~$check_unary(typ)) /\ (~(typ'' has type datatyp))

4. Else Phantom#1136 (~~$check_unary(typ))

;; ../../../../spec/4d2-typing-subtyping.watsup:327.1-328.41
def $reduce_senums_binary(exprIL_a, exprIL_b, $check_binary)

1. (Let (( typ_a ; _ctk )) be $annot(exprIL_a))

2. (Let (( typ_b ; _ctk' )) be $annot(exprIL_b))

3. If ($check_binary(typ_a, typ_b)), then

  1. Return (exprIL_a, exprIL_b)

3. Else Phantom#1137 (~$check_binary(typ_a, typ_b))

4. (Let (( typ_a ; ctk_a )) be $annot(exprIL_a))

5. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

6. If (~$check_binary(typ_a, typ_b)), then

  1. (Let typ be typ_a)

  2. If ((typ has type datatyp)), then

    1. (Let datatyp be (typ as datatyp))

    2. If ((datatyp matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _id typ_a' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

      2. (Let exprIL_a' be (CastE typ_a' exprIL_a (( typ_a' ; ctk_a ))))

      3. (Let (exprIL_a'', exprIL_b'') be $reduce_senums_binary(exprIL_a', exprIL_b, $check_binary))

      4. Return (exprIL_a'', exprIL_b'')

    2. Else Phantom#1138 (~$check_binary(typ_a, typ_b)) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `SEnumT%%%`))

  2. Else Phantom#1139 (~$check_binary(typ_a, typ_b)) /\ (~(typ has type datatyp))

6. Else Phantom#1140 (~~$check_binary(typ_a, typ_b))

7. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

8. If (~$check_binary(typ_a, typ_b)), then

  1. (Let typ be typ_b)

  2. If ((typ has type datatyp)), then

    1. (Let datatyp be (typ as datatyp))

    2. If ((datatyp matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _id typ_b' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

      2. (Let exprIL_b' be (CastE typ_b' exprIL_b (( typ_b' ; ctk_b ))))

      3. (Let (exprIL_a'', exprIL_b'') be $reduce_senums_binary(exprIL_a, exprIL_b', $check_binary))

      4. Return (exprIL_a'', exprIL_b'')

    2. Else Phantom#1141 (~$check_binary(typ_a, typ_b)) /\ ((typ has type datatyp)) /\ (~(datatyp matches pattern `SEnumT%%%`))

  2. Else Phantom#1142 (~$check_binary(typ_a, typ_b)) /\ (~(typ has type datatyp))

8. Else Phantom#1143 (~~$check_binary(typ_a, typ_b))

;; ../../../../spec/4d2-typing-subtyping.watsup:353.1-354.32
def $coerce_binary(exprIL_a, exprIL_b)

1. (Let (( typ_a ; _ctk )) be $annot(exprIL_a))

2. (Let (( typ_b ; _ctk' )) be $annot(exprIL_b))

3. If ((Type_alpha: typ_a ~~ typ_b holds)), then

  1. Return (exprIL_a, exprIL_b)

3. Else Phantom#1144 (~(Type_alpha: typ_a ~~ typ_b holds))

4. (Let (( typ_a ; ctk_a )) be $annot(exprIL_a))

5. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

6. If (~(Type_alpha: typ_a ~~ typ_b holds)), then

  1. If ((Sub_impl: typ_a << typ_b holds)), then

    1. (Let exprIL_a' be (CastE typ_b exprIL_a (( typ_b ; ctk_a ))))

    2. Return (exprIL_a', exprIL_b)

  1. Else Phantom#1145 (~(Type_alpha: typ_a ~~ typ_b holds)) /\ (~(Sub_impl: typ_a << typ_b holds))

6. Else Phantom#1146 (~~(Type_alpha: typ_a ~~ typ_b holds))

7. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

8. If (~(Type_alpha: typ_a ~~ typ_b holds)), then

  1. If (~(Sub_impl: typ_a << typ_b holds)), then

    1. If ((Sub_impl: typ_b << typ_a holds)), then

      1. (Let exprIL_b' be (CastE typ_a exprIL_b (( typ_a ; ctk_b ))))

      2. Return (exprIL_a, exprIL_b')

    1. Else Phantom#1147 (~(Type_alpha: typ_a ~~ typ_b holds)) /\ (~(Sub_impl: typ_a << typ_b holds)) /\ (~(Sub_impl: typ_b << typ_a holds))

  1. Else Phantom#1148 (~(Type_alpha: typ_a ~~ typ_b holds)) /\ (~~(Sub_impl: typ_a << typ_b holds))

8. Else Phantom#1149 (~~(Type_alpha: typ_a ~~ typ_b holds))

;; ../../../../spec/4d2-typing-subtyping.watsup:377.1-378.31
def $coerce_assign(exprIL, typ_t)

1. (Let (( typ_f ; _ctk )) be $annot(exprIL))

2. If ((Type_alpha: typ_f ~~ typ_t holds)), then

  1. Return exprIL

2. Else Phantom#1150 (~(Type_alpha: typ_f ~~ typ_t holds))

3. (Let (( typ_f ; ctk_f )) be $annot(exprIL))

4. If (~(Type_alpha: typ_f ~~ typ_t holds)), then

  1. If ((Sub_impl: typ_f << typ_t holds)), then

    1. Return (CastE typ_t exprIL (( typ_t ; ctk_f )))

  1. Else Phantom#1151 (~(Type_alpha: typ_f ~~ typ_t holds)) /\ (~(Sub_impl: typ_f << typ_t holds))

4. Else Phantom#1152 (~~(Type_alpha: typ_f ~~ typ_t holds))

;; ../../../../spec/4e-typing-expr.watsup:88.1-88.33
def $compatible_bnot(typ)

1. Return $compatible'_bnot($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:89.1-89.34
def $compatible'_bnot(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:103.1-103.33
def $compatible_lnot(typ)

1. Return $compatible'_lnot($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:104.1-104.34
def $compatible'_lnot(typ)

1. If ((typ = ((BoolT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:117.1-117.34
def $compatible_uplus(typ)

1. Return $compatible'_uplus($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:118.1-118.35
def $compatible'_uplus(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:133.1-133.35
def $compatible_uminus(typ)

1. Return $compatible'_uminus($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:134.1-134.36
def $compatible'_uminus(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:153.1-153.47
def $compatible_plusminusmult(typ_l, typ_r)

1. Return $compatible'_plusminusmult($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:154.1-154.48
def $compatible'_plusminusmult(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:179.1-179.46
def $compatible_satplusminus(typ_l, typ_r)

1. Return $compatible'_satplusminus($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:180.1-180.47
def $compatible'_satplusminus(typ'', typ''')

1. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:204.1-204.40
def $compatible_divmod(typ_l, typ_r)

1. Return $compatible'_divmod($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:205.1-205.41
def $compatible'_divmod(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:249.1-249.39
def $compatible_shift(typ_l, typ_r)

1. Return $compatible'_shift($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:250.1-250.40
def $compatible'_shift(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

  2. If ((typ''' has type numtyp)), then

    1. (Let numtyp be (typ''' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. If ((typ''' = ((IntT) as typ))), then

        1. Return true

      3. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. Case analysis on numtyp'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _width') be numtyp')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _width') be numtyp')

            2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. If ((typ''' = ((IntT) as typ))), then

        1. Return true

      3. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. Case analysis on numtyp'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _width') be numtyp')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _width') be numtyp')

            2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:296.1-296.41
def $compatible_compare(typ_l, typ_r)

1. Return $compatible'_compare($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:297.1-297.42
def $compatible'_compare(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:322.1-322.41
def $compatible_bitwise(typ_l, typ_r)

1. Return $compatible'_bitwise($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:323.1-323.42
def $compatible'_bitwise(typ'', typ''')

1. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:347.1-347.40
def $compatible_concat(typ_l, typ_r)

1. Return $compatible'_concat($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:348.1-348.41
def $compatible'_concat(typ'', typ''')

1. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. Case analysis on numtyp'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _width') be numtyp')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _width') be numtyp')

            2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. Case analysis on numtyp'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _width') be numtyp')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _width') be numtyp')

            2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:391.1-391.41
def $compatible_logical(typ_l, typ_r)

1. Return $compatible'_logical($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:392.1-392.42
def $compatible'_logical(typ'', typ''')

1. If ((typ'' = ((BoolT) as typ))), then

  1. If ((typ''' = ((BoolT) as typ))), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:453.1-453.38
def $compatible_mask(typ_l, typ_r)

1. Return $compatible'_mask($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:454.1-454.39
def $compatible'_mask(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:481.1-481.39
def $compatible_range(typ_l, typ_r)

1. Return $compatible'_range($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:482.1-482.40
def $compatible'_range(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:508.1-510.26
relation Select_case_keyset_ok: cursor, C, typ_k, keyset

1. If ((cursor matches pattern `LOCAL`)), then

  1. Case analysis on keyset

    1. Case (% matches pattern `ExprK%`)

      1. (Let (ExprK expr) be keyset)

      2. (Expr_ok: (LOCAL) C |- expr : exprIL)

      3. (Let (( typ' ; _ctk )) be $annot(exprIL))

      4. If ((typ' has type synthtyp)), then

        1. (Let synthtyp be (typ' as synthtyp))

        2. If ((synthtyp matches pattern `SetT%`)), then

          1. (Let (SetT typ) be synthtyp)

          2. Case analysis on (Type_alpha: typ ~~ typ_k holds)

            1. Case true

              1. Result in (ExprK exprIL)

            2. Case false

              1. If ((Sub_impl: typ << typ_k holds)), then

                1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; (DYN) ))))

                2. Result in (ExprK exprIL')

              1. Else Phantom#1153 ((cursor matches pattern `LOCAL`)) /\ ((keyset matches pattern `ExprK%`)) /\ ((typ' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ (~(Type_alpha: typ ~~ typ_k holds)) /\ (~(Sub_impl: typ << typ_k holds))

        2. Else Phantom#1154 ((cursor matches pattern `LOCAL`)) /\ ((keyset matches pattern `ExprK%`)) /\ ((typ' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

      4. Else Phantom#1155 ((cursor matches pattern `LOCAL`)) /\ ((keyset matches pattern `ExprK%`)) /\ (~(typ' has type synthtyp))

      5. (Let (( typ ; _ctk )) be $annot(exprIL))

      6. If ((Sub_impl: typ << typ_k holds)), then

        1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; (DYN) ))))

        2. Result in (ExprK exprIL')

      6. Else Phantom#1156 ((cursor matches pattern `LOCAL`)) /\ ((keyset matches pattern `ExprK%`)) /\ (~(Sub_impl: typ << typ_k holds))

    2. Case (% matches pattern `DefaultK`)

      1. Result in (DefaultK)

    3. Case (% matches pattern `AnyK`)

      1. Result in (AnyK)

1. Else Phantom#1157 (~(cursor matches pattern `LOCAL`))

;; ../../../../spec/4e-typing-expr.watsup:543.1-545.26
relation Select_case_keysets_ok: p, C, typ'*{typ' <- typ'*}, keyset''*{keyset'' <- keyset''*}

1. (Let typ be typ')*{typ' <- typ'*, typ <- typ*}

2. (Let keyset' be keyset'')*{keyset'' <- keyset''*, keyset' <- keyset'*}

3. If ((typ*{typ <- typ*} matches pattern [ _/1 ])), then

  1. (Let [typ_k] be typ*{typ <- typ*})

  2. If ((keyset'*{keyset' <- keyset'*} matches pattern [ _/1 ])), then

    1. (Let [keyset] be keyset'*{keyset' <- keyset'*})

    2. (Select_case_keyset_ok: p C typ_k |- keyset : keysetIL)

    3. Result in [keysetIL]

  2. Else Phantom#1158 ((typ*{typ <- typ*} matches pattern [ _/1 ])) /\ (~(keyset'*{keyset' <- keyset'*} matches pattern [ _/1 ]))

3. Else Phantom#1159 (~(typ*{typ <- typ*} matches pattern [ _/1 ]))

4. (Let typ_k be typ')*{typ' <- typ'*, typ_k <- typ_k*}

5. If ((keyset'*{keyset' <- keyset'*} matches pattern [ _/1 ])), then

  1. (Let [keyset] be keyset'*{keyset' <- keyset'*})

  2. (Select_case_keyset_ok: p C ((SeqT typ_k*{typ_k <- typ_k*}) as typ) |- keyset : keysetIL)

  3. Result in [keysetIL]

5. Else Phantom#1160 (~(keyset'*{keyset' <- keyset'*} matches pattern [ _/1 ]))

6. (Let keyset be keyset'')*{keyset'' <- keyset''*, keyset <- keyset*}

7. If ((|typ_k*{typ_k <- typ_k*}| = |keyset*{keyset <- keyset*}|)), then

  1. (Select_case_keyset_ok: p C typ_k |- keyset : keysetIL)*{keyset <- keyset*, keysetIL <- keysetIL*, typ_k <- typ_k*}

  2. Result in keysetIL*{keysetIL <- keysetIL*}

7. Else Phantom#1161 (~(|typ_k*{typ_k <- typ_k*}| = |keyset*{keyset <- keyset*}|))

;; ../../../../spec/4e-typing-expr.watsup:561.1-563.26
relation Select_case_ok: cursor, C, typ_k*{typ_k <- typ_k*}, (keyset*{keyset <- keyset*} statelabel)

1. If ((cursor matches pattern `LOCAL`)), then

  1. (Select_case_keysets_ok: (LOCAL) C |- typ_k*{typ_k <- typ_k*} keyset*{keyset <- keyset*} : keysetIL*{keysetIL <- keysetIL*})

  2. (Let styp?{styp <- styp?} be $find_styp((LOCAL), C, (CURRENT statelabel)))

  3. If ((styp?{styp <- styp?} matches pattern (_))), then

    1. (Let ?((typ dir'' ctk'' val?{val <- val?})) be styp?{styp <- styp?})

    2. If ((typ = ((StateT) as typ))), then

      1. If ((val?{val <- val?} matches pattern ())), then

        1. Result in (keysetIL*{keysetIL <- keysetIL*} statelabel)

      1. Else Phantom#1162 ((cursor matches pattern `LOCAL`)) /\ ((styp?{styp <- styp?} matches pattern (_))) /\ ((typ = ((StateT) as typ))) /\ (~(val?{val <- val?} matches pattern ()))

    2. Else Phantom#1163 ((cursor matches pattern `LOCAL`)) /\ ((styp?{styp <- styp?} matches pattern (_))) /\ (~(typ = ((StateT) as typ)))

  3. Else Phantom#1164 ((cursor matches pattern `LOCAL`)) /\ (~(styp?{styp <- styp?} matches pattern (_)))

1. Else Phantom#1165 (~(cursor matches pattern `LOCAL`))

;; ../../../../spec/4e-typing-expr.watsup:585.1-585.39
def $compatible_arrayindex(typ)

1. Return $compatible'_arrayindex($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:586.1-586.40
def $compatible'_arrayindex(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:642.1-642.42
def $compatible_bitstringbase(typ)

1. Return $compatible'_bitstringbase($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:643.1-643.43
def $compatible'_bitstringbase(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. Return (w > 0)

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:652.1-652.43
def $compatible_bitstringindex(typ)

1. Return $compatible'_bitstringindex($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:653.1-653.44
def $compatible'_bitstringindex(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:662.1-662.52
def $is_valid_bitstring_slice(typ, n_l, n_h)

1. Return ((n_l <= n_h) /\ $is_valid_bitstring_slice'($canon_typ(typ), n_l, n_h))

;; ../../../../spec/4e-typing-expr.watsup:663.1-663.53
def $is_valid_bitstring_slice'(typ', _nat'', _nat''')

1. If ((typ' = ((IntT) as typ))), then

  1. Return true

2. If ((typ' has type numtyp)), then

  1. (Let numtyp be (typ' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. (Let w_slice be ((_nat''' - _nat'') + 1))

      3. Return ((_nat''' <= w) /\ (w_slice <= w))

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. (Let w_slice be ((_nat''' - _nat'') + 1))

      3. Return ((_nat''' <= w) /\ (w_slice <= w))

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:855.1-855.44
def $not_abstract_extern_object(typ)

1. Return $not_abstract_extern_object'($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:856.1-856.45
def $not_abstract_extern_object'(typ)

1. If (~$is_externt(typ)), then

  1. Return true

2. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ExternT%%`)), then

    1. (Let (ExternT _id fmap) be objtyp)

    2. (Let ({ fid*{fid <- fid*} }) be $dom_map<fid, funcdef>(fmap))

    3. (Let funcdef?{funcdef <- funcdef?} be $find_map<fid, funcdef>(fmap, fid))*{fid <- fid*, funcdef? <- funcdef?*}

    4. If ((funcdef?{funcdef <- funcdef?} matches pattern (_)))*{funcdef? <- funcdef?*}, then

      1. (Let ?(fd) be funcdef?{funcdef <- funcdef?})*{fd <- fd*, funcdef? <- funcdef?*}

      2. If ($not_abstract_extern_object''(fd))*{fd <- fd*}, then

        1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:857.1-857.50
def $not_abstract_extern_object''(funcdef')

1. If ((funcdef' has type polyfuncdef)), then

  1. (Let (PolyFD (_tparam*{_tparam <- _tparam*}, _tparam'*{_tparam' <- _tparam'*}) -> functyp) be (funcdef' as polyfuncdef))

  2. If ((functyp matches pattern `ExternAbstractMethodT%%`)), then

    1. (Let (ExternAbstractMethodT _paramtyp*{_paramtyp <- _paramtyp*} _typ) be functyp)

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec/4f-typing-stmt.watsup:45.1-47.29
relation Switch_tbl_label_ok: p, C, id_t, b_last', switchlabel

1. If ((switchlabel matches pattern `ExprL%`)), then

  1. (Let (ExprL expr) be switchlabel)

  2. If ((expr matches pattern `NameE%`)), then

    1. (Let (NameE name) be expr)

    2. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id_a) be name)

      2. (Let id_e be $concat_text(["action_list(", id_t, ")"]))

      3. (Let id be $concat_text([id_e, ".", id_a]))

      4. If ((?((TableEnumFieldV id_e id_a)) = $find_val(p, C, (CURRENT id)))), then

        1. (Let styp?{styp <- styp?} be $find_styp(p, C, (CURRENT id)))

        2. If ((styp?{styp <- styp?} matches pattern (_))), then

          1. (Let ?((typ_e _dir ctk_e _val?{_val <- _val?})) be styp?{styp <- styp?})

          2. Result in (ExprL (NameE (CURRENT id_a) (( typ_e ; ctk_e ))))

        2. Else Phantom#1166 ((switchlabel matches pattern `ExprL%`)) /\ ((expr matches pattern `NameE%`)) /\ ((name matches pattern `CURRENT%`)) /\ ((?((TableEnumFieldV id_e id_a)) = $find_val(p, C, (CURRENT id)))) /\ (~(styp?{styp <- styp?} matches pattern (_)))

      4. Else Phantom#1167 ((switchlabel matches pattern `ExprL%`)) /\ ((expr matches pattern `NameE%`)) /\ ((name matches pattern `CURRENT%`)) /\ (~(?((TableEnumFieldV id_e id_a)) = $find_val(p, C, (CURRENT id))))

    2. Else Phantom#1168 ((switchlabel matches pattern `ExprL%`)) /\ ((expr matches pattern `NameE%`)) /\ (~(name matches pattern `CURRENT%`))

  2. Else Phantom#1169 ((switchlabel matches pattern `ExprL%`)) /\ (~(expr matches pattern `NameE%`))

1. Else Phantom#1170 (~(switchlabel matches pattern `ExprL%`))

2. If ((b_last' = true)), then

  1. If ((switchlabel matches pattern `DefaultL`)), then

    1. Result in (DefaultL)

  1. Else Phantom#1171 ((b_last' = true)) /\ (~(switchlabel matches pattern `DefaultL`))

2. Else Phantom#1172 (~(b_last' = true))

;; ../../../../spec/4f-typing-stmt.watsup:60.1-62.32
relation Switch_tbl_case_ok: p, C, f, id_t, b_last, switchcase

1. Case analysis on switchcase

  1. Case (% matches pattern `MatchC%%`)

    1. (Let (MatchC switchlabel block) be switchcase)

    2. (Switch_tbl_label_ok: p C id_t b_last |- switchlabel : switchlabelIL)

    3. (Block_ok: p C f (NOINIT) |- block : C' f' blockIL)

    4. Result in f', (MatchC switchlabelIL blockIL), switchlabel

  2. Case (% matches pattern `FallC%`)

    1. (Let (FallC switchlabel) be switchcase)

    2. (Switch_tbl_label_ok: p C id_t b_last |- switchlabel : switchlabelIL)

    3. Result in f, (FallC switchlabelIL), switchlabel

;; ../../../../spec/4f-typing-stmt.watsup:74.1-76.29
relation Switch_tbl_cases_ok: p, C, f, id_t, switchcase*{switchcase <- switchcase*}

1. Case analysis on switchcase*{switchcase <- switchcase*}

  1. Case (% matches pattern [])

    1. Result in f, [], []

  2. Case (% matches pattern _ :: _)

    1. (Let switchcase_h :: switchcase_t*{switchcase_t <- switchcase_t*} be switchcase*{switchcase <- switchcase*})

    2. (Let b_last be (switchcase_t*{switchcase_t <- switchcase_t*} = []))

    3. (Switch_tbl_case_ok: p C f id_t b_last |- switchcase_h : f' switchcaseIL_h switchlabel_h)

    4. (Switch_tbl_cases_ok: p C f' id_t |- switchcase_t*{switchcase_t <- switchcase_t*} : f'' switchcaseIL_t*{switchcaseIL_t <- switchcaseIL_t*} switchlabel_t*{switchlabel_t <- switchlabel_t*})

    5. Result in f'', switchcaseIL_h :: switchcaseIL_t*{switchcaseIL_t <- switchcaseIL_t*}, switchlabel_h :: switchlabel_t*{switchlabel_t <- switchlabel_t*}

;; ../../../../spec/4f-typing-stmt.watsup:98.1-100.29
relation Switch_gen_label_ok: p, C, typ_s, b_last', switchlabel

1. If ((switchlabel matches pattern `ExprL%`)), then

  1. (Let (ExprL expr) be switchlabel)

  2. (Expr_ok: p C |- expr : exprIL)

  3. (Let (( _typ ; ctk )) be $annot(exprIL))

  4. If ((ctk matches pattern `LCTK`)), then

    1. (Let exprIL' be $coerce_assign(exprIL, typ_s))

    2. Result in (ExprL exprIL')

  4. Else Phantom#1173 ((switchlabel matches pattern `ExprL%`)) /\ (~(ctk matches pattern `LCTK`))

1. Else Phantom#1174 (~(switchlabel matches pattern `ExprL%`))

2. If ((b_last' = true)), then

  1. If ((switchlabel matches pattern `DefaultL`)), then

    1. Result in (DefaultL)

  1. Else Phantom#1175 ((b_last' = true)) /\ (~(switchlabel matches pattern `DefaultL`))

2. Else Phantom#1176 (~(b_last' = true))

;; ../../../../spec/4f-typing-stmt.watsup:112.1-114.32
relation Switch_gen_case_ok: p, C, f, typ_s, b_last, switchcase

1. Case analysis on switchcase

  1. Case (% matches pattern `MatchC%%`)

    1. (Let (MatchC switchlabel block) be switchcase)

    2. (Switch_gen_label_ok: p C typ_s b_last |- switchlabel : switchlabelIL)

    3. (Block_ok: p C f (NOINIT) |- block : C' f' blockIL)

    4. Result in f', (MatchC switchlabelIL blockIL), switchlabel

  2. Case (% matches pattern `FallC%`)

    1. (Let (FallC switchlabel) be switchcase)

    2. (Switch_gen_label_ok: p C typ_s b_last |- switchlabel : switchlabelIL)

    3. Result in f, (FallC switchlabelIL), switchlabel

;; ../../../../spec/4f-typing-stmt.watsup:126.1-128.29
relation Switch_gen_cases_ok: p, C, f, typ_s, switchcase*{switchcase <- switchcase*}

1. Case analysis on switchcase*{switchcase <- switchcase*}

  1. Case (% matches pattern [])

    1. Result in f, [], []

  2. Case (% matches pattern _ :: _)

    1. (Let switchcase_h :: switchcase_t*{switchcase_t <- switchcase_t*} be switchcase*{switchcase <- switchcase*})

    2. (Let b_last be (switchcase_t*{switchcase_t <- switchcase_t*} = []))

    3. (Switch_gen_case_ok: p C f typ_s b_last |- switchcase_h : f' switchcaseIL_h switchlabel_h)

    4. (Switch_gen_cases_ok: p C f' typ_s |- switchcase_t*{switchcase_t <- switchcase_t*} : f'' switchcaseIL_t*{switchcaseIL_t <- switchcaseIL_t*} switchlabel_t*{switchlabel_t <- switchlabel_t*})

    5. Result in f'', switchcaseIL_h :: switchcaseIL_t*{switchcaseIL_t <- switchcaseIL_t*}, switchlabel_h :: switchlabel_t*{switchlabel_t <- switchlabel_t*}

;; ../../../../spec/4g-typing-decl.watsup:88.1-90.29
relation Inst_init_decl_ok: p, C'', frame, fdenv, decl''

1. Case analysis on decl''

  1. Case (% matches pattern `InstD%%%%%`)

    1. (Let (InstD id' name targ*{targ <- targ*} arg*{arg <- arg*} decl*{decl <- decl*}) be decl'')

    2. (Decl_ok: p C'' |- (InstD id' name targ*{targ <- targ*} arg*{arg <- arg*} decl*{decl <- decl*}) : C' declIL)

    3. (Let styp?{styp <- styp?} be $find_styp(p, C', (CURRENT id')))

    4. If ((styp?{styp <- styp?} matches pattern (_))), then

      1. (Let ?(styp') be styp?{styp <- styp?})

      2. (Let frame' be $update_map<id, styp>(frame, id', styp'))

      3. Result in frame', fdenv, declIL

    4. Else Phantom#1177 ((decl'' matches pattern `InstD%%%%%`)) /\ (~(styp?{styp <- styp?} matches pattern (_)))

  2. Case (% matches pattern `FuncD%%%%%`)

    1. (Let (FuncD id type_r tparam*{tparam <- tparam*} param*{param <- param*} block) be decl'')

    2. (Let fid be $to_fid(id, param*{param <- param*}))

    3. (Let C_1 be $set_blockkind(C'', (EXTERN)))

    4. (Let C_2 be C_1[BLOCK.FRAME = frame])

    5. (Let C_3 be $add_tparams((LOCAL), C_2, tparam*{tparam <- tparam*}))

    6. (Type_ok: (LOCAL) C_3 |- type_r : typ_r tid*{tid <- tid*})

    7. If ((tid*{tid <- tid*} matches pattern [])), then

      1. (Let C_4 be $set_localkind(C_3, (EXTERNABSTRACTMETHOD typ_r)))

      2. (Param_ok: (LOCAL) C_4 |- param : paramIL tid_fresh_p*{tid_fresh_p <- tid_fresh_p*})*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}

      3. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**}))

      4. (Let C_5 be $add_params((LOCAL), C_4, (paramIL*{paramIL <- paramIL*} as paramtyp*)))

      5. (Let C_6 be $add_tparams((LOCAL), C_5, tparam_hidden*{tparam_hidden <- tparam_hidden*}))

      6. (Block_ok: (LOCAL) C_6 (CONT) (INIT) |- block : C_7 f blockIL)

      7. If (((f = (RET)) \/ (typ_r = ((VoidT) as typ)))), then

        1. (Let fd be ((PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> (ExternMethodT (paramIL*{paramIL <- paramIL*} as paramtyp*) typ_r)) as funcdef))

        2. If ((FuncDef_wf: $bound_tids(p, C'') |- fd holds)), then

          1. (Let fdenv' be $update_map<fid, funcdef>(fdenv, fid, fd))

          2. Result in frame, fdenv', (FuncD id typ_r tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} paramIL*{paramIL <- paramIL*} blockIL)

        2. Else Phantom#1178 ((decl'' matches pattern `FuncD%%%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (((f = (RET)) \/ (typ_r = ((VoidT) as typ)))) /\ (~(FuncDef_wf: $bound_tids(p, C'') |- fd holds))

      7. Else Phantom#1179 ((decl'' matches pattern `FuncD%%%%%`)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~((f = (RET)) \/ (typ_r = ((VoidT) as typ))))

    7. Else Phantom#1180 ((decl'' matches pattern `FuncD%%%%%`)) /\ (~(tid*{tid <- tid*} matches pattern []))

1. Else Phantom#1181 (~(decl'' matches pattern `InstD%%%%%`)) /\ (~(decl'' matches pattern `FuncD%%%%%`))

;; ../../../../spec/4g-typing-decl.watsup:128.1-130.26
relation Inst_init_decls_ok: C, frame, fdenv, decl*{decl <- decl*}

1. Case analysis on decl*{decl <- decl*}

  1. Case (% matches pattern [])

    1. Result in frame, fdenv, []

  2. Case (% matches pattern _ :: _)

    1. (Let decl_h :: decl_t*{decl_t <- decl_t*} be decl*{decl <- decl*})

    2. (Inst_init_decl_ok: (GLOBAL) C frame fdenv |- decl_h : frame' fdenv' declIL_h)

    3. (Inst_init_decls_ok: C frame' fdenv' |- decl_t*{decl_t <- decl_t*} : frame'' fdenv'' declIL_t*{declIL_t <- declIL_t*})

    4. Result in frame'', fdenv'', declIL_h :: declIL_t*{declIL_t <- declIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:141.1-142.109
def $update_fdenv_extern(fdenv_ext, theta, fid*{fid <- fid*}, funcdef*{funcdef <- funcdef*})

1. Case analysis on fid*{fid <- fid*}

  1. Case (% matches pattern [])

    1. If ((funcdef*{funcdef <- funcdef*} matches pattern [])), then

      1. Return fdenv_ext

    1. Else Phantom#1182 ((fid*{fid <- fid*} matches pattern [])) /\ (~(funcdef*{funcdef <- funcdef*} matches pattern []))

  2. Case (% matches pattern _ :: _)

    1. (Let fid_h :: fid_t*{fid_t <- fid_t*} be fid*{fid <- fid*})

    2. If ((funcdef*{funcdef <- funcdef*} matches pattern _ :: _)), then

      1. (Let fd_h :: fd_t*{fd_t <- fd_t*} be funcdef*{funcdef <- funcdef*})

      2. (Let funcdef''?{funcdef'' <- funcdef''?} be $find_map<fid, funcdef>(fdenv_ext, fid_h))

      3. If ((funcdef''?{funcdef'' <- funcdef''?} matches pattern (_))), then

        1. (Let ?(funcdef') be funcdef''?{funcdef'' <- funcdef''?})

        2. If ((funcdef' has type polyfuncdef)), then

          1. (Let (PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> functyp) be (funcdef' as polyfuncdef))

          2. If ((functyp matches pattern `ExternAbstractMethodT%%`)), then

            1. (Let (ExternAbstractMethodT pt*{pt <- pt*} typ_r) be functyp)

            2. (Let fd_ext be ((PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> (ExternMethodT pt*{pt <- pt*} typ_r)) as funcdef))

            3. (Let fd_ext' be $subst_funcdef(theta, fd_ext))

            4. If ((FuncDef_alpha: fd_ext' ~~ fd_h holds)), then

              1. (Let fdenv_ext' be $update_map<fid, funcdef>(fdenv_ext, fid_h, fd_ext'))

              2. Return $update_fdenv_extern(fdenv_ext', theta, fid_t*{fid_t <- fid_t*}, fd_t*{fd_t <- fd_t*})

            4. Else Phantom#1183 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ ((funcdef*{funcdef <- funcdef*} matches pattern _ :: _)) /\ ((funcdef''?{funcdef'' <- funcdef''?} matches pattern (_))) /\ ((funcdef' has type polyfuncdef)) /\ ((functyp matches pattern `ExternAbstractMethodT%%`)) /\ (~(FuncDef_alpha: fd_ext' ~~ fd_h holds))

          2. Else Phantom#1184 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ ((funcdef*{funcdef <- funcdef*} matches pattern _ :: _)) /\ ((funcdef''?{funcdef'' <- funcdef''?} matches pattern (_))) /\ ((funcdef' has type polyfuncdef)) /\ (~(functyp matches pattern `ExternAbstractMethodT%%`))

        2. Else Phantom#1185 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ ((funcdef*{funcdef <- funcdef*} matches pattern _ :: _)) /\ ((funcdef''?{funcdef'' <- funcdef''?} matches pattern (_))) /\ (~(funcdef' has type polyfuncdef))

      3. Else Phantom#1186 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ ((funcdef*{funcdef <- funcdef*} matches pattern _ :: _)) /\ (~(funcdef''?{funcdef'' <- funcdef''?} matches pattern (_)))

    2. Else Phantom#1187 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ (~(funcdef*{funcdef <- funcdef*} matches pattern _ :: _))

;; ../../../../spec/4g-typing-decl.watsup:291.1-293.32
relation SEnum_field_ok: C, id_s, typ_s, (member_s, val_s)*{member_s <- member_s*, val_s <- val_s*}, member, expr

1. (Expr_ok: (BLOCK) C |- expr : exprIL)

2. (Let (( _typ ; ctk )) be $annot(exprIL))

3. If ((ctk matches pattern `LCTK`)), then

  1. (Let exprIL' be $coerce_assign(exprIL, typ_s))

  2. (Eval_static: (BLOCK) C |- exprIL' ~> val_e)

  3. (Let val be (SEnumFieldV id_s member val_e))

  4. (Let member_s'*{member_s' <- member_s'*} be member_s*{member_s <- member_s*} ++ [member])

  5. (Let val_s'*{val_s' <- val_s'*} be val_s*{val_s <- val_s*} ++ [val])

  6. (Let typ_f be ((SEnumT id_s typ_s (member_s', val_s')*{member_s' <- member_s'*, val_s' <- val_s'*}) as typ))

  7. (Let C' be $add_styp((BLOCK), C, member, (typ_f (NO) (LCTK) ?(val))))

  8. Result in C', (member_s', val_s')*{member_s' <- member_s'*, val_s' <- val_s'*}

3. Else Phantom#1188 (~(ctk matches pattern `LCTK`))

;; ../../../../spec/4g-typing-decl.watsup:311.1-313.29
relation SEnum_fields_ok: C, id, typ, (member, val)*{member <- member*, val <- val*}, (member, expr)*{(member, expr) <- (member, expr)*}

1. Case analysis on (member, expr)*{(member, expr) <- (member, expr)*}

  1. Case (% matches pattern [])

    1. Result in C, (member, val)*{member <- member*, val <- val*}

  2. Case (% matches pattern _ :: _)

    1. (Let (member_h, expr_h) :: (member_t, expr_t)*{expr_t <- expr_t*, member_t <- member_t*} be (member, expr)*{(member, expr) <- (member, expr)*})

    2. (SEnum_field_ok: C id typ (member, val)*{member <- member*, val <- val*} |- member_h expr_h : C' (member', val')*{member' <- member'*, val' <- val'*})

    3. (SEnum_fields_ok: C' id typ (member', val')*{member' <- member'*, val' <- val'*} |- (member_t, expr_t)*{expr_t <- expr_t*, member_t <- member_t*} : C'' (member'', val'')*{member'' <- member''*, val'' <- val''*})

    4. Result in C'', (member'', val'')*{member'' <- member''*, val'' <- val''*}

;; ../../../../spec/4g-typing-decl.watsup:500.1-500.49
def $split_methods(method*{method <- method*})

1. Case analysis on method*{method <- method*}

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let method_h :: method_t*{method_t <- method_t*} be method*{method <- method*})

    2. (Let method' be method_h)

    3. Case analysis on method'

      1. Case (% matches pattern `ExternConsM%%`)

        1. (Let (ExternConsM _id _cparam*{_cparam <- _cparam*}) be method')

        2. (Let (method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*}) be $split_methods(method_t*{method_t <- method_t*}))

        3. Return (method_h :: method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*})

      2. Case (% matches pattern `ExternM%%%%`)

        1. (Let (ExternM _id _type _tparam*{_tparam <- _tparam*} _param*{_param <- _param*}) be method')

        2. (Let (method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*}) be $split_methods(method_t*{method_t <- method_t*}))

        3. Return (method_c*{method_c <- method_c*}, method_h :: method_m*{method_m <- method_m*})

      3. Case (% matches pattern `ExternAbstractM%%%%`)

        1. (Let (ExternAbstractM _id _type _tparam*{_tparam <- _tparam*} _param*{_param <- _param*}) be method')

        2. (Let (method_c*{method_c <- method_c*}, method_m*{method_m <- method_m*}) be $split_methods(method_t*{method_t <- method_t*}))

        3. Return (method_c*{method_c <- method_c*}, method_h :: method_m*{method_m <- method_m*})

    3. Else Phantom#1189 ((method*{method <- method*} matches pattern _ :: _)) /\ (~(method' matches pattern `ExternConsM%%`)) /\ (~(method' matches pattern `ExternM%%%%`)) /\ (~(method' matches pattern `ExternAbstractM%%%%`))

;; ../../../../spec/4g-typing-decl.watsup:514.1-516.23
relation Method_ok: C'', id_e, method

1. Case analysis on method

  1. Case (% matches pattern `ExternConsM%%`)

    1. (Let (ExternConsM id_e' cparam*{cparam <- cparam*}) be method)

    2. If ((id_e = id_e')), then

      1. (Let cid be $to_fid(id_e, cparam*{cparam <- cparam*}))

      2. (CParam_ok: (BLOCK) C'' |- cparam : cparamIL tid_fresh_c*{tid_fresh_c <- tid_fresh_c*})*{cparam <- cparam*, cparamIL <- cparamIL*, tid_fresh_c* <- tid_fresh_c**}

      3. (Let (id_c dir_c typ_c val_c?{val_c <- val_c?}) be cparamIL)*{cparamIL <- cparamIL*, dir_c <- dir_c*, id_c <- id_c*, typ_c <- typ_c*, val_c? <- val_c?*}

      4. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_c*{tid_fresh_c <- tid_fresh_c*}*{tid_fresh_c* <- tid_fresh_c**}))

      5. (Let typdef'?{typdef' <- typdef'?} be $find_typdef((GLOBAL), C'', (CURRENT id_e)))

      6. If ((typdef'?{typdef' <- typdef'?} matches pattern (_))), then

        1. (Let ?(typdef) be typdef'?{typdef' <- typdef'?})

        2. If ((typdef has type polytypdef)), then

          1. (Let (PolyD (tparam_e*{tparam_e <- tparam_e*}, tparam*{tparam <- tparam*}) -> typ_e) be (typdef as polytypdef))

          2. If ((tparam*{tparam <- tparam*} matches pattern [])), then

            1. (Let typ be ((SpecT (PolyD (tparam_e*{tparam_e <- tparam_e*}, []) -> typ_e) ((VarT tparam_e) as typ)*{tparam_e <- tparam_e*}) as typ))

            2. (Let cd be (ConsD (tparam_e*{tparam_e <- tparam_e*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> (ConsT (id_c dir_c typ_c val_c?{val_c <- val_c?})*{dir_c <- dir_c*, id_c <- id_c*, typ_c <- typ_c*, val_c? <- val_c?*} typ)))

            3. If ((ConsDef_wf: $bound_tids((BLOCK), C'') |- cd holds)), then

              1. (Let C' be $add_consdef((GLOBAL), C'', cid, cd))

              2. Result in C', (ExternConsM id_e tparam_hidden*{tparam_hidden <- tparam_hidden*} cparamIL*{cparamIL <- cparamIL*})

            3. Else Phantom#1190 ((method matches pattern `ExternConsM%%`)) /\ ((id_e = id_e')) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type polytypdef)) /\ ((tparam*{tparam <- tparam*} matches pattern [])) /\ (~(ConsDef_wf: $bound_tids((BLOCK), C'') |- cd holds))

          2. Else Phantom#1191 ((method matches pattern `ExternConsM%%`)) /\ ((id_e = id_e')) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ ((typdef has type polytypdef)) /\ (~(tparam*{tparam <- tparam*} matches pattern []))

        2. Else Phantom#1192 ((method matches pattern `ExternConsM%%`)) /\ ((id_e = id_e')) /\ ((typdef'?{typdef' <- typdef'?} matches pattern (_))) /\ (~(typdef has type polytypdef))

      6. Else Phantom#1193 ((method matches pattern `ExternConsM%%`)) /\ ((id_e = id_e')) /\ (~(typdef'?{typdef' <- typdef'?} matches pattern (_)))

    2. Else Phantom#1194 ((method matches pattern `ExternConsM%%`)) /\ (~(id_e = id_e'))

  2. Case (% matches pattern `ExternAbstractM%%%%`)

    1. (Let (ExternAbstractM id type_r tparam*{tparam <- tparam*} param*{param <- param*}) be method)

    2. If ((id_e =/= id)), then

      1. (Let fid be $to_fid(id, param*{param <- param*}))

      2. (Let C_1 be $add_typdefs((LOCAL), C'', tparam*{tparam <- tparam*}, ((MonoD ((VarT tparam) as typ)) as typdef)*{tparam <- tparam*}))

      3. (Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*{tid <- tid*})

      4. If ((tid*{tid <- tid*} matches pattern [])), then

        1. (Let C_2 be $set_localkind(C_1, (EXTERNABSTRACTMETHOD typ_r)))

        2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*{tid_fresh_p <- tid_fresh_p*})*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}

        3. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**}))

        4. (Let C_3 be $add_params((LOCAL), C_2, (paramIL*{paramIL <- paramIL*} as paramtyp*)))

        5. (Let fd be ((PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> (ExternAbstractMethodT (paramIL*{paramIL <- paramIL*} as paramtyp*) typ_r)) as funcdef))

        6. If ((FuncDef_wf: $bound_tids((BLOCK), C'') |- fd holds)), then

          1. (Let C_4 be $add_funcdef((BLOCK), C'', fid, fd))

          2. Result in C_4, (ExternAbstractM id typ_r tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} paramIL*{paramIL <- paramIL*})

        6. Else Phantom#1195 ((method matches pattern `ExternAbstractM%%%%`)) /\ ((id_e =/= id)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(FuncDef_wf: $bound_tids((BLOCK), C'') |- fd holds))

      4. Else Phantom#1196 ((method matches pattern `ExternAbstractM%%%%`)) /\ ((id_e =/= id)) /\ (~(tid*{tid <- tid*} matches pattern []))

    2. Else Phantom#1197 ((method matches pattern `ExternAbstractM%%%%`)) /\ (~(id_e =/= id))

  3. Case (% matches pattern `ExternM%%%%`)

    1. (Let (ExternM id type_r tparam*{tparam <- tparam*} param*{param <- param*}) be method)

    2. If ((id_e =/= id)), then

      1. (Let fid be $to_fid(id, param*{param <- param*}))

      2. (Let C_1 be $add_typdefs((LOCAL), C'', tparam*{tparam <- tparam*}, ((MonoD ((VarT tparam) as typ)) as typdef)*{tparam <- tparam*}))

      3. (Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*{tid <- tid*})

      4. If ((tid*{tid <- tid*} matches pattern [])), then

        1. (Let C_2 be $set_localkind(C_1, (EXTERNMETHOD)))

        2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*{tid_fresh_p <- tid_fresh_p*})*{param <- param*, paramIL <- paramIL*, tid_fresh_p* <- tid_fresh_p**}

        3. (Let (id_p dir_p typ_p val_p?{val_p <- val_p?}) be paramIL)*{dir_p <- dir_p*, id_p <- id_p*, paramIL <- paramIL*, typ_p <- typ_p*, val_p? <- val_p?*}

        4. (Let tparam_hidden*{tparam_hidden <- tparam_hidden*} be $concat_<tid>(tid_fresh_p*{tid_fresh_p <- tid_fresh_p*}*{tid_fresh_p* <- tid_fresh_p**}))

        5. (Let C_3 be $add_params((LOCAL), C_2, (paramIL*{paramIL <- paramIL*} as paramtyp*)))

        6. (Let fd be ((PolyFD (tparam*{tparam <- tparam*}, tparam_hidden*{tparam_hidden <- tparam_hidden*}) -> (ExternMethodT (paramIL*{paramIL <- paramIL*} as paramtyp*) typ_r)) as funcdef))

        7. If ((FuncDef_wf: $bound_tids((BLOCK), C'') |- fd holds)), then

          1. (Let C_4 be $add_funcdef((BLOCK), C'', fid, fd))

          2. Result in C_4, (ExternM id typ_r tparam*{tparam <- tparam*} tparam_hidden*{tparam_hidden <- tparam_hidden*} paramIL*{paramIL <- paramIL*})

        7. Else Phantom#1198 ((method matches pattern `ExternM%%%%`)) /\ ((id_e =/= id)) /\ ((tid*{tid <- tid*} matches pattern [])) /\ (~(FuncDef_wf: $bound_tids((BLOCK), C'') |- fd holds))

      4. Else Phantom#1199 ((method matches pattern `ExternM%%%%`)) /\ ((id_e =/= id)) /\ (~(tid*{tid <- tid*} matches pattern []))

    2. Else Phantom#1200 ((method matches pattern `ExternM%%%%`)) /\ (~(id_e =/= id))

;; ../../../../spec/4g-typing-decl.watsup:580.1-582.23
relation Methods_ok: C, id_e, method*{method <- method*}

1. Case analysis on method*{method <- method*}

  1. Case (% matches pattern [])

    1. Result in C, []

  2. Case (% matches pattern _ :: _)

    1. (Let method_h :: method_t*{method_t <- method_t*} be method*{method <- method*})

    2. (Method_ok: C id_e |- method_h : C' methodIL_h)

    3. (Methods_ok: C' id_e |- method_t*{method_t <- method_t*} : C'' methodIL_t*{methodIL_t <- methodIL_t*})

    4. Result in C'', methodIL_h :: methodIL_t*{methodIL_t <- methodIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:652.1-654.20
relation ParserState_ok: C, (statelabel block)

1. (Block_ok: (LOCAL) C (CONT) (INIT) |- block : C' flow blockIL)

2. If ((flow matches pattern `CONT`)), then

  1. Result in (statelabel blockIL)

2. Else Phantom#1201 (~(flow matches pattern `CONT`))

;; ../../../../spec/4g-typing-decl.watsup:713.1-715.26
relation Table_key_ok: p, C, tblctx, (expr matchkind)

1. (Expr_ok: p C |- expr : exprIL)

2. (Let (( typ ; _ctk )) be $annot(exprIL))

3. If ((Type_wf: $bound_tids(p, C) |- ((SetT typ) as typ) holds)), then

  1. If ((?((MatchKindV matchkind)) = $find_val(p, C, (CURRENT matchkind)))), then

    1. If ($check_table_key(matchkind, typ)), then

      1. (Let tblctx' be $update_mode(matchkind, typ, tblctx))

      2. (Let tblctx'' be $add_key((typ, matchkind), tblctx'))

      3. Result in tblctx'', (exprIL matchkind)

    1. Else Phantom#1202 ((Type_wf: $bound_tids(p, C) |- ((SetT typ) as typ) holds)) /\ ((?((MatchKindV matchkind)) = $find_val(p, C, (CURRENT matchkind)))) /\ (~$check_table_key(matchkind, typ))

  1. Else Phantom#1203 ((Type_wf: $bound_tids(p, C) |- ((SetT typ) as typ) holds)) /\ (~(?((MatchKindV matchkind)) = $find_val(p, C, (CURRENT matchkind))))

3. Else Phantom#1204 (~(Type_wf: $bound_tids(p, C) |- ((SetT typ) as typ) holds))

;; ../../../../spec/4g-typing-decl.watsup:717.1-717.44
def $check_table_key(matchkind, typ)

1. Case analysis on matchkind

  1. Case (% = "exact")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_errt(typ')), then

      1. Return true

    3. If ($is_boolt(typ')), then

      1. Return true

    4. If ($is_intt(typ')), then

      1. Return true

    5. If ($is_fintt(typ')), then

      1. Return true

    6. If ($is_fbitt(typ')), then

      1. Return true

    7. If ($is_vbitt(typ')), then

      1. Return true

    8. If ($is_enumt(typ')), then

      1. Return true

    9. (Let typ'' be $canon_typ(typ))

    10. If ((typ'' has type datatyp)), then

      1. (Let datatyp be (typ'' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

  2. Case (% = "optional")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_errt(typ')), then

      1. Return true

    3. If ($is_boolt(typ')), then

      1. Return true

    4. If ($is_intt(typ')), then

      1. Return true

    5. If ($is_fintt(typ')), then

      1. Return true

    6. If ($is_fbitt(typ')), then

      1. Return true

    7. If ($is_vbitt(typ')), then

      1. Return true

    8. If ($is_enumt(typ')), then

      1. Return true

    9. (Let typ'' be $canon_typ(typ))

    10. If ((typ'' has type datatyp)), then

      1. (Let datatyp be (typ'' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

  3. Case (% = "lpm")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_intt(typ')), then

      1. Return true

    3. If ($is_fintt(typ')), then

      1. Return true

    4. If ($is_fbitt(typ')), then

      1. Return true

    5. (Let typ'' be $canon_typ(typ))

    6. If ((typ'' has type datatyp)), then

      1. (Let datatyp be (typ'' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

  4. Case (% = "ternary")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_intt(typ')), then

      1. Return true

    3. If ($is_fintt(typ')), then

      1. Return true

    4. If ($is_fbitt(typ')), then

      1. Return true

    5. (Let typ'' be $canon_typ(typ))

    6. If ((typ'' has type datatyp)), then

      1. (Let datatyp be (typ'' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

  5. Case (% = "range")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_intt(typ')), then

      1. Return true

    3. If ($is_fintt(typ')), then

      1. Return true

    4. If ($is_fbitt(typ')), then

      1. Return true

    5. (Let typ'' be $canon_typ(typ))

    6. If ((typ'' has type datatyp)), then

      1. (Let datatyp be (typ'' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*{_(member, val) <- _(member, val)*}) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

2. Otherwise

  1. Return false

;; ../../../../spec/4g-typing-decl.watsup:767.1-769.26
relation Table_keys_ok: p, C, tblctx, tblkey*{tblkey <- tblkey*}

1. Case analysis on tblkey*{tblkey <- tblkey*}

  1. Case (% matches pattern [])

    1. Result in tblctx, []

  2. Case (% matches pattern _ :: _)

    1. (Let tblkey_h :: tblkey_t*{tblkey_t <- tblkey_t*} be tblkey*{tblkey <- tblkey*})

    2. (Table_key_ok: p C tblctx |- tblkey_h : tblctx' tblkeyIL_h)

    3. (Table_keys_ok: p C tblctx' |- tblkey_t*{tblkey_t <- tblkey_t*} : tblctx'' tblkeyIL_t*{tblkeyIL_t <- tblkeyIL_t*})

    4. Result in tblctx'', tblkeyIL_h :: tblkeyIL_t*{tblkeyIL_t <- tblkeyIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:783.1-785.26
relation Call_action_partial_ok: p, C, pt*{pt <- pt*}, (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*}

1. (Let (paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}) be $split_directionless_params((pt*{pt <- pt*} as paramIL*)))

2. If ((|paramIL_d*{paramIL_d <- paramIL_d*}| = |argIL*{argIL <- argIL*}|)), then

  1. (Call_convention_arg_ok: p C (ACT) |- (paramIL_d as paramtyp) ~~ (argIL, typ_a) : argIL')*{argIL <- argIL*, argIL' <- argIL'*, paramIL_d <- paramIL_d*, typ_a <- typ_a*}

  2. Result in paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}, argIL'*{argIL' <- argIL'*}

2. Else Phantom#1205 (~(|paramIL_d*{paramIL_d <- paramIL_d*}| = |argIL*{argIL <- argIL*}|))

;; ../../../../spec/4g-typing-decl.watsup:787.1-788.46
def $split_directionless_params(paramIL*{paramIL <- paramIL*})

1. Case analysis on paramIL*{paramIL <- paramIL*}

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let paramIL_h :: paramIL_t*{paramIL_t <- paramIL_t*} be paramIL*{paramIL <- paramIL*})

    2. (Let (_idIL dir _typeIL _val?{_val <- _val?}) be paramIL_h)

    3. Case analysis on (dir matches pattern `NO`)

      1. Case true

        1. (Let (paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}) be $split_directionless_params(paramIL_t*{paramIL_t <- paramIL_t*}))

        2. Return (paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_h :: paramIL_c*{paramIL_c <- paramIL_c*})

      2. Case false

        1. (Let (paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*}) be $split_directionless_params(paramIL_t*{paramIL_t <- paramIL_t*}))

        2. Return (paramIL_h :: paramIL_d*{paramIL_d <- paramIL_d*}, paramIL_c*{paramIL_c <- paramIL_c*})

;; ../../../../spec/4g-typing-decl.watsup:807.1-809.26
relation Table_action_ok: p, C, tblctx, (name arg*{arg <- arg*})

1. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

2. (Let funcdef'?{funcdef' <- funcdef'?} be $find_funcdef_by_name(p, C, name))

3. If ((funcdef'?{funcdef' <- funcdef'?} matches pattern (_))), then

  1. (Let ?(funcdef) be funcdef'?{funcdef' <- funcdef'?})

  2. If ((funcdef has type monofuncdef)), then

    1. (Let (MonoFD functyp) be (funcdef as monofuncdef))

    2. If ((functyp matches pattern `ActionT%`)), then

      1. (Let (ActionT pt*{pt <- pt*}) be functyp)

      2. (Call_action_partial_ok: p C |- pt*{pt <- pt*} (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*} : paramIL_d*{paramIL_d <- paramIL_d*} paramIL_c*{paramIL_c <- paramIL_c*} argIL'*{argIL' <- argIL'*})

      3. (Let tblctx' be $add_action((name, pt*{pt <- pt*}, argIL*{argIL <- argIL*}), tblctx))

      4. Result in tblctx', (name argIL'*{argIL' <- argIL'*} paramIL_d*{paramIL_d <- paramIL_d*} paramIL_c*{paramIL_c <- paramIL_c*})

    2. Else Phantom#1206 ((funcdef'?{funcdef' <- funcdef'?} matches pattern (_))) /\ ((funcdef has type monofuncdef)) /\ (~(functyp matches pattern `ActionT%`))

  2. Else Phantom#1207 ((funcdef'?{funcdef' <- funcdef'?} matches pattern (_))) /\ (~(funcdef has type monofuncdef))

3. Else Phantom#1208 (~(funcdef'?{funcdef' <- funcdef'?} matches pattern (_)))

;; ../../../../spec/4g-typing-decl.watsup:821.1-823.26
relation Table_actions_ok: p, C, tblctx, tblaction*{tblaction <- tblaction*}

1. Case analysis on tblaction*{tblaction <- tblaction*}

  1. Case (% matches pattern [])

    1. Result in tblctx, []

  2. Case (% matches pattern _ :: _)

    1. (Let tblaction_h :: tblaction_t*{tblaction_t <- tblaction_t*} be tblaction*{tblaction <- tblaction*})

    2. (Table_action_ok: p C tblctx |- tblaction_h : tblctx' tblactionIL_h)

    3. (Table_actions_ok: p C tblctx' |- tblaction_t*{tblaction_t <- tblaction_t*} : tblctx'' tblactionIL_t*{tblactionIL_t <- tblactionIL_t*})

    4. (Let tblactionIL*{tblactionIL <- tblactionIL*} be tblactionIL_h :: tblactionIL_t*{tblactionIL_t <- tblactionIL_t*})

    5. (Let (name argIL*{argIL <- argIL*} paramIL_d*{paramIL_d <- paramIL_d*} paramIL_c*{paramIL_c <- paramIL_c*}) be tblactionIL)*{argIL* <- argIL**, name <- name*, paramIL_c* <- paramIL_c**, paramIL_d* <- paramIL_d**, tblactionIL <- tblactionIL*}

    6. If ($distinct_<name>(name*{name <- name*})), then

      1. Result in tblctx'', tblactionIL_h :: tblactionIL_t*{tblactionIL_t <- tblactionIL_t*}

    6. Else Phantom#1209 ((tblaction*{tblaction <- tblaction*} matches pattern _ :: _)) /\ (~$distinct_<name>(name*{name <- name*}))

;; ../../../../spec/4g-typing-decl.watsup:841.1-843.29
relation Table_entry_keyset_ok: p, C, tblctx, (typ_k, text'), keyset

1. Case analysis on text'

  1. Case (% = "lpm")

    1. Case analysis on keyset

      1. Case (% matches pattern `ExprK%`)

        1. (Let (ExprK expr) be keyset)

        2. If ((expr matches pattern `MaskE%%`)), then

          1. (Let (MaskE expr_b expr_m) be expr)

          2. (Expr_ok: p C |- (MaskE expr_b expr_m) : exprIL)

          3. (Let (( typ' ; _ctk )) be $annot(exprIL))

          4. If ((typ' has type synthtyp)), then

            1. (Let synthtyp be (typ' as synthtyp))

            2. If ((synthtyp matches pattern `SetT%`)), then

              1. (Let (SetT typ) be synthtyp)

              2. (Let exprIL' be exprIL)

              3. If ((exprIL' matches pattern `MaskE%%%`)), then

                1. (Let (MaskE exprIL_b exprIL_m _annotIL) be exprIL')

                2. (Let mode be tblctx.MODE)

                3. If ((mode matches pattern `NOPRILPM%`)), then

                  1. (Let (NOPRILPM n_w) be mode)

                  2. (Eval_static: p C |- exprIL_m ~> val_m)

                  3. (Let i_m be $get_num(val_m))

                  4. (Let tblstate_e be $get_lpm_prefix((FBitV n_w $to_bitstr((n_w as int), i_m))))

                  5. If ((Sub_impl: typ << typ_k holds)), then

                    1. Result in tblstate_e, (ExprK exprIL)

                  5. Else Phantom#1210 ((text' = "lpm")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `MaskE%%`)) /\ ((typ' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ ((exprIL' matches pattern `MaskE%%%`)) /\ ((mode matches pattern `NOPRILPM%`)) /\ (~(Sub_impl: typ << typ_k holds))

                3. Else Phantom#1211 ((text' = "lpm")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `MaskE%%`)) /\ ((typ' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ ((exprIL' matches pattern `MaskE%%%`)) /\ (~(mode matches pattern `NOPRILPM%`))

              3. Else Phantom#1212 ((text' = "lpm")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `MaskE%%`)) /\ ((typ' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ (~(exprIL' matches pattern `MaskE%%%`))

            2. Else Phantom#1213 ((text' = "lpm")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `MaskE%%`)) /\ ((typ' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

          4. Else Phantom#1214 ((text' = "lpm")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `MaskE%%`)) /\ (~(typ' has type synthtyp))

        2. Else Phantom#1215 ((text' = "lpm")) /\ ((keyset matches pattern `ExprK%`)) /\ (~(expr matches pattern `MaskE%%`))

        3. If (~($is_maske(expr) \/ $is_rangee(expr))), then

          1. (Expr_ok: p C |- expr : exprIL)

          2. (Let (( typ ; ctk )) be $annot(exprIL))

          3. (Let mode be tblctx.MODE)

          4. If ((mode matches pattern `NOPRILPM%`)), then

            1. (Let (NOPRILPM n_w) be mode)

            2. If ((Sub_impl: typ << typ_k holds)), then

              1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk ))))

              2. Result in (LPM n_w), (ExprK exprIL')

            2. Else Phantom#1216 ((text' = "lpm")) /\ ((keyset matches pattern `ExprK%`)) /\ (~($is_maske(expr) \/ $is_rangee(expr))) /\ ((mode matches pattern `NOPRILPM%`)) /\ (~(Sub_impl: typ << typ_k holds))

          4. Else Phantom#1217 ((text' = "lpm")) /\ ((keyset matches pattern `ExprK%`)) /\ (~($is_maske(expr) \/ $is_rangee(expr))) /\ (~(mode matches pattern `NOPRILPM%`))

        3. Else Phantom#1218 ((text' = "lpm")) /\ ((keyset matches pattern `ExprK%`)) /\ (~~($is_maske(expr) \/ $is_rangee(expr)))

      2. Case (% matches pattern `DefaultK`)

        1. (Let mode be tblctx.MODE)

        2. If ((mode matches pattern `NOPRILPM%`)), then

          1. (Let (NOPRILPM n_w) be mode)

          2. Result in (LPM n_w), (DefaultK)

        2. Else Phantom#1219 ((text' = "lpm")) /\ ((keyset matches pattern `DefaultK`)) /\ (~(mode matches pattern `NOPRILPM%`))

      3. Case (% matches pattern `AnyK`)

        1. (Let mode be tblctx.MODE)

        2. If ((mode matches pattern `NOPRILPM%`)), then

          1. (Let (NOPRILPM _nat) be mode)

          2. Result in (LPM 0), (AnyK)

        2. Else Phantom#1220 ((text' = "lpm")) /\ ((keyset matches pattern `AnyK`)) /\ (~(mode matches pattern `NOPRILPM%`))

  2. Case (% = "ternary")

    1. If ((keyset matches pattern `ExprK%`)), then

      1. (Let (ExprK expr) be keyset)

      2. If ((expr matches pattern `MaskE%%`)), then

        1. (Let (MaskE expr_b expr_m) be expr)

        2. (Expr_ok: p C |- (MaskE expr_b expr_m) : exprIL)

        3. (Let (( typ' ; _ctk )) be $annot(exprIL))

        4. If ((typ' has type synthtyp)), then

          1. (Let synthtyp be (typ' as synthtyp))

          2. If ((synthtyp matches pattern `SetT%`)), then

            1. (Let (SetT typ) be synthtyp)

            2. If ((Sub_impl: typ << typ_k holds)), then

              1. Result in (NOLPM), (ExprK exprIL)

            2. Else Phantom#1221 ((text' = "ternary")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `MaskE%%`)) /\ ((typ' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ (~(Sub_impl: typ << typ_k holds))

          2. Else Phantom#1222 ((text' = "ternary")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `MaskE%%`)) /\ ((typ' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

        4. Else Phantom#1223 ((text' = "ternary")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `MaskE%%`)) /\ (~(typ' has type synthtyp))

      2. Else Phantom#1224 ((text' = "ternary")) /\ ((keyset matches pattern `ExprK%`)) /\ (~(expr matches pattern `MaskE%%`))

      3. If (~($is_maske(expr) \/ $is_rangee(expr))), then

        1. (Expr_ok: p C |- expr : exprIL)

        2. (Let (( typ ; ctk )) be $annot(exprIL))

        3. If ((Sub_impl: typ << typ_k holds)), then

          1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk ))))

          2. Result in (NOLPM), (ExprK exprIL')

        3. Else Phantom#1225 ((text' = "ternary")) /\ ((keyset matches pattern `ExprK%`)) /\ (~($is_maske(expr) \/ $is_rangee(expr))) /\ (~(Sub_impl: typ << typ_k holds))

      3. Else Phantom#1226 ((text' = "ternary")) /\ ((keyset matches pattern `ExprK%`)) /\ (~~($is_maske(expr) \/ $is_rangee(expr)))

    1. Else Phantom#1227 ((text' = "ternary")) /\ (~(keyset matches pattern `ExprK%`))

  3. Case (% = "range")

    1. If ((keyset matches pattern `ExprK%`)), then

      1. (Let (ExprK expr) be keyset)

      2. If ((expr matches pattern `RangeE%%`)), then

        1. (Let (RangeE expr_l expr_r) be expr)

        2. (Expr_ok: p C |- (RangeE expr_l expr_r) : exprIL)

        3. (Let (( typ' ; _ctk )) be $annot(exprIL))

        4. If ((typ' has type synthtyp)), then

          1. (Let synthtyp be (typ' as synthtyp))

          2. If ((synthtyp matches pattern `SetT%`)), then

            1. (Let (SetT typ) be synthtyp)

            2. If ((Sub_impl: typ << typ_k holds)), then

              1. Result in (NOLPM), (ExprK exprIL)

            2. Else Phantom#1228 ((text' = "range")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `RangeE%%`)) /\ ((typ' has type synthtyp)) /\ ((synthtyp matches pattern `SetT%`)) /\ (~(Sub_impl: typ << typ_k holds))

          2. Else Phantom#1229 ((text' = "range")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `RangeE%%`)) /\ ((typ' has type synthtyp)) /\ (~(synthtyp matches pattern `SetT%`))

        4. Else Phantom#1230 ((text' = "range")) /\ ((keyset matches pattern `ExprK%`)) /\ ((expr matches pattern `RangeE%%`)) /\ (~(typ' has type synthtyp))

      2. Else Phantom#1231 ((text' = "range")) /\ ((keyset matches pattern `ExprK%`)) /\ (~(expr matches pattern `RangeE%%`))

      3. If (~($is_maske(expr) \/ $is_rangee(expr))), then

        1. (Expr_ok: p C |- expr : exprIL)

        2. (Let (( typ ; ctk )) be $annot(exprIL))

        3. If ((Sub_impl: typ << typ_k holds)), then

          1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk ))))

          2. Result in (NOLPM), (ExprK exprIL')

        3. Else Phantom#1232 ((text' = "range")) /\ ((keyset matches pattern `ExprK%`)) /\ (~($is_maske(expr) \/ $is_rangee(expr))) /\ (~(Sub_impl: typ << typ_k holds))

      3. Else Phantom#1233 ((text' = "range")) /\ ((keyset matches pattern `ExprK%`)) /\ (~~($is_maske(expr) \/ $is_rangee(expr)))

    1. Else Phantom#1234 ((text' = "range")) /\ (~(keyset matches pattern `ExprK%`))

1. Else Phantom#1235 (~(text' = "lpm")) /\ (~(text' = "ternary")) /\ (~(text' = "range"))

2. Case analysis on keyset

  1. Case (% matches pattern `ExprK%`)

    1. (Let (ExprK expr) be keyset)

    2. If ((((text' =/= "lpm") /\ (text' =/= "ternary")) /\ (text' =/= "range"))), then

      1. If (~($is_maske(expr) \/ $is_rangee(expr))), then

        1. (Expr_ok: p C |- expr : exprIL)

        2. (Let (( typ ; ctk )) be $annot(exprIL))

        3. If ((Sub_impl: typ << typ_k holds)), then

          1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk ))))

          2. Result in (NOLPM), (ExprK exprIL')

        3. Else Phantom#1236 ((keyset matches pattern `ExprK%`)) /\ ((((text' =/= "lpm") /\ (text' =/= "ternary")) /\ (text' =/= "range"))) /\ (~($is_maske(expr) \/ $is_rangee(expr))) /\ (~(Sub_impl: typ << typ_k holds))

      1. Else Phantom#1237 ((keyset matches pattern `ExprK%`)) /\ ((((text' =/= "lpm") /\ (text' =/= "ternary")) /\ (text' =/= "range"))) /\ (~~($is_maske(expr) \/ $is_rangee(expr)))

    2. Else Phantom#1238 ((keyset matches pattern `ExprK%`)) /\ (~(((text' =/= "lpm") /\ (text' =/= "ternary")) /\ (text' =/= "range")))

  2. Case (% matches pattern `DefaultK`)

    1. If ((text' =/= "exact")), then

      1. Result in (NOLPM), (DefaultK)

    1. Else Phantom#1239 ((keyset matches pattern `DefaultK`)) /\ (~(text' =/= "exact"))

  3. Case (% matches pattern `AnyK`)

    1. If ((text' =/= "exact")), then

      1. Result in (NOLPM), (AnyK)

    1. Else Phantom#1240 ((keyset matches pattern `AnyK`)) /\ (~(text' =/= "exact"))

;; ../../../../spec/4g-typing-decl.watsup:935.1-937.32
relation Table_entry_keysets_state_ok: p, C, tblctx, tblstate', key*{key <- key*}, keyset*{keyset <- keyset*}

1. Case analysis on key*{key <- key*}

  1. Case (% matches pattern [])

    1. If ((keyset*{keyset <- keyset*} matches pattern [])), then

      1. Result in tblstate', []

    1. Else Phantom#1241 ((key*{key <- key*} matches pattern [])) /\ (~(keyset*{keyset <- keyset*} matches pattern []))

  2. Case (% matches pattern _ :: _)

    1. (Let key_h :: key_t*{key_t <- key_t*} be key*{key <- key*})

    2. If ((keyset*{keyset <- keyset*} matches pattern _ :: _)), then

      1. (Let keyset_h :: keyset_t*{keyset_t <- keyset_t*} be keyset*{keyset <- keyset*})

      2. (Table_entry_keyset_ok: p C tblctx |- key_h keyset_h : tblstate_1 keysetIL_h)

      3. (Let tblstate_2 be $update_state(tblstate', tblstate_1))

      4. (Table_entry_keysets_state_ok: p C tblctx tblstate_2 |- key_t*{key_t <- key_t*} keyset_t*{keyset_t <- keyset_t*} : tblstate_3 keysetIL_t*{keysetIL_t <- keysetIL_t*})

      5. Result in tblstate_3, keysetIL_h :: keysetIL_t*{keysetIL_t <- keysetIL_t*}

    2. Else Phantom#1242 ((key*{key <- key*} matches pattern _ :: _)) /\ (~(keyset*{keyset <- keyset*} matches pattern _ :: _))

;; ../../../../spec/4g-typing-decl.watsup:949.1-951.26
relation Table_entry_keysets_ok: p, C, tblctx, keyset*{keyset <- keyset*}

1. If ((keyset*{keyset <- keyset*} = [(DefaultK)])), then

  1. (Let mode be tblctx.MODE)

  2. If ((mode matches pattern `NOPRILPM%`)), then

    1. (Let (NOPRILPM nat) be mode)

    2. Result in (LPM nat), [(DefaultK)]

  2. Else Phantom#1243 ((keyset*{keyset <- keyset*} = [(DefaultK)])) /\ (~(mode matches pattern `NOPRILPM%`))

  3. If ((((tblctx.MODE = (NOPRI)) \/ (tblctx.MODE = (PRI))) \/ (tblctx.MODE = (PRILPM)))), then

    1. Result in (NOLPM), [(DefaultK)]

  3. Else Phantom#1244 ((keyset*{keyset <- keyset*} = [(DefaultK)])) /\ (~(((tblctx.MODE = (NOPRI)) \/ (tblctx.MODE = (PRI))) \/ (tblctx.MODE = (PRILPM))))

1. Else Phantom#1245 (~(keyset*{keyset <- keyset*} = [(DefaultK)]))

2. If ((keyset*{keyset <- keyset*} = [(AnyK)])), then

  1. (Let mode be tblctx.MODE)

  2. If ((mode matches pattern `NOPRILPM%`)), then

    1. (Let (NOPRILPM nat) be mode)

    2. Result in (LPM 0), [(AnyK)]

  2. Else Phantom#1246 ((keyset*{keyset <- keyset*} = [(AnyK)])) /\ (~(mode matches pattern `NOPRILPM%`))

  3. If ((((tblctx.MODE = (NOPRI)) \/ (tblctx.MODE = (PRI))) \/ (tblctx.MODE = (PRILPM)))), then

    1. Result in (NOLPM), [(AnyK)]

  3. Else Phantom#1247 ((keyset*{keyset <- keyset*} = [(AnyK)])) /\ (~(((tblctx.MODE = (NOPRI)) \/ (tblctx.MODE = (PRI))) \/ (tblctx.MODE = (PRILPM))))

2. Else Phantom#1248 (~(keyset*{keyset <- keyset*} = [(AnyK)]))

3. If ((|tblctx.KEYS| = |keyset*{keyset <- keyset*}|)), then

  1. (Table_entry_keysets_state_ok: p C tblctx (NOLPM) |- tblctx.KEYS keyset*{keyset <- keyset*} : tblstate keysetIL*{keysetIL <- keysetIL*})

  2. Result in tblstate, keysetIL*{keysetIL <- keysetIL*}

3. Else Phantom#1249 (~(|tblctx.KEYS| = |keyset*{keyset <- keyset*}|))

;; ../../../../spec/4g-typing-decl.watsup:975.1-977.29
relation Call_default_action_ok: p, C, pt*{pt <- pt*}, (argIL, typ)*{argIL <- argIL*, typ <- typ*}, argIL_a*{argIL_a <- argIL_a*}

1. If ((|pt*{pt <- pt*}| = |argIL*{argIL <- argIL*}|)), then

  1. (Let argIL_d*{argIL_d <- argIL_d*} be $filter_directionless_args(pt*{pt <- pt*}, argIL*{argIL <- argIL*}))

  2. If ((argIL_a = argIL_d))*{argIL_a <- argIL_a*, argIL_d <- argIL_d*}, then

    1. (Call_convention_arg_ok: p C (ACT) |- pt ~~ (argIL, typ) : argIL')*{argIL <- argIL*, argIL' <- argIL'*, pt <- pt*, typ <- typ*}

    2. Result in argIL'*{argIL' <- argIL'*}

  2. Else Phantom#1250 ((|pt*{pt <- pt*}| = |argIL*{argIL <- argIL*}|)) /\ (exists ~(argIL_a = argIL_d))*{argIL_a <- argIL_a*, argIL_d <- argIL_d*}

1. Else Phantom#1251 (~(|pt*{pt <- pt*}| = |argIL*{argIL <- argIL*}|))

;; ../../../../spec/4g-typing-decl.watsup:979.1-979.59
def $filter_directionless_args(paramtyp*{paramtyp <- paramtyp*}, argIL*{argIL <- argIL*})

1. Case analysis on paramtyp*{paramtyp <- paramtyp*}

  1. Case (% matches pattern [])

    1. If ((argIL*{argIL <- argIL*} matches pattern [])), then

      1. Return []

    1. Else Phantom#1252 ((paramtyp*{paramtyp <- paramtyp*} matches pattern [])) /\ (~(argIL*{argIL <- argIL*} matches pattern []))

  2. Case (% matches pattern _ :: _)

    1. (Let pt_h :: pt_t*{pt_t <- pt_t*} be paramtyp*{paramtyp <- paramtyp*})

    2. If ((argIL*{argIL <- argIL*} matches pattern _ :: _)), then

      1. (Let argIL_h :: argIL_t*{argIL_t <- argIL_t*} be argIL*{argIL <- argIL*})

      2. (Let (id dir typ val?{val <- val?}) be pt_h)

      3. If ((dir matches pattern `NO`)), then

        1. Return $filter_directionless_args(pt_t*{pt_t <- pt_t*}, argIL_t*{argIL_t <- argIL_t*})

      3. Else Phantom#1253 ((paramtyp*{paramtyp <- paramtyp*} matches pattern _ :: _)) /\ ((argIL*{argIL <- argIL*} matches pattern _ :: _)) /\ (~(dir matches pattern `NO`))

      4. Otherwise

        1. Return argIL_h :: $filter_directionless_args(pt_t*{pt_t <- pt_t*}, argIL_t*{argIL_t <- argIL_t*})

    2. Else Phantom#1254 ((paramtyp*{paramtyp <- paramtyp*} matches pattern _ :: _)) /\ (~(argIL*{argIL <- argIL*} matches pattern _ :: _))

;; ../../../../spec/4g-typing-decl.watsup:997.1-999.26
relation Table_entry_action_ok: p, C, tblctx, (name arg*{arg <- arg*})

1. (Let (paramtyp*, argIL*)?{(paramtyp*, argIL*) <- (paramtyp*, argIL*)?} be $find_action(tblctx, name))

2. If (((paramtyp*, argIL*)?{(paramtyp*, argIL*) <- (paramtyp*, argIL*)?} matches pattern (_))), then

  1. (Let ?((pt*{pt <- pt*}, argIL_a*{argIL_a <- argIL_a*})) be (paramtyp*, argIL*)?{(paramtyp*, argIL*) <- (paramtyp*, argIL*)?})

  2. (Arg_ok: p C |- arg : argIL typ_arg)*{arg <- arg*, argIL <- argIL*, typ_arg <- typ_arg*}

  3. (Call_default_action_ok: p C |- pt*{pt <- pt*} (argIL, typ_arg)*{argIL <- argIL*, typ_arg <- typ_arg*} argIL_a*{argIL_a <- argIL_a*} : argIL'*{argIL' <- argIL'*})

  4. (Let tblactionIL be (name argIL'*{argIL' <- argIL'*} (pt*{pt <- pt*} as paramIL*) []))

  5. Result in tblactionIL

2. Else Phantom#1255 (~((paramtyp*, argIL*)?{(paramtyp*, argIL*) <- (paramtyp*, argIL*)?} matches pattern (_)))

;; ../../../../spec/4g-typing-decl.watsup:1012.1-1014.29
relation Table_entry_priority_ok: cursor, C, tblctx, tblstate, expr''?{expr'' <- expr''?}

1. (Let expr be expr'')?{expr'' <- expr''?, expr <- expr?}

2. If ((cursor matches pattern `LOCAL`)), then

  1. If ((expr?{expr <- expr?} matches pattern ())), then

    1. If ((tblctx.MODE matches pattern `NOPRI`)), then

      1. Result in tblctx, ?()

    1. Else Phantom#1256 ((cursor matches pattern `LOCAL`)) /\ ((expr?{expr <- expr?} matches pattern ())) /\ (~(tblctx.MODE matches pattern `NOPRI`))

  1. Else Phantom#1257 ((cursor matches pattern `LOCAL`)) /\ (~(expr?{expr <- expr?} matches pattern ()))

  2. If ((tblstate matches pattern `LPM%`)), then

    1. (Let (LPM nat_prefix) be tblstate)

    2. If ((expr?{expr <- expr?} matches pattern ())), then

      1. (Let mode be tblctx.MODE)

      2. If ((mode matches pattern `NOPRILPM%`)), then

        1. (Let (NOPRILPM nat) be mode)

        2. Result in tblctx, ?()

      2. Else Phantom#1258 ((cursor matches pattern `LOCAL`)) /\ ((tblstate matches pattern `LPM%`)) /\ ((expr?{expr <- expr?} matches pattern ())) /\ (~(mode matches pattern `NOPRILPM%`))

    2. Else Phantom#1259 ((cursor matches pattern `LOCAL`)) /\ ((tblstate matches pattern `LPM%`)) /\ (~(expr?{expr <- expr?} matches pattern ()))

  2. Else Phantom#1260 ((cursor matches pattern `LOCAL`)) /\ (~(tblstate matches pattern `LPM%`))

2. Else Phantom#1261 (~(cursor matches pattern `LOCAL`))

3. (Let expr' be expr'')?{expr'' <- expr''?, expr' <- expr'?}

4. If ((cursor matches pattern `LOCAL`)), then

  1. If ((expr'?{expr' <- expr'?} matches pattern (_))), then

    1. (Let ?(expr) be expr'?{expr' <- expr'?})

    2. If (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))), then

      1. If (~tblctx.ENTRIES.CONST), then

        1. Case analysis on tblctx.PRIORITIES.VALUES

          1. Case (% = [])

            1. (Expr_ok: (LOCAL) C |- expr : exprIL)

            2. (Eval_static: (LOCAL) C |- exprIL ~> val)

            3. (Let i be $get_num(val))

            4. If ((i >= (0 as int))), then

              1. (Let tblctx' be tblctx[PRIORITIES.INIT = true])

              2. (Let tblctx'' be $add_priority(i, tblctx'))

              3. Result in tblctx'', ?((IntV i))

            4. Else Phantom#1262 ((cursor matches pattern `LOCAL`)) /\ ((expr'?{expr' <- expr'?} matches pattern (_))) /\ (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))) /\ (~tblctx.ENTRIES.CONST) /\ ((tblctx.PRIORITIES.VALUES = [])) /\ (~(i >= (0 as int)))

          2. Case (% =/= [])

            1. If (tblctx.PRIORITIES.INIT), then

              1. (Expr_ok: (LOCAL) C |- expr : exprIL)

              2. (Eval_static: (LOCAL) C |- exprIL ~> val)

              3. (Let i be $get_num(val))

              4. If ((i >= (0 as int))), then

                1. (Let tblctx' be $add_priority(i, tblctx))

                2. Result in tblctx', ?((IntV i))

              4. Else Phantom#1263 ((cursor matches pattern `LOCAL`)) /\ ((expr'?{expr' <- expr'?} matches pattern (_))) /\ (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))) /\ (~tblctx.ENTRIES.CONST) /\ ((tblctx.PRIORITIES.VALUES =/= [])) /\ (tblctx.PRIORITIES.INIT) /\ (~(i >= (0 as int)))

            1. Else Phantom#1264 ((cursor matches pattern `LOCAL`)) /\ ((expr'?{expr' <- expr'?} matches pattern (_))) /\ (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))) /\ (~tblctx.ENTRIES.CONST) /\ ((tblctx.PRIORITIES.VALUES =/= [])) /\ (~tblctx.PRIORITIES.INIT)

      1. Else Phantom#1265 ((cursor matches pattern `LOCAL`)) /\ ((expr'?{expr' <- expr'?} matches pattern (_))) /\ (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))) /\ (~~tblctx.ENTRIES.CONST)

    2. Else Phantom#1266 ((cursor matches pattern `LOCAL`)) /\ ((expr'?{expr' <- expr'?} matches pattern (_))) /\ (~((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM))))

  1. Else Phantom#1267 ((cursor matches pattern `LOCAL`)) /\ (~(expr'?{expr' <- expr'?} matches pattern (_)))

  2. If ((expr?{expr <- expr?} matches pattern ())), then

    1. If (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))), then

      1. Case analysis on tblctx.PRIORITIES.VALUES

        1. Case (% = [])

          1. Case analysis on tblctx.PRIORITIES.LARGEST_WINS

            1. Case true

              1. (Let i_size be tblctx.ENTRIES.SIZE)

              2. (Let i_delta be tblctx.PRIORITIES.DELTA)

              3. (Let i be (((i_size - (1 as int)) * i_delta) + (1 as int)))

              4. If ((i >= (0 as int))), then

                1. (Let tblctx' be $add_priority(i, tblctx))

                2. Result in tblctx', ?((IntV i))

              4. Else Phantom#1268 ((cursor matches pattern `LOCAL`)) /\ ((expr?{expr <- expr?} matches pattern ())) /\ (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))) /\ ((tblctx.PRIORITIES.VALUES = [])) /\ (tblctx.PRIORITIES.LARGEST_WINS) /\ (~(i >= (0 as int)))

            2. Case false

              1. (Let tblctx' be $add_priority((1 as int), tblctx))

              2. Result in tblctx', ?((IntV (1 as int)))

        2. Case (% =/= [])

          1. (Let i_delta be tblctx.PRIORITIES.DELTA)

          2. (Let i be $find_last_priority(tblctx))

          3. Case analysis on tblctx.PRIORITIES.LARGEST_WINS

            1. Case true

              1. (Let i' be (i - i_delta))

              2. If ((i' >= (0 as int))), then

                1. (Let tblctx' be $add_priority(i', tblctx))

                2. Result in tblctx', ?((IntV i'))

              2. Else Phantom#1269 ((cursor matches pattern `LOCAL`)) /\ ((expr?{expr <- expr?} matches pattern ())) /\ (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))) /\ ((tblctx.PRIORITIES.VALUES =/= [])) /\ (tblctx.PRIORITIES.LARGEST_WINS) /\ (~(i' >= (0 as int)))

            2. Case false

              1. (Let i' be (i + i_delta))

              2. If ((i' >= (0 as int))), then

                1. (Let tblctx' be $add_priority(i', tblctx))

                2. Result in tblctx', ?((IntV i'))

              2. Else Phantom#1270 ((cursor matches pattern `LOCAL`)) /\ ((expr?{expr <- expr?} matches pattern ())) /\ (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))) /\ ((tblctx.PRIORITIES.VALUES =/= [])) /\ (~tblctx.PRIORITIES.LARGEST_WINS) /\ (~(i' >= (0 as int)))

    1. Else Phantom#1271 ((cursor matches pattern `LOCAL`)) /\ ((expr?{expr <- expr?} matches pattern ())) /\ (~((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM))))

  2. Else Phantom#1272 ((cursor matches pattern `LOCAL`)) /\ (~(expr?{expr <- expr?} matches pattern ()))

4. Else Phantom#1273 (~(cursor matches pattern `LOCAL`))

;; ../../../../spec/4g-typing-decl.watsup:1105.1-1107.26
relation Table_entry_ok: p, C, tblctx, (bool keyset*{keyset <- keyset*} tblaction expr?{expr <- expr?})

1. (Table_entry_keysets_ok: p C tblctx |- keyset*{keyset <- keyset*} : tblstate keysetIL*{keysetIL <- keysetIL*})

2. (Table_entry_action_ok: p C tblctx |- tblaction : tblactionIL)

3. (Table_entry_priority_ok: p C tblctx tblstate |- expr?{expr <- expr?} : tblctx' val?{val <- val?})

4. Result in tblctx', (bool keysetIL*{keysetIL <- keysetIL*} tblactionIL val?{val <- val?})

;; ../../../../spec/4g-typing-decl.watsup:1118.1-1120.26
relation Table_entries_fold_ok: p, C, tblctx, tblentry*{tblentry <- tblentry*}

1. Case analysis on tblentry*{tblentry <- tblentry*}

  1. Case (% matches pattern [])

    1. Result in tblctx, []

  2. Case (% matches pattern _ :: _)

    1. (Let tblentry_h :: tblentry_t*{tblentry_t <- tblentry_t*} be tblentry*{tblentry <- tblentry*})

    2. (Table_entry_ok: p C tblctx |- tblentry_h : tblctx' tblentryIL_h)

    3. (Table_entries_fold_ok: p C tblctx' |- tblentry_t*{tblentry_t <- tblentry_t*} : tblctx'' tblentryIL_t*{tblentryIL_t <- tblentryIL_t*})

    4. Result in tblctx'', tblentryIL_h :: tblentryIL_t*{tblentryIL_t <- tblentryIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:1131.1-1133.26
relation Table_entries_ok: p, C, tblctx_0, (b tblentry*{tblentry <- tblentry*})

1. If (((|tblctx_0.KEYS| = 0) => (|tblentry*{tblentry <- tblentry*}| = 0))), then

  1. (Let tblctx_1 be tblctx_0[ENTRIES.SIZE = (|tblentry*{tblentry <- tblentry*}| as int)])

  2. (Let tblctx_2 be tblctx_1[ENTRIES.CONST = b])

  3. (Table_entries_fold_ok: p C tblctx_2 |- tblentry*{tblentry <- tblentry*} : tblctx_3 tblentryIL*{tblentryIL <- tblentryIL*})

  4. Result in tblctx_3, (b tblentryIL*{tblentryIL <- tblentryIL*})

1. Else Phantom#1274 (~((|tblctx_0.KEYS| = 0) => (|tblentry*{tblentry <- tblentry*}| = 0)))

;; ../../../../spec/4g-typing-decl.watsup:1148.1-1150.26
relation Table_default_ok: p, C, tblctx, (bool (name arg*{arg <- arg*}))

1. (Let (paramtyp*, argIL*)?{(paramtyp*, argIL*) <- (paramtyp*, argIL*)?} be $find_action(tblctx, name))

2. If (((paramtyp*, argIL*)?{(paramtyp*, argIL*) <- (paramtyp*, argIL*)?} matches pattern (_))), then

  1. (Let ?((pt*{pt <- pt*}, argIL_a*{argIL_a <- argIL_a*})) be (paramtyp*, argIL*)?{(paramtyp*, argIL*) <- (paramtyp*, argIL*)?})

  2. (Arg_ok: p C |- arg : argIL typ_a)*{arg <- arg*, argIL <- argIL*, typ_a <- typ_a*}

  3. (Call_default_action_ok: p C |- pt*{pt <- pt*} (argIL, typ_a)*{argIL <- argIL*, typ_a <- typ_a*} argIL_a*{argIL_a <- argIL_a*} : argIL'*{argIL' <- argIL'*})

  4. (Let tblactionIL be (name argIL'*{argIL' <- argIL'*} (pt*{pt <- pt*} as paramIL*) []))

  5. Result in (bool tblactionIL)

2. Else Phantom#1275 (~((paramtyp*, argIL*)?{(paramtyp*, argIL*) <- (paramtyp*, argIL*)?} matches pattern (_)))

;; ../../../../spec/4g-typing-decl.watsup:1166.1-1168.26
relation Table_custom_ok: p, C, tblctx, (b text' expr)

1. Case analysis on text'

  1. Case (% = "size")

    1. (Expr_ok: p C |- expr : exprIL)

    2. (Let (( typ ; _ctk )) be $annot(exprIL))

    3. If ((($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ))), then

      1. Result in tblctx, (b "size" exprIL)

    3. Else Phantom#1276 ((text' = "size")) /\ (~(($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ)))

  2. Case (% = "largest_priority_wins")

    1. (Expr_ok: p C |- expr : exprIL)

    2. (Let (( typ ; _ctk )) be $annot(exprIL))

    3. If ((typ = ((BoolT) as typ))), then

      1. (Eval_static: p C |- exprIL ~> val)

      2. If ((val matches pattern `BoolV%`)), then

        1. (Let (BoolV b_lw) be val)

        2. (Let tblctx' be tblctx[PRIORITIES.LARGEST_WINS = b_lw])

        3. Result in tblctx', (b "largest_priority_wins" exprIL)

      2. Else Phantom#1277 ((text' = "largest_priority_wins")) /\ ((typ = ((BoolT) as typ))) /\ (~(val matches pattern `BoolV%`))

    3. Else Phantom#1278 ((text' = "largest_priority_wins")) /\ (~(typ = ((BoolT) as typ)))

  3. Case (% = "priority_delta")

    1. (Expr_ok: p C |- expr : exprIL)

    2. (Let (( typ ; _ctk )) be $annot(exprIL))

    3. If ((($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ))), then

      1. (Eval_static: p C |- exprIL ~> val)

      2. (Let i_delta be $get_num(val))

      3. If ((i_delta > (0 as int))), then

        1. (Let tblctx' be tblctx[PRIORITIES.DELTA = i_delta])

        2. Result in tblctx', (b "priority_delta" exprIL)

      3. Else Phantom#1279 ((text' = "priority_delta")) /\ ((($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ))) /\ (~(i_delta > (0 as int)))

    3. Else Phantom#1280 ((text' = "priority_delta")) /\ (~(($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ)))

1. Else Phantom#1281 (~(text' = "size")) /\ (~(text' = "largest_priority_wins")) /\ (~(text' = "priority_delta"))

2. If ((((text' =/= "size") /\ (text' =/= "largest_priority_wins")) /\ (text' =/= "priority_delta"))), then

  1. (Expr_ok: p C |- expr : exprIL)

  2. Result in tblctx, (b text' exprIL)

2. Else Phantom#1282 (~(((text' =/= "size") /\ (text' =/= "largest_priority_wins")) /\ (text' =/= "priority_delta")))

;; ../../../../spec/4g-typing-decl.watsup:1203.1-1205.26
relation Table_prop_ok: p, C, tblctx, tblprop

1. Case analysis on tblprop

  1. Case (% matches pattern `KeyP%`)

    1. (Let (KeyP tblkeyprop) be tblprop)

    2. (Table_keys_ok: p C tblctx |- tblkeyprop : tblctx' tblkeypropIL)

    3. Result in tblctx', (KeyP tblkeypropIL)

  2. Case (% matches pattern `ActionP%`)

    1. (Let (ActionP tblactionprop) be tblprop)

    2. (Table_actions_ok: p C tblctx |- tblactionprop : tblctx' tblactionpropIL)

    3. Result in tblctx', (ActionP tblactionpropIL)

  3. Case (% matches pattern `EntryP%`)

    1. (Let (EntryP tblentryprop) be tblprop)

    2. (Table_entries_ok: p C tblctx |- tblentryprop : tblctx' tblentrypropIL)

    3. Result in tblctx', (EntryP tblentrypropIL)

  4. Case (% matches pattern `DefaultP%`)

    1. (Let (DefaultP tbldefaultprop) be tblprop)

    2. (Table_default_ok: p C tblctx |- tbldefaultprop : tbldefaultpropIL)

    3. Result in tblctx, (DefaultP tbldefaultpropIL)

  5. Case (% matches pattern `CustomP%`)

    1. (Let (CustomP tblcustomprop) be tblprop)

    2. (Table_custom_ok: p C tblctx |- tblcustomprop : tblctx' tblcustompropIL)

    3. Result in tblctx', (CustomP tblcustompropIL)

;; ../../../../spec/4g-typing-decl.watsup:1228.1-1230.26
relation Table_props_ok: p, C, tblctx, tblprop*{tblprop <- tblprop*}

1. Case analysis on tblprop*{tblprop <- tblprop*}

  1. Case (% matches pattern [])

    1. Result in tblctx, []

  2. Case (% matches pattern _ :: _)

    1. (Let tblprop_h :: tblprop_t*{tblprop_t <- tblprop_t*} be tblprop*{tblprop <- tblprop*})

    2. (Table_prop_ok: p C tblctx |- tblprop_h : tblctx' tblpropIL_h)

    3. (Table_props_ok: p C tblctx' |- tblprop_t*{tblprop_t <- tblprop_t*} : tblctx'' tblpropIL_t*{tblpropIL_t <- tblpropIL_t*})

    4. Result in tblctx'', tblpropIL_h :: tblpropIL_t*{tblpropIL_t <- tblpropIL_t*}

;; ../../../../spec/4g-typing-decl.watsup:1244.1-1246.26
relation Table_type_decl_ok: cursor, C, tblctx, id

1. If ((cursor matches pattern `BLOCK`)), then

  1. (Let id_e be $concat_text(["action_list(", id, ")"]))

  2. (Let (name, pt*{pt <- pt*}, argIL*{argIL <- argIL*})*{argIL* <- argIL**, name <- name*, pt* <- pt**} be tblctx.ACTIONS)

  3. (Let member be $string_of_name(name))*{member <- member*, name <- name*}

  4. (Let typ_e be ((TableEnumT id_e member*{member <- member*}) as typ))

  5. (Let val_e be (TableEnumFieldV id_e member))*{member <- member*, val_e <- val_e*}

  6. (Let id_f be $concat_text([id_e, ".", member]))*{id_f <- id_f*, member <- member*}

  7. (Let C' be $add_styps((BLOCK), C, id_f*{id_f <- id_f*}, (typ_e (NO) (LCTK) ?(val_e))*{val_e <- val_e*}))

  8. (Let id_s be $concat_text(["apply_result(", id, ")"]))

  9. (Let typ_s be ((TableStructT id_s [("hit", ((BoolT) as typ)), ("miss", ((BoolT) as typ)), ("action_run", typ_e)]) as typ))

  10. Result in C', typ_s

1. Else Phantom#1283 (~(cursor matches pattern `BLOCK`))

;; ../../../../spec/4h-typing-call.watsup:149.1-150.77
def $filter_default_args(paramtyp*{paramtyp <- paramtyp*}, id_deft*{id_deft <- id_deft*})

1. Case analysis on paramtyp*{paramtyp <- paramtyp*}

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let pt_h :: pt_t*{pt_t <- pt_t*} be paramtyp*{paramtyp <- paramtyp*})

    2. (Let (id_p _dir _typ _val?{_val <- _val?}) be pt_h)

    3. If (id_p is in id_deft*{id_deft <- id_deft*}), then

      1. Return $filter_default_args(pt_t*{pt_t <- pt_t*}, id_deft*{id_deft <- id_deft*})

    3. Else Phantom#1284 ((paramtyp*{paramtyp <- paramtyp*} matches pattern _ :: _)) /\ (~id_p is in id_deft*{id_deft <- id_deft*})

    4. Otherwise

      1. Return pt_h :: $filter_default_args(pt_t*{pt_t <- pt_t*}, id_deft*{id_deft <- id_deft*})

;; ../../../../spec/4h-typing-call.watsup:161.15-161.32
syntax pmap = map<id, paramtyp>

;; ../../../../spec/4h-typing-call.watsup:163.1-164.80
def $align_params_with_args(pt*{pt <- pt*}, (argIL, typ)*{argIL <- argIL*, typ <- typ*})

1. (Let (id _dir _typ _val?{_val <- _val?}) be pt)*{_dir <- _dir*, _typ <- _typ*, _val? <- _val?*, id <- id*, pt <- pt*}

2. (Let pmap be ({ (id -> pt)*{id <- id*, pt <- pt*} }))

3. (Let pt' be $align_params_with_args'(pmap, pt, (argIL, typ)))*{argIL <- argIL*, pt <- pt*, pt' <- pt'*, typ <- typ*}

4. Return pt'*{pt' <- pt'*}

;; ../../../../spec/4h-typing-call.watsup:165.1-166.97
def $align_params_with_args'(pmap, pt, (argIL, _typ))

1. Case analysis on argIL

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA _exprIL) be argIL)

    2. Return pt

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA id _exprIL?{_exprIL <- _exprIL?}) be argIL)

    2. (Let paramtyp?{paramtyp <- paramtyp?} be $find_map<id, paramtyp>(pmap, id))

    3. If ((paramtyp?{paramtyp <- paramtyp?} matches pattern (_))), then

      1. (Let ?(pt') be paramtyp?{paramtyp <- paramtyp?})

      2. Return pt'

    3. Else Phantom#1285 ((argIL matches pattern `NameA%%`)) /\ (~(paramtyp?{paramtyp <- paramtyp?} matches pattern (_)))

  3. Case (% matches pattern `AnyA`)

    1. Return pt

;; ../../../../spec/4h-typing-call.watsup:183.1-184.12
syntax typcstr = 
   | `KNOWN%`(typ)
   | `UNKNOWN`()

;; ../../../../spec/4h-typing-call.watsup:188.1-188.42
def $empty_cstr(tid*{tid <- tid*})

1. Return ({ (tid -> (UNKNOWN))*{tid <- tid*} })

;; ../../../../spec/4h-typing-call.watsup:194.1-194.63
def $gen_cstr(cstr, typ'', typ_a''')

1. Case analysis on typ''

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT tid) be abstyp)

        2. If ($in_set<tid>(tid, $dom_map<tid, typcstr>(cstr))), then

          1. Return $update_map<tid, typcstr>(cstr, tid, (KNOWN typ_a'''))

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd_p typ_p'*{typ_p' <- typ_p'*}) be abstyp)

        2. If ((typ_a''' has type abstyp)), then

          1. (Let abstyp' be (typ_a''' as abstyp))

          2. If ((abstyp' matches pattern `SpecT%%`)), then

            1. (Let (SpecT ptd_a typ_a'*{typ_a' <- typ_a'*}) be abstyp')

            2. (Let typ_p'' be $specialize_typdef((ptd_p as typdef), typ_p'*{typ_p' <- typ_p'*}))

            3. (Let typ_a'' be $specialize_typdef((ptd_a as typdef), typ_a'*{typ_a' <- typ_a'*}))

            4. Case analysis on ($is_nominal(typ_p'') /\ $is_nominal(typ_a''))

              1. Case true

                1. (Let cstr' be $gen_cstr(cstr, typ_p'', typ_a''))

                2. Return $gen_cstrs(cstr', typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})

              2. Case false

                1. (Let cstr' be $gen_cstr(cstr, typ_p'', typ_a''))

                2. Return cstr'

  2. Case (% has type aliastyp)

    1. (Let (DefT typ_p') be (typ'' as aliastyp))

    2. Return $gen_cstr(cstr, typ_p', typ_a''')

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT id typ_p') be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `NewT%%`)), then

            1. (Let (NewT id' typ_a') be datatyp')

            2. If ((id = id')), then

              1. Return $gen_cstr(cstr, typ_p', typ_a')

      2. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ'') be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `ListT%`)), then

            1. (Let (ListT typ_a''') be datatyp')

            2. Return $gen_cstr(cstr, typ'', typ_a''')

      3. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*{typ'' <- typ''*}) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `TupleT%`)), then

            1. (Let (TupleT typ_a'''*{typ_a''' <- typ_a'''*}) be datatyp')

            2. Return $gen_cstrs(cstr, typ''*{typ'' <- typ''*}, typ_a'''*{typ_a''' <- typ_a'''*})

      4. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ_p' i_p) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `StackT%%`)), then

            1. (Let (StackT typ_a' i_a) be datatyp')

            2. Return $gen_cstr(cstr, typ_p', typ_a')

      5. Case (% matches pattern `StructT%%`)

        1. (Let (StructT id (member_p, typ_p')*{member_p <- member_p*, typ_p' <- typ_p'*}) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `StructT%%`)), then

            1. (Let (StructT id' (member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) be datatyp')

            2. If ((id = id')), then

              1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})

      6. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT id (member_p, typ_p')*{member_p <- member_p*, typ_p' <- typ_p'*}) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `HeaderT%%`)), then

            1. (Let (HeaderT id' (member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) be datatyp')

            2. If ((id = id')), then

              1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})

      7. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT id (member_p, typ_p')*{member_p <- member_p*, typ_p' <- typ_p'*}) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `UnionT%%`)), then

            1. (Let (UnionT id' (member_a, typ_a')*{member_a <- member_a*, typ_a' <- typ_a'*}) be datatyp')

            2. If ((id = id')), then

              1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})

  4. Case (% has type objtyp)

    1. (Let objtyp be (typ'' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT id fdenv_p) be objtyp)

        2. If ((typ_a''' has type objtyp)), then

          1. (Let objtyp' be (typ_a''' as objtyp))

          2. If ((objtyp' matches pattern `ExternT%%`)), then

            1. (Let (ExternT id' fdenv_a) be objtyp')

            2. If ((id = id')), then

              1. (Let ({ (fid_p -> fd_p)*{fd_p <- fd_p*, fid_p <- fid_p*} }) be fdenv_p)

              2. (Let ({ (fid_a -> fd_a)*{fd_a <- fd_a*, fid_a <- fid_a*} }) be fdenv_a)

              3. If ($eq_set<fid>(({ fid_p*{fid_p <- fid_p*} }), ({ fid_a*{fid_a <- fid_a*} }))), then

                1. Return $gen_cstr_fd'(cstr, fid_p*{fid_p <- fid_p*}, fdenv_p, fdenv_a)

      2. Case (% matches pattern `ParserT%`)

        1. (Let (ParserT pt_p*{pt_p <- pt_p*}) be objtyp)

        2. If ((typ_a''' has type objtyp)), then

          1. (Let objtyp' be (typ_a''' as objtyp))

          2. If ((objtyp' matches pattern `ParserT%`)), then

            1. (Let (ParserT pt_a*{pt_a <- pt_a*}) be objtyp')

            2. (Let (_id dir typ_p' _val?{_val <- _val?}) be pt_p)*{_id <- _id*, _val? <- _val?*, dir <- dir*, pt_p <- pt_p*, typ_p' <- typ_p'*}

            3. (Let (_id' dir' typ_a' _val'?{_val' <- _val'?}) be pt_a)*{_id' <- _id'*, _val'? <- _val'?*, dir' <- dir'*, pt_a <- pt_a*, typ_a' <- typ_a'*}

            4. If ((dir' = dir))*{dir <- dir*, dir' <- dir'*}, then

              1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})

      3. Case (% matches pattern `ControlT%`)

        1. (Let (ControlT pt_p*{pt_p <- pt_p*}) be objtyp)

        2. If ((typ_a''' has type objtyp)), then

          1. (Let objtyp' be (typ_a''' as objtyp))

          2. If ((objtyp' matches pattern `ControlT%`)), then

            1. (Let (ControlT pt_a*{pt_a <- pt_a*}) be objtyp')

            2. (Let (_id dir typ_p' _val?{_val <- _val?}) be pt_p)*{_id <- _id*, _val? <- _val?*, dir <- dir*, pt_p <- pt_p*, typ_p' <- typ_p'*}

            3. (Let (_id' dir' typ_a' _val'?{_val' <- _val'?}) be pt_a)*{_id' <- _id'*, _val'? <- _val'?*, dir' <- dir'*, pt_a <- pt_a*, typ_a' <- typ_a'*}

            4. If ((dir' = dir))*{dir <- dir*, dir' <- dir'*}, then

              1. Return $gen_cstrs(cstr, typ_p'*{typ_p' <- typ_p'*}, typ_a'*{typ_a' <- typ_a'*})

      4. Case (% matches pattern `PackageT%`)

        1. (Let (PackageT typ''*{typ'' <- typ''*}) be objtyp)

        2. If ((typ_a''' has type objtyp)), then

          1. (Let objtyp' be (typ_a''' as objtyp))

          2. If ((objtyp' matches pattern `PackageT%`)), then

            1. (Let (PackageT typ_a'''*{typ_a''' <- typ_a'''*}) be objtyp')

            2. Return $gen_cstrs(cstr, typ''*{typ'' <- typ''*}, typ_a'''*{typ_a''' <- typ_a'''*})

2. If ((typ_a''' has type aliastyp)), then

  1. (Let (DefT typ_a') be (typ_a''' as aliastyp))

  2. Return $gen_cstr(cstr, typ'', typ_a')

3. Otherwise

  1. Return cstr

;; ../../../../spec/4h-typing-call.watsup:196.1-196.66
def $gen_cstrs(cstr, typ_p*{typ_p <- typ_p*}, typ_a*{typ_a <- typ_a*})

1. If ((|typ_p*{typ_p <- typ_p*}| = |typ_a*{typ_a <- typ_a*}|)), then

  1. (Let cstr' be $gen_cstr(cstr, typ_p, typ_a))*{cstr' <- cstr'*, typ_a <- typ_a*, typ_p <- typ_p*}

  2. Return $merge_cstrs(cstr, cstr'*{cstr' <- cstr'*})

1. Else Phantom#1286 (~(|typ_p*{typ_p <- typ_p*}| = |typ_a*{typ_a <- typ_a*}|))

;; ../../../../spec/4h-typing-call.watsup:198.1-198.74
def $gen_cstr_fd(cstr, fd_p, fd_a)

1. (Let (_id _dir typ_p _val?{_val <- _val?})*{_dir <- _dir*, _id <- _id*, _val? <- _val?*, typ_p <- typ_p*} be $get_params_funcdef(fd_p))

2. (Let (_id' _dir' typ_a _val'?{_val' <- _val'?})*{_dir' <- _dir'*, _id' <- _id'*, _val'? <- _val'?*, typ_a <- typ_a*} be $get_params_funcdef(fd_a))

3. (Let cstr' be $gen_cstrs(cstr, typ_p*{typ_p <- typ_p*}, typ_a*{typ_a <- typ_a*}))

4. (Let cstr'' be $gen_cstr(cstr', $get_typ_ret_funcdef(fd_p), $get_typ_ret_funcdef(fd_a)))

5. Return cstr''

;; ../../../../spec/4h-typing-call.watsup:200.1-200.77
def $gen_cstr_fd'(cstr, fid*{fid <- fid*}, fdenv_p, fdenv_a)

1. Case analysis on fid*{fid <- fid*}

  1. Case (% matches pattern [])

    1. Return cstr

  2. Case (% matches pattern _ :: _)

    1. (Let fid_h :: fid_t*{fid_t <- fid_t*} be fid*{fid <- fid*})

    2. (Let funcdef?{funcdef <- funcdef?} be $find_map<fid, funcdef>(fdenv_p, fid_h))

    3. If ((funcdef?{funcdef <- funcdef?} matches pattern (_))), then

      1. (Let ?(fd_p) be funcdef?{funcdef <- funcdef?})

      2. (Let funcdef'?{funcdef' <- funcdef'?} be $find_map<fid, funcdef>(fdenv_a, fid_h))

      3. If ((funcdef'?{funcdef' <- funcdef'?} matches pattern (_))), then

        1. (Let ?(fd_a) be funcdef'?{funcdef' <- funcdef'?})

        2. (Let cstr' be $gen_cstr_fd(cstr, fd_p, fd_a))

        3. Return $gen_cstr_fd'(cstr', fid_t*{fid_t <- fid_t*}, fdenv_p, fdenv_a)

      3. Else Phantom#1287 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ ((funcdef?{funcdef <- funcdef?} matches pattern (_))) /\ (~(funcdef'?{funcdef' <- funcdef'?} matches pattern (_)))

    3. Else Phantom#1288 ((fid*{fid <- fid*} matches pattern _ :: _)) /\ (~(funcdef?{funcdef <- funcdef?} matches pattern (_)))

;; ../../../../spec/4h-typing-call.watsup:202.1-202.74
def $merge_cstr(cstr_o, cstr_n)

1. (Let ({ tid_o*{tid_o <- tid_o*} }) be $dom_map<tid, typcstr>(cstr_o))

2. If ($eq_set<tid>($dom_map<tid, typcstr>(cstr_o), $dom_map<tid, typcstr>(cstr_n))), then

  1. Return $merge_cstr'(cstr_o, cstr_n, tid_o*{tid_o <- tid_o*}, ({ [] }))

2. Else Phantom#1289 (~$eq_set<tid>($dom_map<tid, typcstr>(cstr_o), $dom_map<tid, typcstr>(cstr_n)))

;; ../../../../spec/4h-typing-call.watsup:204.1-204.100
def $merge_cstr'(cstr_o, cstr_n, tid*{tid <- tid*}, cstr)

1. Case analysis on tid*{tid <- tid*}

  1. Case (% matches pattern [])

    1. Return cstr

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t*{tid_t <- tid_t*} be tid*{tid <- tid*})

    2. If (($find_map<tid, typcstr>(cstr_o, tid_h) = ?((UNKNOWN)))), then

      1. If (($find_map<tid, typcstr>(cstr_n, tid_h) = ?((UNKNOWN)))), then

        1. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (UNKNOWN)))

        2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')

      1. Else Phantom#1290 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ (($find_map<tid, typcstr>(cstr_o, tid_h) = ?((UNKNOWN)))) /\ (~($find_map<tid, typcstr>(cstr_n, tid_h) = ?((UNKNOWN))))

      2. (Let typcstr'?{typcstr' <- typcstr'?} be $find_map<tid, typcstr>(cstr_n, tid_h))

      3. If ((typcstr'?{typcstr' <- typcstr'?} matches pattern (_))), then

        1. (Let ?(typcstr) be typcstr'?{typcstr' <- typcstr'?})

        2. If ((typcstr matches pattern `KNOWN%`)), then

          1. (Let (KNOWN typ_n) be typcstr)

          2. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_n)))

          3. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')

        2. Else Phantom#1291 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ (($find_map<tid, typcstr>(cstr_o, tid_h) = ?((UNKNOWN)))) /\ ((typcstr'?{typcstr' <- typcstr'?} matches pattern (_))) /\ (~(typcstr matches pattern `KNOWN%`))

      3. Else Phantom#1292 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ (($find_map<tid, typcstr>(cstr_o, tid_h) = ?((UNKNOWN)))) /\ (~(typcstr'?{typcstr' <- typcstr'?} matches pattern (_)))

    2. Else Phantom#1293 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ (~($find_map<tid, typcstr>(cstr_o, tid_h) = ?((UNKNOWN))))

    3. (Let typcstr'?{typcstr' <- typcstr'?} be $find_map<tid, typcstr>(cstr_o, tid_h))

    4. If ((typcstr'?{typcstr' <- typcstr'?} matches pattern (_))), then

      1. (Let ?(typcstr) be typcstr'?{typcstr' <- typcstr'?})

      2. If ((typcstr matches pattern `KNOWN%`)), then

        1. (Let (KNOWN typ_o) be typcstr)

        2. If (($find_map<tid, typcstr>(cstr_n, tid_h) = ?((UNKNOWN)))), then

          1. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_o)))

          2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')

        2. Else Phantom#1294 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ ((typcstr'?{typcstr' <- typcstr'?} matches pattern (_))) /\ ((typcstr matches pattern `KNOWN%`)) /\ (~($find_map<tid, typcstr>(cstr_n, tid_h) = ?((UNKNOWN))))

        3. (Let typcstr'''?{typcstr''' <- typcstr'''?} be $find_map<tid, typcstr>(cstr_n, tid_h))

        4. If ((typcstr'''?{typcstr''' <- typcstr'''?} matches pattern (_))), then

          1. (Let ?(typcstr'') be typcstr'''?{typcstr''' <- typcstr'''?})

          2. If ((typcstr'' matches pattern `KNOWN%`)), then

            1. (Let (KNOWN typ_n) be typcstr'')

            2. Case analysis on (Sub_impl: typ_o << typ_n holds)

              1. Case true

                1. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_n)))

                2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')

              2. Case false

                1. If ((Sub_impl: typ_n << typ_o holds)), then

                  1. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_o)))

                  2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*{tid_t <- tid_t*}, cstr')

                1. Else Phantom#1295 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ ((typcstr'?{typcstr' <- typcstr'?} matches pattern (_))) /\ ((typcstr matches pattern `KNOWN%`)) /\ ((typcstr'''?{typcstr''' <- typcstr'''?} matches pattern (_))) /\ ((typcstr'' matches pattern `KNOWN%`)) /\ (~(Sub_impl: typ_o << typ_n holds)) /\ (~(Sub_impl: typ_n << typ_o holds))

          2. Else Phantom#1296 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ ((typcstr'?{typcstr' <- typcstr'?} matches pattern (_))) /\ ((typcstr matches pattern `KNOWN%`)) /\ ((typcstr'''?{typcstr''' <- typcstr'''?} matches pattern (_))) /\ (~(typcstr'' matches pattern `KNOWN%`))

        4. Else Phantom#1297 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ ((typcstr'?{typcstr' <- typcstr'?} matches pattern (_))) /\ ((typcstr matches pattern `KNOWN%`)) /\ (~(typcstr'''?{typcstr''' <- typcstr'''?} matches pattern (_)))

      2. Else Phantom#1298 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ ((typcstr'?{typcstr' <- typcstr'?} matches pattern (_))) /\ (~(typcstr matches pattern `KNOWN%`))

    4. Else Phantom#1299 ((tid*{tid <- tid*} matches pattern _ :: _)) /\ (~(typcstr'?{typcstr' <- typcstr'?} matches pattern (_)))

;; ../../../../spec/4h-typing-call.watsup:206.1-206.76
def $merge_cstrs(cstr, map<tid, typcstr>*{map<tid, typcstr> <- map<tid, typcstr>*})

1. Case analysis on map<tid, typcstr>*{map<tid, typcstr> <- map<tid, typcstr>*}

  1. Case (% matches pattern [])

    1. Return cstr

  2. Case (% matches pattern _ :: _)

    1. (Let cstr_h :: cstr_t*{cstr_t <- cstr_t*} be map<tid, typcstr>*{map<tid, typcstr> <- map<tid, typcstr>*})

    2. (Let cstr' be $merge_cstr(cstr, cstr_h))

    3. (Let cstr'' be $merge_cstrs(cstr', cstr_t*{cstr_t <- cstr_t*}))

    4. Return cstr''

;; ../../../../spec/4h-typing-call.watsup:208.1-208.54
def $resolve_cstrs(set<pair<tid, typcstr>>')

1. If ((set<pair<tid, typcstr>>' = ({ [] }))), then

  1. Return ({ [] })

1. Else Phantom#1300 (~(set<pair<tid, typcstr>>' = ({ [] })))

2. (Let ({ pair<tid, typcstr>*{pair<tid, typcstr> <- pair<tid, typcstr>*} }) be set<pair<tid, typcstr>>')

3. If ((pair<tid, typcstr>*{pair<tid, typcstr> <- pair<tid, typcstr>*} matches pattern _ :: _)), then

  1. (Let (tid_h -> typcstr) :: (tid_t -> typcstr_t)*{tid_t <- tid_t*, typcstr_t <- typcstr_t*} be pair<tid, typcstr>*{pair<tid, typcstr> <- pair<tid, typcstr>*})

  2. If ((typcstr matches pattern `KNOWN%`)), then

    1. (Let (KNOWN typ_h) be typcstr)

    2. If ((typ_h =/= ((AnyT) as typ))), then

      1. (Let ({ (tid_t' -> typ_t')*{tid_t' <- tid_t'*, typ_t' <- typ_t'*} }) be $resolve_cstrs(({ (tid_t -> typcstr_t)*{tid_t <- tid_t*, typcstr_t <- typcstr_t*} })))

      2. Return $add_map<tid, typ>(({ (tid_t' -> typ_t')*{tid_t' <- tid_t'*, typ_t' <- typ_t'*} }), tid_h, typ_h)

    2. Else Phantom#1301 ((pair<tid, typcstr>*{pair<tid, typcstr> <- pair<tid, typcstr>*} matches pattern _ :: _)) /\ ((typcstr matches pattern `KNOWN%`)) /\ (~(typ_h =/= ((AnyT) as typ)))

  2. Else Phantom#1302 ((pair<tid, typcstr>*{pair<tid, typcstr> <- pair<tid, typcstr>*} matches pattern _ :: _)) /\ (~(typcstr matches pattern `KNOWN%`))

3. Else Phantom#1303 (~(pair<tid, typcstr>*{pair<tid, typcstr> <- pair<tid, typcstr>*} matches pattern _ :: _))

;; ../../../../spec/4h-typing-call.watsup:332.1-332.56
def $infer_targs(tid*{tid <- tid*}, (id dir typ_p val?{val <- val?})*{dir <- dir*, id <- id*, typ_p <- typ_p*, val? <- val?*}, typ_a*{typ_a <- typ_a*})

1. (Let cstr be $empty_cstr(tid*{tid <- tid*}))

2. (Let cstr' be $gen_cstrs(cstr, typ_p*{typ_p <- typ_p*}, typ_a*{typ_a <- typ_a*}))

3. Return $resolve_cstrs(cstr')

;; ../../../../spec/4h-typing-call.watsup:438.1-439.43
def $is_table_apply_in_action_arg(argIL)

1. Return false
